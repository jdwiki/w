<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Assembly Dili Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/assembly/</link>
    <description>Recent content in Assembly Dili Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Assembly Dili&#39;ni kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/assembly/assembly-dilini-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/assembly-dilini-kullanmaya-baslama/</guid>
      <description>Giriiş # Montaj dili, işlemci mantığının üzerinde çalıştığı gerçek bit ve bayt dizisi olan, insan tarafından okunabilir bir makine dili veya makine kodu biçimidir. İnsanların anımsatıcılarda okuması ve programlaması ikili, sekizli veya onaltılıya göre genellikle daha kolaydır, bu nedenle insanlar genellikle kod derleme dilinde yazar ve ardından bunu işlemci tarafından anlaşılan makine dili biçimine dönüştürmek için bir veya daha fazla program kullanır.
ÖRNEK:
mov eax, 4 cmp eax, 5 je point Assembler, Assembly dili programını okuyan, onu ayrıştıran ve karşılık gelen makine dilini üreten bir programdır.</description>
    </item>
    
    <item>
      <title>Kayıtlar</title>
      <link>https://www.wikiod.com/tr/assembly/kaytlar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/kaytlar/</guid>
      <description>Kayıtlar nedir?
İşlemci sayısal değerler (sayılar) üzerinde çalışabilir, ancak bunların önce bir yerde saklanması gerekir. Veriler çoğunlukla bellekte veya komut işlem kodunun içinde (genellikle bellekte de depolanır) veya doğrudan işlemciye yerleştirilmiş özel çip üstü bellekte depolanır, buna kayıt denir.
Kayıttaki değerle çalışmak için, onu adrese göre adreslemeniz gerekmez, ancak örneğin x86&amp;rsquo;da &amp;lsquo;ax&amp;rsquo; veya Z80&amp;rsquo;de &amp;lsquo;A&amp;rsquo; veya ARM&amp;rsquo;de &amp;lsquo;r0&amp;rsquo; gibi özel anımsatıcı &amp;ldquo;adlar&amp;rdquo; kullanılır.
Bazı işlemciler, hemen hemen tüm kayıtların eşit olduğu ve tüm amaçlar için kullanılabileceği (genellikle RISC işlemciler grubu) bir şekilde yapılandırılmıştır, diğerleri ise yalnızca bazı kayıtlar aritmetik için kullanılabildiğinde (&amp;ldquo;akümülatör&amp;rdquo; üzerinde farklı bir uzmanlığa sahiptir).</description>
    </item>
    
    <item>
      <title>Yığın</title>
      <link>https://www.wikiod.com/tr/assembly/ygn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/ygn/</guid>
      <description>Bilgisayar yığını, bir kitap yığını gibidir. PUSH en üste bir tane ekler ve POP en yukarıyı alır. Gerçek hayatta olduğu gibi yığın sonsuz olamaz, bu nedenle maksimum boyutu vardır. Yığın, algoritmaları sıralamak, daha büyük miktarda veriyi işlemek veya başka bir işlem yaparken kayıtların güvenli değerlerine ulaşmak için kullanılabilir.
Zilog Z80 Yığını # sp kaydedicisi yığın işaretçisi olarak kullanılır ve yığında saklanan son değeri gösterir (yığının &amp;ldquo;topu&amp;rdquo;). Böylece EX (sp),hl, hl değerini yığının üstündeki değerle değiştirecektir.</description>
    </item>
    
    <item>
      <title>glibc kullanmayan Linux elf64 örnekleri</title>
      <link>https://www.wikiod.com/tr/assembly/glibc-kullanmayan-linux-elf64-ornekleri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/glibc-kullanmayan-linux-elf64-ornekleri/</guid>
      <description>Kullanıcı arayüzü # Modern bilgi işlem sistemlerinde devam eden işlemlerin %80&amp;rsquo;inin Linux, OSX ve Windows için çekirdek kodu gibi kullanıcı etkileşimi gerektirmediğini söylemeye cüret ediyorum. Bunu yapanlar için klavye (işaretleme aygıtları) ve konsol aracılığıyla etkileşim olmak üzere iki temel ilke vardır. Bu örnek ve serimdeki diğerleri, metin tabanlı konsol (VT100 öykünmesi) ve klavyeye yöneliktir.
Bu örnek kendi içinde çok basittir, ancak daha karmaşık algoritmalar için temel bir yapı taşıdır.Subrtx.asm
STDIN equ 0 STDOUT equ 1 SYS_READ equ 0 SYS_WRITE equ 1 global gets, strlen, print, atoq section .</description>
    </item>
    
    <item>
      <title>Akış kontrolü</title>
      <link>https://www.wikiod.com/tr/assembly/aks-kontrolu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/aks-kontrolu/</guid>
      <description>Önemsiz olmayan her yazılım parçası, program akışını koşullara göre yönlendirmek için akış kontrol yapılarına ihtiyaç duyar.
En düşük seviyeli programlama dili olan Assembly, kontrol yapıları için yalnızca ilkelleri sağlar. Tipik olarak, makine işlemleri CPU&amp;rsquo;daki işaretleri etkiler ve koşullu dallar/atlamalar akış kontrolünü uygular. Montajda, tüm üst düzey kontrol yapılarının bu tür ilkellerden oluşturulması gerekir.
İÇİN &amp;hellip; Z80 Montajında ​​SONRAKİ # Z80&amp;rsquo;in döngü sayımlarını uygulamak için özel bir talimatı vardır: &amp;ldquo;DJNZ&amp;rdquo;, &amp;ldquo;B kaydının azalması ve sıfır değilse atlama&amp;rdquo; anlamına gelir.</description>
    </item>
    
    <item>
      <title>kesintiler</title>
      <link>https://www.wikiod.com/tr/assembly/kesintiler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/assembly/kesintiler/</guid>
      <description>Neden Kesintilere ihtiyacımız var
Hayal edelim: Bilgisayarımız bir tuş takımına bağlı. Bir şey girmek istiyoruz. Tuşa bastığımızda hiçbir şey olmuyor çünkü bilgisayar farklı şeylerle uğraşıyor ve ondan bir şey istediğimizi fark etmiyor. Kesintilere ihtiyacımız var!
Kesintiler yazılım (INT 80h) veya donanım (tuşa basma) tarafından tetiklenir, bir Call gibi davranırlar (belirli bir konuma atlarlar, kodu yürütürler ve tekrar geri atlarlar).
Z80&amp;rsquo;de Kesintilerle Çalışma: # Z80, modern işlemciler gibi Kesinti tablosuna sahip değildir.</description>
    </item>
    
  </channel>
</rss>
