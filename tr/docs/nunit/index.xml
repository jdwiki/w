<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rahibe Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/nunit/</link>
    <description>Recent content in rahibe Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/nunit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>nunit&#39;e başlarken</title>
      <link>https://www.wikiod.com/tr/nunit/nunite-baslarken/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/nunit/nunite-baslarken/</guid>
      <description>Assert.Equals&amp;rsquo;ı neden kullanamıyorsunuz? # Hem Nunit hem de MSTest için Assert.Equals()&amp;lsquo;i neden kullanamadığınızı hiç merak ettiniz. Eğer yapmadıysanız, belki başlangıç ​​olarak bu yöntemi kullanamayacağınızı bilmelisiniz. Bunun yerine, iki nesneyi eşitlik açısından karşılaştırmak için Assert.AreEqual()&amp;lsquo;ı kullanırsınız.
Buradaki sebep çok basit. Assert sınıfı, herhangi bir sınıf gibi, belirli bir nesnenin geçerli nesneye eşit olup olmadığını kontrol etmek için genel bir sanal Equals yöntemine sahip System.Object öğesinden miras alır. Bu nedenle, eşittir yöntemini çağırmak, bir birim testinde Assert sınıfıyla ilgisi olmayan iki nesneyi karşılaştırmak yerine yapacağınız gibi bir hata olacaktır.</description>
    </item>
    
    <item>
      <title>Kısıtlama modeli için özel bir kısıtlama yazın</title>
      <link>https://www.wikiod.com/tr/nunit/kstlama-modeli-icin-ozel-bir-kstlama-yazn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/nunit/kstlama-modeli-icin-ozel-bir-kstlama-yazn/</guid>
      <description>Bir tamsayıyı yaklaşık olarak eşleştir # Bir sayıyla eşleşen, ancak yaklaşık olarak bir kısıtlama yazmak istediğimizi varsayalım. Diyelim ki, bir ankette &amp;lsquo;95&amp;rsquo; kişiniz olması gerekiyor, ancak &amp;lsquo;93&amp;rsquo; veya &amp;lsquo;96&amp;rsquo; da yapacaktır. Formun özel bir kısıtlamasını yazabiliriz:
public class AlmostEqualToConstraint : Constraint { readonly int _expected; readonly double _expectedMin; readonly double _expectedMax; readonly int _percentageTolerance; public AlmostEqualToConstraint(int expected, int percentageTolerance) { _expected = expected; _expectedMin = expected * (1 - (double)percentageTolerance / 100); _expectedMax = expected * (1 + (double)percentageTolerance / 100); _percentageTolerance = percentageTolerance; Description = $&amp;quot;AlmostEqualTo {expected} with a tolerance of {percentageTolerance}%&amp;quot;; } public override ConstraintResult ApplyTo&amp;lt;TActual&amp;gt;(TActual actual) { if (typeof(TActual) !</description>
    </item>
    
    <item>
      <title>Akıcı İddialar</title>
      <link>https://www.wikiod.com/tr/nunit/akc-iddialar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/nunit/akc-iddialar/</guid>
      <description>NUnit&amp;rsquo;in Assert.That() formu, ikinci parametresi olarak kısıtlamaların kullanımını destekler. NUnit tarafından kullanıma hazır olarak sağlanan tüm kısıtlamalar, &amp;lsquo;Is&amp;rsquo;, &amp;lsquo;Has&amp;rsquo; ve &amp;lsquo;Does&amp;rsquo; statik sınıfları aracılığıyla kullanılabilir. Kısıtlamalar, yerleşik &amp;ldquo;And&amp;rdquo;, &amp;ldquo;Or&amp;rdquo; ve &amp;ldquo;With&amp;rdquo; yöntemleri kullanılarak akıcı ifadelerde birleştirilebilir. İfadeler, &amp;ldquo;AtMost&amp;rdquo; ve &amp;ldquo;Contains&amp;rdquo; gibi &amp;ldquo;ConstraintExpression&amp;rdquo; içindeki birçok yöntem kullanılarak uygun şekilde genişletilebilir.
Gelişmiş Kısıtlama Kullanımı # Büyük akıcı iddiaların okunması zorlaşır, ancak iyi ToString() uygulamalarına sahip sınıflarla birleştirildiğinde, çok faydalı hata mesajları üretebilirler.</description>
    </item>
    
    <item>
      <title>Test yürütme ve yaşam döngüsü</title>
      <link>https://www.wikiod.com/tr/nunit/test-yurutme-ve-yasam-dongusu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/nunit/test-yurutme-ve-yasam-dongusu/</guid>
      <description>Testleri belirli bir sırayla yürütme # Normalde testleriniz, yürütme sırasını önemsemeyecek şekilde oluşturulmalıdır. Ancak, bu kuralı çiğnemeniz gerektiğinde her zaman bir uç durum olacaktır.
Karşılaştığım bir senaryo, belirli bir süreçte yalnızca bir R Motorunu başlatabileceğiniz ve atıldıktan sonra yeniden başlatamazsınız, R.NET ile oldu. Testlerimden biri motorun elden çıkarılmasıyla ilgiliydi ve bu test diğer test(ler)den önce yapılırsa başarısız olacaktı.
Bunu Nunit kullanarak sırayla çalıştırmayı nasıl başardığıma dair bir kod parçacığını aşağıda bulacaksınız.</description>
    </item>
    
    <item>
      <title>Öznitellikler</title>
      <link>https://www.wikiod.com/tr/nunit/oznitellikler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/nunit/oznitellikler/</guid>
      <description>NUnit&amp;rsquo;in 1. Versiyonu, kalıtım ve adlandırma kurallarına dayalı testleri tanımlamak için klasik yaklaşımı kullandı. Sürüm 2.0&amp;rsquo;dan itibaren, NUnit bu amaç için özel öznitelikler kullanmıştır.
NUnit test fikstürleri bir çerçeve sınıfından miras almadığından, geliştirici kalıtımı başka şekillerde kullanmakta serbesttir. Ve testleri adlandırmak için keyfi bir kural olmadığından, ad seçimi tamamen testin amacını iletmeye yönelik olabilir.
Tüm NUnit öznitelikleri, NUnit.Framework ad alanında bulunur. Testleri içeren her kaynak dosya, o ad alanı için bir using ifadesi içermelidir ve proje, nunit.</description>
    </item>
    
  </channel>
</rss>
