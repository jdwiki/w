<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julia Dil Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/julia-lang/</link>
    <description>Recent content in Julia Dil Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/julia-lang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Julia Language&#39;i kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/julia-lang/julia-languagei-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/julia-languagei-kullanmaya-baslama/</guid>
      <description>Selam Dünya! # println(&amp;quot;Hello, World!&amp;quot;) Julia&amp;rsquo;yı çalıştırmak için önce web sitesinin indirme sayfasından tercümanı edinin. Mevcut kararlı sürüm v0.5.0&amp;rsquo;dır ve bu sürüm çoğu kullanıcı için önerilir. Bazı paket geliştiricileri veya uzman kullanıcılar, çok daha az kararlı olan gece derlemesini kullanmayı seçebilir.
Yorumlayıcıya sahip olduğunuzda, programınızı hello.jl adlı bir dosyaya yazın. Daha sonra bir sistem terminalinden şu şekilde çalıştırılabilir:
$ julia hello.jl Hello, World! Julia, &amp;ldquo;julia&amp;rdquo; programını çalıştırarak etkileşimli olarak da çalıştırılabilir.</description>
    </item>
    
    <item>
      <title>Döngüler için</title>
      <link>https://www.wikiod.com/tr/julia-lang/donguler-icin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/donguler-icin/</guid>
      <description>Sözdizimi # yinelemede i için; &amp;hellip;; son koşuldayken; &amp;hellip;; son kırmak devam et yinelemede i için @parallel (op); &amp;hellip;; son yinelemede i için @parallel; &amp;hellip;; son @goto etiketi @etiket etiketi Kodun daha kısa ve okunmasını kolaylaştırdığında, döngüler yerine &amp;ldquo;harita&amp;rdquo; veya &amp;ldquo;filtre&amp;rdquo; gibi daha yüksek dereceli işlevleri kullanmayı düşünün.
En küçük asal çarpanı bulun # Bazı durumlarda, bir döngünün tamamını bitirmeden önce bir işlevden geri dönmek istenebilir. Bunun için &amp;ldquo;dönüş&amp;rdquo; ifadesi kullanılabilir.</description>
    </item>
    
    <item>
      <title>Kapanışlar</title>
      <link>https://www.wikiod.com/tr/julia-lang/kapanslar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/kapanslar/</guid>
      <description>Sözdizimi # x -&amp;gt; [gövde] (x, y) -&amp;gt; [gövde] (xs&amp;hellip;) -&amp;gt; [gövde] Julia&amp;rsquo;nın eski sürümlerinde, kapatmalar ve anonim işlevlerin çalışma zamanı performans cezası vardı. Bu ceza 0,5&amp;rsquo;te elimine edilmiştir.
son sürüm Kapanışlara Giriş # İşlevler, Julia programlamasının önemli bir parçasıdır. Doğrudan modüller içinde tanımlanabilirler, bu durumda işlevlere üst düzey olarak atıfta bulunulur. Ancak fonksiyonlar, diğer fonksiyonlar içinde de tanımlanabilir. Bu tür işlevlere &amp;ldquo;kapamalar&amp;rdquo; denir.
Kapanışlar, değişkenleri dış işlevlerinde yakalar. Bir üst düzey işlev, yalnızca modüllerindeki global değişkenleri, işlev parametrelerini veya yerel değişkenleri kullanabilir:</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/tr/julia-lang/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/json/</guid>
      <description>Sözdizimi # JSON kullanarak JSON.parse(str) JSON.json(nesne) JSON.print(io, nesne, girinti) Ne Julia &amp;ldquo;Dict&amp;rdquo; ne de JSON nesneleri doğal olarak sıralanmadığından, bir JSON nesnesindeki anahtar/değer çiftlerinin sırasına güvenmemek en iyisidir.
JSON.jl&amp;rsquo;yi yükleme # JSON, popüler bir veri değişim biçimidir. Julia için en popüler JSON kitaplığı JSON.jl. Bu paketi kurmak için paket yöneticisini kullanın:
julia&amp;gt; Pkg.add(&amp;quot;JSON&amp;quot;) Bir sonraki adım, paketin makinenizde çalışıp çalışmadığını test etmektir:
julia&amp;gt; Pkg.test(&amp;quot;JSON&amp;quot;) Tüm testler başarılı olursa, kitaplık kullanıma hazırdır.</description>
    </item>
    
    <item>
      <title>Giriş</title>
      <link>https://www.wikiod.com/tr/julia-lang/giris/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/giris/</guid>
      <description>Sözdizimi # okuma satırı() okuma satırları() okuma dizisi (STDIN) chomp(str) aç(f, dosya) göz çizgisi (io) okuma dizisi (dosya) oku(dosya) readcsv(dosya) readdlm(dosya) Parametreler # parametre Ayrıntılar chomp(str) Bir dizeden en fazla bir satırsonu kaldır. str Sondaki yeni satırın çıkarılacağı dize. dizeler kuralının değişmez olduğuna dikkat edin. Bu işlev yeni bir dize döndürür. open(f, dosya) Bir dosya açın, işlevi çağırın ve ardından dosyayı kapatın. &amp;lsquo;f&amp;rsquo; Dosyayı açan IO akışını çağırma işlevi oluşturur. &amp;ldquo;dosya&amp;rdquo; Açılacak dosyanın yolu.</description>
    </item>
    
    <item>
      <title>Metaprogramlama</title>
      <link>https://www.wikiod.com/tr/julia-lang/metaprogramlama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/metaprogramlama/</guid>
      <description>Sözdizimi # makro adı(ex) &amp;hellip; bitiş alıntı &amp;hellip; son :(&amp;hellip;) $x Meta.quot(x) AlıntıDüğümü(x) esc(x) Julia&amp;rsquo;nın metaprogramlama özellikleri, Lisp benzeri dillerden büyük ölçüde esinlenmiştir ve bazı Lisp geçmişine sahip olanlara tanıdık gelecektir. Metaprogramlama çok güçlüdür. Doğru kullanıldığında, daha özlü ve okunabilir kodlara yol açabilir.
&amp;ldquo;alıntı &amp;hellip; bitiş&amp;rdquo; yarı alıntı sözdizimidir. Değerlendirilmekte olan ifadeler yerine basitçe ayrıştırılır. &amp;ldquo;quote &amp;hellip; end&amp;rdquo; ifadesinin değeri, sonuçta ortaya çıkan Soyut Sözdizimi Ağacıdır (AST).
:(...) sözdizimi, quote .</description>
    </item>
    
    <item>
      <title>Şartlılar</title>
      <link>https://www.wikiod.com/tr/julia-lang/sartllar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/sartllar/</guid>
      <description>Sözdizimi # eğer koşul; gövde; son eğer koşul; gövde; başka; gövde; son eğer koşul; gövde; başka koşul; gövde; başka; son eğer koşul; gövde; başka koşul; gövde; son koşul? iftrue : iffalse koşul &amp;amp;&amp;amp; iftrue koşul || eğer yanlışsa ifelse(koşul, iftrue, iffalse) Tüm koşullu işleçler ve işlevler, boole koşullarının (&amp;ldquo;doğru&amp;rdquo; veya &amp;ldquo;yanlış&amp;rdquo;) kullanılmasını içerir. Julia&amp;rsquo;da boolean türü &amp;ldquo;Bool&amp;quot;dur. Diğer bazı dillerden farklı olarak, diğer sayı türleri (&amp;ldquo;1&amp;rdquo; veya &amp;ldquo;0&amp;rdquo; gibi), dizeler, diziler ve benzerleri doğrudan koşullu ifadelerde kullanılamaz.</description>
    </item>
    
    <item>
      <title>Paralel İşleme</title>
      <link>https://www.wikiod.com/tr/julia-lang/paralel-isleme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/paralel-isleme/</guid>
      <description>@async ve @sync # ?@async altındaki belgelere göre, &amp;ldquo;@async bir Görevdeki bir ifadeyi sarar.&amp;rdquo; Bunun anlamı, kapsamına giren her şey için Julia&amp;rsquo;nın bu görevi çalıştırmaya başlaması, ancak daha sonra görevin tamamlanmasını beklemeden komut dosyasında bir sonraki adıma devam etmesidir. Böylece, örneğin, makro olmadan şunları elde edersiniz:
julia&amp;gt; @time sleep(2) 2.005766 seconds (13 allocations: 624 bytes) Ancak makro ile şunları elde edersiniz:
julia&amp;gt; @time @async sleep(2) 0.000021 seconds (7 allocations: 657 bytes) Task (waiting) @0x0000000112a65ba0 julia&amp;gt; Böylece Julia, görevin tamamlanmasını beklemeden (bu durumda, iki saniye uyumak) komut dosyasının ilerlemesine (ve &amp;ldquo;@time&amp;rdquo; makrosunun tam olarak yürütülmesine) izin verir.</description>
    </item>
    
    <item>
      <title>demetler</title>
      <link>https://www.wikiod.com/tr/julia-lang/demetler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/demetler/</guid>
      <description>Sözdizimi # a, bir, b a, b = xs () (a,) (a, b) (a, b&amp;hellip;) Tuple{T, U, V} NÇift{N, T} Tuple{T, U, Vararg{V}} Tuple&amp;rsquo;lar, iki nedenden dolayı diziler&amp;lsquo;den çok daha iyi çalışma zamanı performansına sahiptir: türleri daha kesindir ve değişmezlikleri, yığın yerine yığında ayrılmalarına olanak tanır. Bununla birlikte, bu daha kesin yazma, hem daha fazla derleme zamanı yükü hem de tür kararlılığı elde etmede daha fazla zorluk ile birlikte gelir.</description>
    </item>
    
    <item>
      <title>Birim Testi</title>
      <link>https://www.wikiod.com/tr/julia-lang/birim-testi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/julia-lang/birim-testi/</guid>
      <description>Sözdizimi # @test [ifade] @test_throws [İstisna] [ifade] @testset &amp;ldquo;[isim]&amp;rdquo; başlangıcı; [testler]; son Pkg.test([paket]) Base.Test için standart kitaplık belgeleri, bu örneklerde gösterilenlerin ötesinde ek materyalleri kapsar.
Bir Paketi Test Etme # Bir paket için birim testlerini çalıştırmak için &amp;ldquo;Pkg.test&amp;rdquo; işlevini kullanın. MyPackage adlı bir paket için komut şöyle olacaktır:
julia&amp;gt; Pkg.test(&amp;quot;MyPackage&amp;quot;) Beklenen bir çıktı şuna benzer olacaktır:
INFO: Computing test dependencies for MyPackage... INFO: Installing BaseTestNext v0.2.2 INFO: Testing MyPackage Test Summary: | Pass Total Data | 66 66 Test Summary: | Pass Total Monetary | 107 107 Test Summary: | Pass Total Basket | 47 47 Test Summary: | Pass Total Mixed | 13 13 Test Summary: | Pass Total Data Access | 35 35 INFO: MyPackage tests passed INFO: Removing BaseTestNext v0.</description>
    </item>
    
  </channel>
</rss>
