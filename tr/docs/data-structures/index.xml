<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>veri yapıları Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/data-structures/</link>
    <description>Recent content in veri yapıları Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/data-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Veri yapılarını kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/data-structures/veri-yaplarn-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/veri-yaplarn-kullanmaya-baslama/</guid>
      <description>Veri Yapılarına Giriş # Bir veri yapısı, bilgiyi organize etmenin ve saklamanın bir yoludur.
Bir &amp;ldquo;Merhaba Dünya!&amp;rdquo; dize, bayt adreslenebilir bellekte düzenlememiz ve saklamamız gereken bilgiler olsun.
Her ASCII karakteri 7 bit depolama gerektirir. Çoğu sistem, her karakter için 8 bit (1 bayt) ayırır, bu nedenle &amp;ldquo;Merhaba, Dünya!&amp;rdquo; bayt boyutunda bir bellek biriminde birbiri ardına ardışık olarak depolanır.
Birden çok bellek adresine yayılmış olsa bile dizgimize tek bir referansa ihtiyacımız var, bu yüzden dizgedeki ilk karakterin adresini &amp;lsquo;H&amp;rsquo; kullanıyoruz.</description>
    </item>
    
    <item>
      <title>Bağlantılı liste</title>
      <link>https://www.wikiod.com/tr/data-structures/baglantl-liste/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/baglantl-liste/</guid>
      <description>XOR Bağlantılı Liste # Bir XOR Bağlantılı listesi aynı zamanda Bellek-Verimli Bağlantılı Liste olarak da adlandırılır. Çift bağlantılı bir listenin başka bir şeklidir. Bu, büyük ölçüde XOR mantık kapısına ve özelliklerine bağlıdır.
Bunun adı neden Verimli Bellek Bağlantılı Listedir? Buna böyle denir, çünkü bu, geleneksel bir çift bağlantılı listeden daha az bellek kullanır.
Bu, Çift Bağlantılı Listeden farklı mı?
**Evet öyle.
Bir Çift Bağlantılı Liste, sonraki ve önceki düğümü işaret eden iki işaretçiyi saklar.</description>
    </item>
    
    <item>
      <title>Trie (Önek AğacıRadix Ağacı)</title>
      <link>https://www.wikiod.com/tr/data-structures/trie-onek-agacradix-agac/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/trie-onek-agacradix-agac/</guid>
      <description>Trie&amp;rsquo;ye Giriş # Arama motorlarının nasıl çalıştığını hiç merak ettiniz mi? Google, milyonlarca sonucu sadece birkaç milisaniyede nasıl sıralar? Sizden binlerce mil uzakta bulunan devasa bir veri tabanı, aradığınız bilgiyi nasıl bulur ve size geri gönderir? Bunun nedeni sadece daha hızlı internet ve süper bilgisayarlar kullanmakla mümkün değil. Bazı büyüleyici arama algoritmaları ve veri yapıları bunun arkasında çalışır. Bunlardan biri Trie.
Trie, aynı zamanda dijital ağaç ve bazen radix tree veya prefix tree (öneklerle aranabilecekleri için) olarak da adlandırılır, bir tür arama ağacıdır; depolamak için kullanılan sıralı bir ağaç veri yapısıdır.</description>
    </item>
    
    <item>
      <title>İkili Arama Ağacı</title>
      <link>https://www.wikiod.com/tr/data-structures/ikili-arama-agac/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/ikili-arama-agac/</guid>
      <description>BST&amp;rsquo;de Düğüm Oluşturma # İkili Arama Ağacı (BST), kök düğüme tek bir işaretçi içeren hiyerarşik bir veri yapısıdır.
BST&amp;rsquo;deki Düğüm genellikle hızlı arama için &amp;ldquo;öğeler&amp;rdquo; (sayılar veya adlar gibi) içerir. Her düğümün en fazla iki çocuğu vardır (sol ve sağ). Her düğüm, bazı anahtar veri alanları tarafından düzenlenir. BST&amp;rsquo;deki her düğüm için anahtarı, sol çocuğun anahtarından büyük ve sağ çocuğun anahtarından küçüktür.
Tipik bir düğüm yapısı (bir tamsayıyı saklayan) şöyle olur:</description>
    </item>
    
    <item>
      <title>Yığın</title>
      <link>https://www.wikiod.com/tr/data-structures/ygn/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/ygn/</guid>
      <description>Yığına Giriş # Yığın, bir LIFO (son giren ilk çıkar) veri yapısıdır, yani yığına eklenen en son (veya &amp;ldquo;son giren&amp;rdquo;) öğe, kaldırılan ilk öğe (&amp;ldquo;ilk çıkar&amp;rdquo;) olacaktır.
Kutudaki kitap örneğini ele alalım. Bir seferde yalnızca bir kitap eklenebilir veya kutudan çıkarılabilir ve yalnızca üstten eklenebilir ve kaldırılabilir.
Şimdi, ilk iki kitabın olduğu kutu şuna benziyor:
|--------| | 2. kitap | ◀──── kutunun üstü |-------| | kitap 1 | ◀──── kutunun altı |-------| kitabı eklersek, en üstte olacak.</description>
    </item>
    
    <item>
      <title>Segment Ağacı</title>
      <link>https://www.wikiod.com/tr/data-structures/segment-agac/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/segment-agac/</guid>
      <description>Segment Ağacına Giriş # Diyelim ki bir dizimiz var:
+-------+-----+-----+-----+-----+-----+-----+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | +-------+-----+-----+-----+-----+-----+-----+ | Value | -1 | 3 | 4 | 0 | 2 | 1 | +-------+-----+-----+-----+-----+-----+-----+ Bu dizi üzerinde bazı sorgular yapmak istiyoruz. Örneğin:
Dizin-2 ile dizin-4 arasındaki minimum değer nedir? -&amp;gt; 0 Dizin-0 ile dizin-3 arasındaki maksimum değer nedir? -&amp;gt; 4 İndeks-1 ile indeks-5 arasındaki toplam nedir?</description>
    </item>
    
    <item>
      <title>Sıra</title>
      <link>https://www.wikiod.com/tr/data-structures/sra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/sra/</guid>
      <description>Kuyruğa Giriş # Kuyruk bir FIFO (ilk giren ilk çıkar) veri yapısıdır, yani kuyruğa eklenen ilk eleman kaldırılan ilk eleman olacaktır (&amp;ldquo;ilk çıkar&amp;rdquo;).
Yardım edilmeyi bekleyen müşteriler örneğini ele alalım. Alice, Bob ve Dan süpermarketteler. Alice ödemeye hazırdır, bu yüzden kasiyere yaklaşır. Alice şimdi sırada. Sıradaki tek kişi o, bu yüzden hem önde hem de arkada.
Şimdi, sıra şöyle görünüyor:
|-------| | Alice | cashier |-------| ▲ ▲ sıranın arkası ──┘ └── sıranın önü Şimdi Bob ve sonra Dan kasiyere yaklaşıyor.</description>
    </item>
    
    <item>
      <title>Grafik geçişleri</title>
      <link>https://www.wikiod.com/tr/data-structures/grafik-gecisleri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/grafik-gecisleri/</guid>
      <description>Grafik geçişleri ile ilgili tüm algoritmalar. Karmaşıklıkları, hem çalışma zamanı hem de uzay
Derinlik öncelikli arama # Bir grafik için Derinlik İlk Geçiş (veya Arama), bir ağacın Derinlik İlk Geçişine benzer. Buradaki tek yakalama, ağaçların aksine, grafikler döngüler içerebilir, bu yüzden aynı düğüme tekrar gelebiliriz. Bir düğümün birden fazla işlenmesini önlemek için, boolean ziyaret edilen bir dizi kullanırız.
Aşağıdaki algoritma, DFS kullanarak grafik geçişi için adımları sunar:
Algoritma DFS(v);
Girdi: Grafikte bir köşe v</description>
    </item>
    
    <item>
      <title>Deque(Çift uçlu kuyruk)</title>
      <link>https://www.wikiod.com/tr/data-structures/dequecift-uclu-kuyruk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/dequecift-uclu-kuyruk/</guid>
      <description>Sıranın hem önünden hem de sonundan Ekleme ve Silme # </description>
    </item>
    
    <item>
      <title>Birlik bulma veri yapısı</title>
      <link>https://www.wikiod.com/tr/data-structures/birlik-bulma-veri-yaps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/data-structures/birlik-bulma-veri-yaps/</guid>
      <description>Birleşim bulma (veya ayrık küme) veri yapısı, basit bir veri yapısıdır ve bir dizi öğenin ayrık kümelere bölünmesidir. Her kümenin, onu diğer kümelerden ayırt etmek için kullanılabilecek bir temsilcisi vardır.
Birçok algoritmada kullanılır, örn. minimum yayılan ağaçları Kruskal&amp;rsquo;ın algoritması ile hesaplamak, bağlı bileşenleri yönsüz grafiklerde hesaplamak ve daha pek çok şey.
Teori # Union find veri yapıları aşağıdaki işlemleri sağlar:
&amp;lsquo;make_sets(n)&amp;rsquo;, &amp;rsquo;n&amp;rsquo; tekil tonlarıyla bir birlik bulma veri yapısını başlatır &amp;ldquo;find(i)&amp;rdquo;, &amp;ldquo;i&amp;rdquo; öğesi kümesi için bir temsilci döndürür &amp;lsquo;union(i,j)&amp;rsquo;, &amp;lsquo;i&amp;rsquo; ve &amp;lsquo;j&amp;rsquo; içeren kümeleri birleştirir Her &amp;ldquo;i&amp;rdquo; öğesi için bir parent öğesi &amp;ldquo;parent[i]&amp;rdquo; depolayarak &amp;ldquo;0&amp;rdquo; ile &amp;ldquo;n - 1&amp;rdquo; arasındaki öğelerin bölümümüzü temsil ediyoruz, bu da sonunda &amp;ldquo;i&amp;quot;yi içeren kümenin bir temsilcisine yol açar.</description>
    </item>
    
  </channel>
</rss>
