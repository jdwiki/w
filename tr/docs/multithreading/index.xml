<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>çoklu iş parçacığı Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/multithreading/</link>
    <description>Recent content in çoklu iş parçacığı Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/multithreading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Çoklu iş parçacığı kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/multithreading/coklu-is-parcacg-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/multithreading/coklu-is-parcacg-kullanmaya-baslama/</guid>
      <description>Kilitlenmeler # İki veya daha fazla iş parçacığından oluşan bir grubun her üyesi, devam etmeden önce diğer üyelerden birinin bir şey yapmasını (örneğin, bir kilidi serbest bırakmak için) beklemesi gerektiğinde bir kilitlenme oluşur. Müdahale olmadan, iplikler sonsuza kadar bekler.
Kilitlenmeye meyilli bir tasarımın sözde kod örneği:
thread_1 { acquire(A) ... acquire(B) ... release(A, B) } thread_2 { acquire(B) ... acquire(A) ... release(A, B) } &amp;ldquo;thread_1&amp;rdquo; &amp;ldquo;A&amp;quot;yı edindiğinde, ancak henüz &amp;ldquo;B&amp;quot;yi almadığında ve &amp;ldquo;thread_2&amp;rdquo;, &amp;ldquo;B&amp;quot;yi edindiği halde &amp;ldquo;A&amp;quot;yı almadığında bir kilitlenme meydana gelebilir.</description>
    </item>
    
    <item>
      <title>uygulayıcılar</title>
      <link>https://www.wikiod.com/tr/multithreading/uygulayclar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/multithreading/uygulayclar/</guid>
      <description>Sözdizimi # ThreadPoolExecutor
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, uzun keepAliveTime, TimeUnit birimi, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, uzun keepAliveTime, TimeUnit birimi, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ReddedilenExecutionHandler işleyicisi)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, uzun keepAliveTime, TimeUnit birimi, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit birimi, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler işleyicisi)
Executors.callable(PrivilegedAction&amp;lt;?&amp;gt; action)
Executors.callable(PrivilegedExceptionAction&amp;lt;?&amp;gt; action)
Executors.callable(Çalıştırılabilir görev)
Executors.callable(Çalıştırılabilir görev, T sonucu)
Executors.defaultThreadFactory()
Executors.newCachedThreadPool()
Executors.newCachedThreadPool(ThreadFactory threadFactory)
Executors.newFixedThreadPool(int nThreads)
Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</description>
    </item>
    
    <item>
      <title>Semaforlar ve Muteksler</title>
      <link>https://www.wikiod.com/tr/multithreading/semaforlar-ve-muteksler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/multithreading/semaforlar-ve-muteksler/</guid>
      <description>Semaforlar ve Muteksler, paylaşılan kaynaklara çoklu iş parçacığı erişimini senkronize etmek için kullanılan eşzamanlılık kontrolleridir.
Semafor # İşte bu Stackoverflow sorusundan harika bir açıklama:
Semaforları bir gece kulübünde fedai olarak düşünün. adanmış var kulüpte aynı anda izin verilen kişi sayısı. kulüp ise dolu kimsenin girmesine izin verilmez, ancak bir kişi ayrılır ayrılmaz başka bir kişi girebilir.
Bu sadece sayısını sınırlamanın bir yolu. belirli bir kaynak için tüketiciler. Örneğin, sayısını sınırlamak için bir uygulamadaki bir veritabanına eşzamanlı çağrılar.</description>
    </item>
    
  </channel>
</rss>
