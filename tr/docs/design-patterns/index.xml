<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tasarım desenleri Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/design-patterns/</link>
    <description>Recent content in Tasarım desenleri Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tasarım kalıplarını kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/design-patterns/tasarm-kalplarn-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/tasarm-kalplarn-kullanmaya-baslama/</guid>
      <description>Giriiş # Wikipedia&amp;rsquo;e göre:
[A] yazılım tasarım deseni, yazılım tasarımında belirli bir bağlamda yaygın olarak ortaya çıkan bir soruna yönelik yeniden kullanılabilir genel bir çözümdür. Doğrudan kaynak veya makine koduna dönüştürülebilecek bitmiş bir tasarım değildir. Birçok farklı durumda kullanılabilecek bir sorunun nasıl çözüleceğine ilişkin bir açıklama veya şablondur. Tasarım kalıpları, programcının bir uygulama veya sistem tasarlarken yaygın sorunları çözmek için kullanabileceği resmileştirilmiş en iyi uygulamalardır.
(Alınan: 2016-10-13)
Pek çok tanınmış yazılım tasarım modeli vardır ve düzenli olarak yenileri önerilmektedir.</description>
    </item>
    
    <item>
      <title>Fabrika</title>
      <link>https://www.wikiod.com/tr/design-patterns/fabrika/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/fabrika/</guid>
      <description>Somut sınıflarını belirtmeden ilgili veya bağımlı nesnelerin ailelerini oluşturmak için bir arayüz sağlayın.
&amp;ndash; GOF 1994
Basit fabrika (Java) # Bir fabrika, nesne oluşturma kodundan nesneler oluşturması gereken kodlar arasındaki eşleşmeyi azaltır. Nesne oluşturma, bir sınıf kurucusunu çağırarak değil, çağıran adına nesneyi yaratan bir işlevi çağırarak açıkça yapılır. Basit bir Java örneği aşağıdaki gibidir:
interface Car { } public class CarFactory{ static public Car create(String s) { switch (s) { default: case &amp;quot;us&amp;quot;: case &amp;quot;american&amp;quot;: return new Chrysler(); case &amp;quot;de&amp;quot;: case &amp;quot;german&amp;quot;: return new Mercedes(); case &amp;quot;jp&amp;quot;: case &amp;quot;japanese&amp;quot;: return new Mazda(); } } } class Chrysler implements Car { public String toString() { return &amp;quot;Chrysler&amp;quot;; } } class Mazda implements Car { public String toString() { return &amp;quot;Mazda&amp;quot;; } } class Mercedes implements Car { public String toString() { return &amp;quot;Mercedes&amp;quot;; } } public class CarEx { public static void main(String args[]) { Car car = CarFactory.</description>
    </item>
    
    <item>
      <title>tekton</title>
      <link>https://www.wikiod.com/tr/design-patterns/tekton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/tekton/</guid>
      <description>Singleton tasarım deseni bazen &amp;ldquo;Anti desen&amp;rdquo; olarak kabul edilir. Bunun nedeni, bazı sorunları olması gerçeğidir. Kullanmanın uygun olduğunu düşünüyorsanız kendiniz karar vermelisiniz. Bu konu StackOverflow&amp;rsquo;ta birkaç kez tartışıldı.
Görmek: http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons
Singleton (Java) # Java&amp;rsquo;daki singleton&amp;rsquo;lar, her iki dil de nesne yönelimli olduğundan C#&amp;lsquo;a çok benzer. Aşağıda, programın ömrü boyunca nesnenin yalnızca bir sürümünün canlı olabileceği bir singleton sınıfı örneği verilmiştir (Programın bir iş parçacığı üzerinde çalıştığını varsayarsak)
public class SingletonExample { private SingletonExample() { } private static SingletonExample _instance; public static SingletonExample getInstance() { if (_instance == null) { _instance = new SingletonExample(); } return _instance; } } İşte o programın iş parçacığı güvenli sürümü:</description>
    </item>
    
    <item>
      <title>Strateji Modeli</title>
      <link>https://www.wikiod.com/tr/design-patterns/strateji-modeli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/strateji-modeli/</guid>
      <description>Context sınıfıyla Java&amp;rsquo;da strateji modeli örneği # Strateji:
&amp;ldquo;Strateji&amp;rdquo;, algoritmayı ilgili algoritmalar ailesinden dinamik olarak değiştirmeye izin veren bir davranış kalıbıdır.
Vikipedi&amp;rsquo;den Strateji kalıbının UML&amp;rsquo;si
:
import java.util.*; /* Interface for Strategy */ interface OfferStrategy { public String getName(); public double getDiscountPercentage(); } /* Concrete implementation of base Strategy */ class NoDiscountStrategy implements OfferStrategy{ public String getName(){ return this.getClass().getName(); } public double getDiscountPercentage(){ return 0; } } /* Concrete implementation of base Strategy */ class QuarterDiscountStrategy implements OfferStrategy{ public String getName(){ return this.</description>
    </item>
    
    <item>
      <title>Oluşturucu Deseni</title>
      <link>https://www.wikiod.com/tr/design-patterns/olusturucu-deseni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/olusturucu-deseni/</guid>
      <description>Aynı inşa sürecinin farklı temsiller oluşturabilmesi için karmaşık bir nesnenin inşasını temsilinden ayırır.
Mantığı temsilden ayırın. Farklı veri kümeleriyle çalışmak için mantığı yeniden kullanın. Java / Lombok # import lombok.Builder; @Builder public class Email { private String to; private String from; private String subject; private String body; } Kullanım örneği:
Email.builder().to(&amp;quot;email1@email.com&amp;quot;) .from(&amp;quot;email2@email.com&amp;quot;) .subject(&amp;quot;Email subject&amp;quot;) .body(&amp;quot;Email content&amp;quot;) .build(); Java&amp;rsquo;da kompozisyonlu oluşturucu deseni # Amaç:
Karmaşık bir nesnenin inşasını temsilinden ayırın, böylece aynı inşa süreci farklı temsiller yaratabilir</description>
    </item>
    
    <item>
      <title>dekoratör desen</title>
      <link>https://www.wikiod.com/tr/design-patterns/dekorator-desen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/dekorator-desen/</guid>
      <description>Dekoratör deseni, kullanıcının yapısını değiştirmeden mevcut bir nesneye yeni işlevler eklemesine olanak tanır. Bu tür tasarım deseni, bu desen mevcut sınıfa bir sarmalayıcı görevi gördüğü için yapısal desen altında gelir.
Bu model, orijinal sınıfı saran ve sınıf yöntemleri imzasını olduğu gibi tutan ek işlevsellik sağlayan bir dekoratör sınıfı oluşturur.
Parametreler # parametre Açıklama İçecek Çay veya Kahve olabilir OtomatDekoratör # Wikipedia&amp;rsquo;ya göre Dekoratörün tanımı:
Dekoratör deseni, belirli bir nesnenin işlevselliğini statik olarak veya bazı durumlarda, tasarım zamanında bazı temel çalışmaların yapılması koşuluyla, aynı sınıfın diğer örneklerinden bağımsız olarak çalışma zamanında genişletmek (süslemek) için kullanılabilir.</description>
    </item>
    
    <item>
      <title>Bağımlılık Enjeksiyonu</title>
      <link>https://www.wikiod.com/tr/design-patterns/bagmllk-enjeksiyonu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/bagmllk-enjeksiyonu/</guid>
      <description>Dependency Injection&amp;rsquo;ın arkasındaki genel fikir, uygulamanızı Dependency Inversion İlkesine bağlı kalarak gevşek bağlı bileşenler etrafında tasarlamanızdır. Somut uygulamalara bağlı kalmadan son derece esnek sistemler tasarlamaya olanak tanır.
Bağımlılık eklemenin arkasındaki temel fikir, daha gevşek bağlı kod oluşturmaktır. Bir sınıf, kendi bağımlılıklarını yenilemek yerine bağımlılıklarını aldığında, sınıfın bir birim olarak test edilmesi daha basit hale gelir (birim testi).
Gevşek bağlantı üzerinde daha fazla ayrıntıya girmek için - fikir, sınıfların somutlardan ziyade soyutlamalara bağımlı hale gelmesidir.</description>
    </item>
    
    <item>
      <title>Ziyaretçi Kalıbı</title>
      <link>https://www.wikiod.com/tr/design-patterns/ziyaretci-kalb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/ziyaretci-kalb/</guid>
      <description>Java&amp;rsquo;da ziyaretçi kalıbı örneği # &amp;ldquo;Ziyaretçi&amp;rdquo; kalıbı, bu sınıfların yapısını değiştirmeden bir dizi sınıfa yeni işlemler veya yöntemler eklemenize olanak tanır.
Bu model, özellikle nesneyi genişletmeden veya nesneyi değiştirmeden bir nesne üzerinde belirli bir işlemi merkezileştirmek istediğinizde kullanışlıdır.
Wikipedia&amp;rsquo;dan UML diyagramı:
Kod parçacığı:
import java.util.HashMap; interface Visitable{ void accept(Visitor visitor); } interface Visitor{ void logGameStatistics(Chess chess); void logGameStatistics(Checkers checkers); void logGameStatistics(Ludo ludo); } class GameVisitor implements Visitor{ public void logGameStatistics(Chess chess){ System.</description>
    </item>
    
    <item>
      <title>Komut deseni</title>
      <link>https://www.wikiod.com/tr/design-patterns/komut-deseni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/komut-deseni/</guid>
      <description>Java&amp;rsquo;da komut kalıbı örneği # [wikipedia] tanım:
Komut kalıbı, bir eylemi gerçekleştirmek veya daha sonra bir olayı tetiklemek için gereken tüm bilgileri kapsüllemek için bir nesnenin kullanıldığı davranışsal bir tasarım kalıbıdır.
dofactory&amp;lsquo;den UML diyagramı:
Temel bileşenler ve iş akışı:
&amp;ldquo;Komut&amp;rdquo;, &amp;ldquo;execute()&amp;rdquo; gibi soyut komutlar için bir arayüz bildirir. &amp;lsquo;Alıcı&amp;rsquo; belirli bir komutu nasıl yürüteceğini bilir &amp;lsquo;Invoker&amp;rsquo;, yürütülmesi gereken &amp;lsquo;Somut Komut&amp;rsquo;u tutar &amp;ldquo;Müşteri&amp;rdquo;, &amp;ldquo;Somut Komut&amp;rdquo; oluşturur ve &amp;ldquo;Alıcı&amp;quot;yı atar &amp;ldquo;SomutKomut&amp;rdquo;, &amp;ldquo;Komut&amp;rdquo; ve &amp;ldquo;Alıcı&amp;rdquo; arasındaki bağlantıyı tanımlar Bu şekilde, Komut düzeni Gönderen&amp;lsquo;i (İstemci) Alıcı&amp;lsquo;dan Çağlayan&amp;lsquo;a ayırır.</description>
    </item>
    
    <item>
      <title>Depo Kalıbı</title>
      <link>https://www.wikiod.com/tr/design-patterns/depo-kalb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/design-patterns/depo-kalb/</guid>
      <description>IEnumerable&amp;lt;TEntity&amp;gt; Get(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter) uygulaması hakkında: Bunun fikri, yazmak için i =&amp;gt; x.id == 17 gibi İfadeler kullanmaktır. genel istekler Teknolojinizin belirli sorgulama dilini kullanmadan verileri sorgulamanın bir yoludur. Uygulama oldukça kapsamlıdır, bu nedenle, uyguladığınız depolardaki belirli yöntemler gibi diğer alternatifleri düşünmek isteyebilirsiniz: Hayali bir &amp;lsquo;CompanyRepository&amp;rsquo;, &amp;lsquo;GetByName(dize adı)&amp;rsquo; yöntemini sağlayabilir.
Salt okunur depolar (C#) # Veri depolamaya özgü kodu, belirlenmiş bileşenlerde kapsüllemek için bir havuz modeli kullanılabilir. Uygulamanızın verilere ihtiyaç duyan kısmı yalnızca depolarla çalışacaktır.</description>
    </item>
    
  </channel>
</rss>
