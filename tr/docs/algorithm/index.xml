<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algoritma Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/algorithm/</link>
    <description>Recent content in algoritma Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Algoritmaya başlarken</title>
      <link>https://www.wikiod.com/tr/algorithm/algoritmaya-baslarken/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/algoritmaya-baslarken/</guid>
      <description>Örnek bir algoritmik problem # Algoritmik bir sorun, üzerinde çalışması gereken tüm örnekler kümesini ve bu örneklerden biri üzerinde çalıştıktan sonra çıktısını tanımlayarak belirtilir. Bir problem ile bir problemin örneği arasındaki bu ayrım temeldir. Sıralama olarak bilinen algoritmik problem şu şekilde tanımlanır: [Skiena:2008:ADM:1410219]
Sorun: Sıralama Giriş: n tuşları dizisi, a_1, a_2, ..., a_n. Çıktı: Giriş dizisinin a&#39;_1 &amp;lt;= a&#39;_2 &amp;lt;= ... &amp;lt;= a&#39;_{n-1} &amp;lt;= a&#39;_n olacak şekilde yeniden düzenlenmesi Bir sıralama örneği, &amp;ldquo;{ Haskell, Emacs }&amp;rdquo; gibi bir dizi dizi veya &amp;ldquo;{ 154, 245, 1337 }&amp;rdquo; gibi bir sayı dizisi olabilir.</description>
    </item>
    
    <item>
      <title>Algoritma Karmaşıklığı</title>
      <link>https://www.wikiod.com/tr/algorithm/algoritma-karmasklg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/algoritma-karmasklg/</guid>
      <description>Tüm algoritmalar, bir sorunu çözmeye yönelik adımların bir listesidir. Her adımın bir önceki adım kümesine veya algoritmanın başlangıcına bağımlılıkları vardır. Küçük bir sorun aşağıdaki gibi görünebilir:
Bu yapıya yönlendirilmiş asiklik grafik veya kısaca DAG denir. Grafikteki her düğüm arasındaki bağlantılar, işlem sırasına göre bağımlılıkları temsil eder ve grafikte döngü yoktur.
Bağımlılıklar nasıl olur? Örneğin aşağıdaki kodu alın:
total = 0 for(i = 1; i &amp;lt; 10; i++) total = total + i Bu psuedocode&amp;rsquo;da, for döngüsünün her yinelemesi, önceki yinelemede hesaplanan değeri bu sonraki yinelemede kullandığımız için önceki yinelemenin sonucuna bağlıdır.</description>
    </item>
    
    <item>
      <title>Büyük-O Gösterimi</title>
      <link>https://www.wikiod.com/tr/algorithm/buyuk-o-gosterimi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/buyuk-o-gosterimi/</guid>
      <description>Tanım
Big-O notasyonu özünde, fonksiyonların yakınsama oranını karşılaştırmak için kullanılan matematiksel bir notasyondur. n -&amp;gt; f(n) ve n -&amp;gt; g(n) doğal sayılar üzerinden tanımlanmış fonksiyonlar olsun. O zaman &amp;lsquo;f = O(g)&amp;rsquo; olduğunu ancak ve ancak n sonsuza yaklaştığında &amp;lsquo;f(n)/g(n)&amp;rsquo; sınırlıysa söyleriz. Başka bir deyişle, &amp;lsquo;f = O(g)&amp;rsquo; ancak ve ancak bir A sabiti varsa, öyle ki tüm n için &amp;lsquo;f(n)/g(n) &amp;lt;= A&amp;rsquo; olur.
Aslında Big-O notasyonunun kapsamı matematikte biraz daha geniştir, ancak basitlik için onu algoritma karmaşıklık analizinde kullanılanlara daralttım: sıfır olmayan değerlere sahip doğallarda tanımlanan fonksiyonlar ve n&amp;rsquo;nin büyümesi durumu sonsuzluğa.</description>
    </item>
    
    <item>
      <title>grafik</title>
      <link>https://www.wikiod.com/tr/algorithm/grafik/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/grafik/</guid>
      <description>Grafik, bazı (muhtemelen boş) alt kümelerini birbirine bağlayan noktalar ve çizgiler topluluğudur. Bir grafiğin noktalarına grafik köşeleri, &amp;ldquo;düğümler&amp;rdquo; veya basitçe &amp;ldquo;noktalar&amp;rdquo; denir. Benzer şekilde, bir grafiğin köşelerini birleştiren çizgilere grafik kenarları, &amp;ldquo;yaylar&amp;rdquo; veya &amp;ldquo;çizgiler&amp;rdquo; denir.
G grafiği bir çift (V,E) olarak tanımlanabilir, burada V bir köşeler kümesidir ve E köşeler arasındaki bir kenar kümesidir E ⊆ {(u,v) | u, v ∈ V}.
Grafikler, kenar veya bağlantı kümelerinden üyelerle bağlantılı olabilecek veya olmayabilecek nesne kümelerini modelleyen matematiksel bir yapıdır.</description>
    </item>
    
    <item>
      <title>İkili Arama Ağaçları</title>
      <link>https://www.wikiod.com/tr/algorithm/ikili-arama-agaclar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/ikili-arama-agaclar/</guid>
      <description>İkili ağaç, içindeki her düğümün en fazla iki çocuğu olan bir ağaçtır. İkili arama ağacı (BST), öğelerinin özel sıraya göre konumlandırıldığı bir ikili ağaçtır. Her BST&amp;rsquo;de sol alt ağaçtaki tüm değerler (yani anahtar), sağ alt ağaçtaki değerlerden küçüktür.
İkili Arama Ağacı - Ekleme (Python) # Bu, Python kullanılarak İkili Arama Ağacı Eklemenin basit bir uygulamasıdır.
Aşağıda bir örnek gösterilmiştir:
Kod parçacığının ardından her görüntü, bu kodun nasıl çalıştığını görselleştirmeyi kolaylaştıran yürütme görselleştirmesini gösterir.</description>
    </item>
    
    <item>
      <title>Dijkstra Algoritması</title>
      <link>https://www.wikiod.com/tr/algorithm/dijkstra-algoritmas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/dijkstra-algoritmas/</guid>
      <description>Dijkstra&amp;rsquo;nın En Kısa Yol Algoritması # Devam etmeden önce Bitişiklik Matrisi ve BFS hakkında kısa bir fikir edinmenizi tavsiye ederiz
Dijkstra&amp;rsquo;nın algoritması tek kaynaklı en kısa yol algoritması olarak bilinir. Örneğin yol ağlarını temsil edebilen bir grafikteki düğümler arasındaki en kısa yolları bulmak için kullanılır. Edsger W. Dijkstra tarafından 1956&amp;rsquo;da tasarlandı ve üç yıl sonra yayınlandı.
En kısa yolu Genişlik İlk Arama (BFS) arama algoritmasını kullanarak bulabiliriz. Bu algoritma iyi çalışıyor, ancak sorun şu ki, her yolu geçme maliyetinin aynı olduğunu varsayıyor, bu da her bir kenarın maliyetinin aynı olduğu anlamına geliyor.</description>
    </item>
    
    <item>
      <title>Sıralamayı Birleştir</title>
      <link>https://www.wikiod.com/tr/algorithm/sralamay-birlestir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/sralamay-birlestir/</guid>
      <description>Sıralama Temellerini Birleştirme # Merge Sort bir böl ve yönet algoritmasıdır. n uzunluğundaki girdi listesini, boyut 1&amp;rsquo;de n liste olana kadar art arda ikiye böler. Daha sonra, liste çiftleri, her adımda eklenen liste çifti arasında daha küçük olan ilk eleman ile birleştirilir. Ardışık birleştirme ve ilk öğelerin karşılaştırılması yoluyla, sıralı liste oluşturulur.
Bir örnek:
Zaman Karmaşıklığı: T(n) = 2T(n/2) + Θ(n)
Yukarıdaki yineleme, Yineleme Ağacı yöntemi veya Ana yöntem kullanılarak çözülebilir.</description>
    </item>
    
    <item>
      <title>Dinamik Zaman Bükülmesi</title>
      <link>https://www.wikiod.com/tr/algorithm/dinamik-zaman-bukulmesi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/dinamik-zaman-bukulmesi/</guid>
      <description>Dinamik Zaman Bükülmesine Giriş # Dynamic Time Warping(DTW), hızı değişebilen iki zamansal dizi arasındaki benzerliği ölçmek için kullanılan bir algoritmadır. Örneğin, bir kişi diğerinden daha hızlı yürüse veya bir gözlem sırasında hızlanma ve yavaşlama olsa bile, yürümedeki benzerlikler DTW kullanılarak tespit edilebilir. Kişi önceden kaydedilmiş örnek sesten daha hızlı veya daha yavaş konuşsa bile, örnek bir sesli komutu diğer komutlarla eşleştirmek için kullanılabilir. DTW, video, ses ve grafik verilerinin zamansal dizilerine uygulanabilir - gerçekten de doğrusal bir diziye dönüştürülebilen herhangi bir veri DTW ile analiz edilebilir.</description>
    </item>
    
    <item>
      <title>Bellman-Ford Algoritması</title>
      <link>https://www.wikiod.com/tr/algorithm/bellman-ford-algoritmas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/bellman-ford-algoritmas/</guid>
      <description>Yönlendirilmiş bir &amp;ldquo;G&amp;rdquo; grafiği verildiğinde, genellikle belirli bir &amp;ldquo;A&amp;rdquo; düğümünden grafikteki diğer düğümlere olan en kısa mesafeyi bulmak isteriz. Dijkstra algoritması, en kısa yolu bulmak için en ünlü algoritmadır, ancak yalnızca verilen grafiğin kenar ağırlıkları negatif değilse çalışır. Bellman-Ford ancak ağırlıkların bazıları negatif olsa bile belirli bir düğümden (varsa) en kısa yolu bulmayı amaçlar. Grafikte negatif bir döngü varsa en kısa mesafenin mevcut olmayabileceğini unutmayın (bu durumda döngünün etrafından dolaşarak sonsuz küçük toplam mesafeyle sonuçlanabiliriz).</description>
    </item>
    
    <item>
      <title>Alt Dizi Arama</title>
      <link>https://www.wikiod.com/tr/algorithm/alt-dizi-arama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/algorithm/alt-dizi-arama/</guid>
      <description>Knuth-Morris-Pratt (KMP) Algoritmasına Giriş # Bir metnemiz ve bir desenimiz olduğunu varsayalım. Desenin metinde var olup olmadığını belirlememiz gerekir. Örneğin:
+-------+---+---+---+---+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | +-------+---+---+---+---+---+---+---+---+ | Text | a | b | c | b | c | g | l | x | +-------+---+---+---+---+---+---+---+---+ +---------+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | +---------+---+---+---+---+ | Pattern | b | c | g | l | +---------+---+---+---+---+ Bu kalıp metinde var.</description>
    </item>
    
  </channel>
</rss>
