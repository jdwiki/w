<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dinamik programlama Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/dynamic-programming/</link>
    <description>Recent content in dinamik programlama Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Dinamik programlamaya başlarken</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/dinamik-programlamaya-baslarken/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/dinamik-programlamaya-baslarken/</guid>
      <description>Dinamik Programlamaya Giriş # Dinamik programlama, çözümleri alt problemlerle birleştirerek problemleri çözer. Problemin ayrık alt problemlere bölündüğü, alt problemlerin özyinelemeli olarak çözüldüğü ve daha sonra orijinal problemin çözümünü bulmak için birleştirildiği böl ve fethet yöntemine benzer olabilir. Buna karşılık, dinamik programlama, alt problemler örtüştüğünde, yani alt problemler alt problemleri paylaştığında uygulanır. Bu bağlamda, bir böl ve yönet algoritması gereğinden fazla iş yapar ve ortak alt problemleri tekrar tekrar çözer. Bir dinamik programlama algoritması her bir alt problemi sadece bir kez çözer ve ardından cevabını bir tabloya kaydeder, böylece her alt problemi çözdüğünde cevabı yeniden hesaplama işinden kaçınır.</description>
    </item>
    
    <item>
      <title>Dinamik Programlama Kullanarak Grafik Sorunlarını Çözme</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/dinamik-programlama-kullanarak-grafik-sorunlarn-cozme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/dinamik-programlama-kullanarak-grafik-sorunlarn-cozme/</guid>
      <description>Floyd-Warshall Algoritması # Minimum Köşe Örtüsü # Minimum Vertex Cover klasik bir grafik problemidir. Diyelim ki bir şehirde birkaç noktayı birbirine bağlayan birkaç yol var. Kenarları kullanarak yolları ve düğümleri kullanarak noktaları temsil edelim. İki örnek grafik alalım:
Bazı noktalara bekçi yerleştirmek istiyoruz. Bir bekçi, noktaya bağlı tüm yolları koruyabilir. Sorun şu ki, tüm yolları kapatmak için gereken minimum bekçi sayısı nedir? Bekçileri A, B, H, I ve J düğümlerine yerleştirirsek, tüm yolları kapatabiliriz.</description>
    </item>
    
    <item>
      <title>Madeni Para Değiştirme Sorunu</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/madeni-para-degistirme-sorunu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/madeni-para-degistirme-sorunu/</guid>
      <description>Toplam Alma Yollarının Sayısı # Farklı mezheplere ve toplamlara sahip madeni paralar verildiğinde, toplamı elde etmek için bu madeni paraları kaç şekilde birleştirebiliriz? Diyelim ki &amp;ldquo;paralar = {1, 2, 3}&amp;rdquo; ve bir &amp;ldquo;toplam = 5&amp;rdquo; var, toplamı 5 yolla bulabiliriz:
1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 2 3 Sorun sırt çantası sorunu ile yakından ilgilidir. Tek fark, sınırsız madeni para kaynağımız var.</description>
    </item>
    
    <item>
      <title>Ağırlıklı Etkinlik Seçimi</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/agrlkl-etkinlik-secimi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/agrlkl-etkinlik-secimi/</guid>
      <description>Ağırlıklı İş Planlama Algoritması # Ağırlıklı İş Çizelgeleme Algoritması, Ağırlıklı Faaliyet Seçim Algoritması olarak da ifade edilebilir.
Sorun şu ki, belirli işlerin başlangıç ​​ve bitiş zamanları verildiğinde ve işi bitirdiğinizde elde ettiğiniz kârla, iki iş paralel olarak yürütülemezken elde edebileceğiniz maksimum kâr nedir?
Bu, Açgözlü Algoritma kullanan Etkinlik Seçimi&amp;rsquo;ne benziyor, ancak ek bir bükülme var. Yani biten iş sayısını maksimize etmek yerine maksimum karı elde etmeye odaklanıyoruz. Burada yapılan işlerin sayısı önemli değil.</description>
    </item>
    
    <item>
      <title>Sırt Çantası Sorunu</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/srt-cantas-sorunu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/srt-cantas-sorunu/</guid>
      <description>Sırt çantası sorunu veya sırt çantası sorunu, kombinatoryal optimizasyonda bir sorundur. Her biri bir ağırlık ve değere sahip bir dizi öğe verildiğinde, toplam ağırlığın belirli bir sınıra eşit veya daha az olması ve toplam değerin mümkün olduğunca büyük olması için bir koleksiyona dahil edilecek her öğenin sayısını belirleyin. Adını, sabit boyutlu sırt çantasıyla kısıtlanan ve en değerli eşyalarla doldurması gereken birinin karşılaştığı sorundan alır.
Sorun genellikle finansal kısıtlamaların olduğu ve kombinatorikler, bilgisayar bilimi gibi alanlarda çalışıldığı kaynak tahsisinde ortaya çıkar.</description>
    </item>
    
    <item>
      <title>Sırayla İlgili Algoritmalar</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/srayla-ilgili-algoritmalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/srayla-ilgili-algoritmalar/</guid>
      <description>En Uzun Artan Sıra # Görev, verilen bir tamsayı dizisindeki en uzun dizinin uzunluğunu, böylece dizinin tüm öğeleri artan düzende sıralanacak şekilde bulmaktır. Örneğin, {15, 27, 14, 38, 26, 55, 46, 65, 85} için en uzun artan alt dizinin (LIS) uzunluğu 6 ve en uzun artan sıra * {15, 27, 38, 55, 65, 85}. Yine {3, 4, -1, 0, 6, 2, 3} için LIS uzunluğu 4 ve devamı {-1, 0, 2, 3} şeklindedir.</description>
    </item>
    
    <item>
      <title>Dinamik Zaman Çarpıtma</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/dinamik-zaman-carptma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/dinamik-zaman-carptma/</guid>
      <description>Dinamik Zaman Bükülmesine Giriş # Dynamic Time Warping(DTW), hızı değişebilen iki zamansal dizi arasındaki benzerliği ölçmek için kullanılan bir algoritmadır. Örneğin, bir kişi diğerinden daha hızlı yürüse veya bir gözlem sırasında hızlanma ve yavaşlama olsa bile, yürümedeki benzerlikler DTW kullanılarak tespit edilebilir. Kişi önceden kaydedilmiş örnek sesten daha hızlı veya daha yavaş konuşsa bile, örnek bir sesli komutu diğer komutlarla eşleştirmek için kullanılabilir. DTW, video, ses ve grafik verilerinin zamansal dizilerine uygulanabilir - gerçekten de doğrusal bir diziye dönüştürülebilen herhangi bir veri DTW ile analiz edilebilir.</description>
    </item>
    
    <item>
      <title>Matris Zinciri Çarpımı</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/matris-zinciri-carpm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/matris-zinciri-carpm/</guid>
      <description>Özyinelemeli Çözüm # Matris zincir çarpımı, dinamik programlama kullanılarak çözülebilen bir optimizasyon problemidir. Bir dizi matris verildiğinde amaç, bu matrisleri çarpmanın en verimli yolunu bulmaktır. Sorun aslında çarpmaları yapmak değil, sadece ilgili matris çarpımlarının sırasına karar vermektir.
Diyelim ki m * n ve p * q boyutunda iki matrisimiz var A1 ve A2 . Matris çarpım kurallarından biliyoruz ki,
A1 ve A2&amp;lsquo;yı ancak ve ancak n = p ise çarpabiliriz. Bu, A1 sütununun sayısının A2 satır sayısına eşit olması gerektiği anlamına gelir.</description>
    </item>
    
    <item>
      <title>Çubuk Kesme</title>
      <link>https://www.wikiod.com/tr/dynamic-programming/cubuk-kesme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/dynamic-programming/cubuk-kesme/</guid>
      <description>Maksimum karı elde etmek için Çubuğu kesmek # n inç uzunluğunda bir çubuk ve n&amp;rsquo;den küçük tüm parçaların fiyatlarını içeren bir dizi m fiyat verildi. Çubuğu kesip parçaları satarak elde edilebilecek maksimum değeri bulmalıyız. Örneğin, çubuğun uzunluğu 8 ise ve farklı parçaların değerleri aşağıdaki gibi veriliyorsa, elde edilebilecek maksimum değer 22&amp;lsquo;dir.
+---+---+---+---+---+---+---+---+ (price)| 1 | 5 | 8 | 9 | 10| 17| 17| 20| +---+---+---+---+---+---+---+---+ Bir 2B dizi dp[m][n + 1] kullanacağız, burada n, çubuğun uzunluğu ve m, fiyat dizisinin uzunluğudur.</description>
    </item>
    
  </channel>
</rss>
