<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;&#39;a başlarken</title>
      <link>https://www.wikiod.com/tr/c-/c-a-baslarken/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/c-a-baslarken/</guid>
      <description>Selam Dünya # Bu program standart çıktı akışına &amp;lsquo;Merhaba Dünya!&amp;rsquo; yazdırır:
#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; } Coliru&amp;rsquo;da canlı görün.
analiz # Bu kodun her bir bölümünü ayrıntılı olarak inceleyelim:
&amp;ldquo;#include &amp;rdquo;, standart C++ başlık dosyası &amp;ldquo;iostream&amp;quot;in içeriğini içeren bir önişlemci yönergesidir.
iostream is a standard library header file that contains definitions of the standard input and output streams. These definitions are included in the std namespace, explained below.</description>
    </item>
    
    <item>
      <title>standart vektör</title>
      <link>https://www.wikiod.com/tr/c-/standart-vektor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/standart-vektor/</guid>
      <description>Vektör, otomatik olarak işlenen depolamaya sahip dinamik bir dizidir. Bir vektördeki öğelere, bir dizideki öğeler kadar verimli bir şekilde erişilebilir; bunun avantajı, vektörlerin dinamik olarak boyut olarak değişebilmesidir.
Depolama açısından, vektör verileri (genellikle) dinamik olarak ayrılmış belleğe yerleştirilir, bu nedenle bazı küçük ek yük gerektirir; tersine &amp;lsquo;C-dizileri&amp;rsquo; ve &amp;lsquo;std::array&amp;rsquo; beyan edilen konuma göre otomatik depolama kullanır ve bu nedenle herhangi bir ek yükü yoktur.
Bir &amp;ldquo;std::vector&amp;rdquo; kullanımı, &amp;ldquo;#include &amp;rdquo; kullanılarak &amp;ldquo;&amp;rdquo; başlığının dahil edilmesini gerektirir.</description>
    </item>
    
    <item>
      <title>Bir fonksiyondan birkaç değer döndürme</title>
      <link>https://www.wikiod.com/tr/c-/bir-fonksiyondan-birkac-deger-dondurme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/bir-fonksiyondan-birkac-deger-dondurme/</guid>
      <description>Bir işlevden birkaç değer döndürmenin yararlı olduğu birçok durum vardır: örneğin, bir öğeyi girmek ve stoktaki fiyat ve sayıyı iade etmek istiyorsanız, bu işlev yararlı olabilir. Bunu C++&amp;lsquo;da yapmanın birçok yolu vardır ve çoğu STL&amp;rsquo;yi içerir. Ancak, herhangi bir nedenle STL&amp;rsquo;den kaçınmak istiyorsanız, bunu yapmanın &amp;ldquo;yapılar/sınıflar&amp;rdquo; ve &amp;ldquo;diziler&amp;rdquo; dahil olmak üzere hala birkaç yolu vardır.
std::tuple&amp;rsquo;ı kullanma # std::tuple türü, potansiyel olarak farklı türlerdeki değerler de dahil olmak üzere herhangi bir sayıda değeri tek bir dönüş nesnesinde toplayabilir:</description>
    </item>
    
    <item>
      <title>Üç, Beş ve Sıfır Kuralı</title>
      <link>https://www.wikiod.com/tr/c-/uc-bes-ve-sfr-kural/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/uc-bes-ve-sfr-kural/</guid>
      <description>Sıfır Kuralı # Daha yalın bir arayüz elde etmek için Beş Kuralı ve RAII ilkelerini birleştirebiliriz: Sıfır Kuralı: yönetilmesi gereken herhangi bir kaynak kendi türünde olmalıdır. Bu türün Beş Kuralı izlemesi gerekir, ancak bu kaynağın tüm kullanıcılarının beş özel üye işlevinden hiçbirini yazması gerekmez ve hepsini &amp;ldquo;varsayılan&amp;rdquo; olarak yapabilir.
[Üç Kural örneğinde] tanıtılan &amp;lsquo;Person&amp;rsquo; sınıfını kullanma(https://www.wikiod.com/tr/docs/c%2b%2b/1206/the-rule-of- Three-five-and-zero/9867/ üç kural#t=201607281743050894887), &amp;ldquo;cstrings&amp;rdquo; için kaynak yöneten bir nesne oluşturabiliriz:
class cstring { private: char* p; public: ~cstring() { delete [] p; } cstring(cstring const&amp;amp; ); cstring(cstring&amp;amp;&amp;amp; ); cstring&amp;amp; operator=(cstring const&amp;amp; ); cstring&amp;amp; operator=(cstring&amp;amp;&amp;amp; ); /* other members as appropriate */ }; Ve bu ayrı olduğunda, &amp;lsquo;Person&amp;rsquo; sınıfımız çok daha basit hale gelir:</description>
    </item>
    
    <item>
      <title>Lambdalar</title>
      <link>https://www.wikiod.com/tr/c-/lambdalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/lambdalar/</guid>
      <description>Sözdizimi # [default-capture, capture-list] (argument-list) değiştirilebilir throw-specation nitelikler -&amp;gt; return-type { lambda-body } // lambda belirteçlerinin sırası ve nitelikler. [capture-list] (argument-list) { lambda-body } // Ortak lambda tanımı. [=] (argument-list) { lambda-body } // Gerekli tüm yerel değişkenleri değere göre yakalar. [&amp;amp;] (argument-list) { lambda-body } // Gerekli tüm yerel değişkenleri referansa göre yakalar. [capture-list] { lambda-body } // Argüman listesi ve belirteçler atlanabilir. Parametreler # parametre Ayrıntılar varsayılan yakalama Listelenmemiş tüm değişkenlerin nasıl yakalandığını belirtir.</description>
    </item>
    
    <item>
      <title>Akıllı İşaretçiler</title>
      <link>https://www.wikiod.com/tr/c-/akll-isaretciler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/akll-isaretciler/</guid>
      <description>Sözdizimi # std::shared_ptr&amp;lt;ClassType&amp;gt; değişkenAdı = std::make_shared&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); std::shared_ptr&amp;lt;ClassType&amp;gt; değişkenAdı (yeni ClassType(arg1, arg2, ...)); std::unique_ptr&amp;lt;ClassType&amp;gt; değişkenAdı = std::make_unique&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); // C++14 std::unique_ptr&amp;lt;SınıfTürü&amp;gt; değişkenAdı (yeni SınıfTürü(arg1, arg2, ...)); C++, bellek tarafından yönetilen bir dil değildir. Dinamik olarak ayrılmış bellek (yani, &amp;ldquo;yeni&amp;rdquo; ile oluşturulan nesneler), açıkça ayrılmamışsa (&amp;ldquo;sil&amp;rdquo; ile) &amp;ldquo;sızdırılır&amp;rdquo;. Bu nesneye son işaretçiyi atmadan önce dinamik olarak ayrılan belleğin serbest bırakılmasını sağlamak programcının sorumluluğundadır.
Akıllı işaretçiler, dinamik olarak ayrılmış belleğin kapsamını otomatik olarak yönetmek için kullanılabilir (yani, son işaretçi referansı kapsam dışına çıktığında silinir).</description>
    </item>
    
    <item>
      <title>standart dize</title>
      <link>https://www.wikiod.com/tr/c-/standart-dize/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/standart-dize/</guid>
      <description>Dizeler, karakter dizilerini temsil eden nesnelerdir. Standart &amp;ldquo;string&amp;rdquo; sınıfı, metin ve diğer karakter dizileriyle uğraşırken açık &amp;ldquo;char&amp;rdquo; dizilerini kullanmaya basit, güvenli ve çok yönlü bir alternatif sağlar. C++ &amp;ldquo;string&amp;rdquo; sınıfı, &amp;ldquo;std&amp;rdquo; ad alanının bir parçasıdır ve 1998&amp;rsquo;de standartlaştırılmıştır.
Sözdizimi # // Boş dize bildirimi
std::string s;
// const karakterden oluşturma* (c-string)
std::string s(&amp;ldquo;Merhaba&amp;rdquo;);
std::string s = &amp;ldquo;Merhaba&amp;rdquo;;
// Kopya yapıcıyı kullanarak oluşturma std::string s1(&amp;ldquo;Merhaba&amp;rdquo;);
std::string s2(s1);
// alt diziden oluşturma std::string s1(&amp;ldquo;Merhaba&amp;rdquo;);</description>
    </item>
    
    <item>
      <title>şablonlar</title>
      <link>https://www.wikiod.com/tr/c-/sablonlar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/sablonlar/</guid>
      <description>Sınıflar, işlevler ve (C++14&amp;rsquo;ten beri) değişkenler şablonlanabilir. Şablon, tüm parametreler belirtildiğinde somut bir sınıf, işlev veya değişken olacak bazı ücretsiz parametreler içeren bir kod parçasıdır. Parametreler türler, değerler veya kendileri şablonlar olabilir. İyi bilinen bir şablon &amp;lsquo;std::vector&amp;rsquo; olup, öğe türü belirtildiğinde somut bir kap türü haline gelir, ör. &amp;lsquo;std::vector&amp;rsquo;.
Sözdizimi # şablon &amp;lt; şablon-parametre-listesi &amp;gt; bildirim dışa aktarma şablonu &amp;lt; template-parameter-list &amp;gt; declaration /* C++11&amp;rsquo;e kadar */ şablon &amp;lt;&amp;gt; bildirim şablon bildirim dış şablon bildirim /* C++11&amp;rsquo;den beri */ şablon &amp;lt; şablon-parametre-listesi &amp;gt; sınıf &amp;hellip;(opt) tanımlayıcı(opt) şablon &amp;lt; template-parameter-list &amp;gt; class identifier(opt) = id-ifadesi şablon &amp;lt; template-parameter-list &amp;gt; typename &amp;hellip;(opt) identifier(opt) /* C++17&amp;rsquo;den beri */ şablon &amp;lt; template-parameter-list &amp;gt; typename identifier(opt) = id-expression /* C++17&amp;rsquo;den beri */ postfix-ifadesi .</description>
    </item>
    
    <item>
      <title>Metaprogramlama</title>
      <link>https://www.wikiod.com/tr/c-/metaprogramlama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/metaprogramlama/</guid>
      <description>C++&amp;lsquo;da Metaprogramlama, derleme zamanında kod oluşturmak için makroların veya şablonların kullanımını ifade eder.
Genel olarak, bu rolde makrolar hoş karşılanmaz ve genel olmasa da şablonlar tercih edilir.
Şablon metaprogramlaması, kod oluşturma hedeflerine ulaşmak için şablonlar veya &amp;ldquo;constexpr&amp;rdquo; işlevleri aracılığıyla, genellikle derleme zamanı hesaplamalarını kullanır, ancak derleme zamanı hesaplamaları kendi başına metaprogramlama değildir.
Metaprogramlama (veya daha spesifik olarak, Şablon Metaprogramlama), derleme zamanında sabitler, işlevler veya veri yapıları oluşturmak için şablonlar kullanma uygulamasıdır.</description>
    </item>
    
    <item>
      <title>diş açma</title>
      <link>https://www.wikiod.com/tr/c-/dis-acma/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/c-/dis-acma/</guid>
      <description>Sözdizimi # iplik() iplik(iplik&amp;amp;&amp;amp; diğer) açık iş parçacığı(Function&amp;amp;&amp;amp; func, Args&amp;amp;&amp;amp;&amp;hellip; args) Parametreler # | parametre | Ayrıntılar | | &amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | &amp;lsquo;diğer&amp;rsquo; | &amp;lsquo;other&amp;rsquo;ın sahipliğini alır, &amp;lsquo;other&amp;rsquo; artık başlığın sahibi değildir | | &amp;ldquo;işlev&amp;rdquo; | Ayrı bir iş parçacığında çağırma işlevi | | &amp;ldquo;arg&amp;rdquo; | &amp;ldquo;Func&amp;rdquo; için Argümanlar |
Bazı notlar:
İki std::thread nesnesi aynı iş parçacığını asla temsil edemez. Bir &amp;ldquo;std::thread&amp;rdquo; nesnesi, herhangi bir iş parçacığını temsil etmediği bir durumda olabilir (yani bir hamleden sonra, &amp;ldquo;join&amp;rdquo; çağrısından sonra vb.</description>
    </item>
    
  </channel>
</rss>
