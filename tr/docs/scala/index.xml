<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala Dil Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/scala/</link>
    <description>Recent content in Scala Dil Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Scala Dilini kullanmaya başlama</title>
      <link>https://www.wikiod.com/tr/scala/scala-dilini-kullanmaya-baslama/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/scala-dilini-kullanmaya-baslama/</guid>
      <description>Uygulamayı genişleterek Merhaba Dünya # object HelloWorld extends App { println(&amp;quot;Hello, world!&amp;quot;) } Canlı demo
App özellik&amp;lsquo;i genişleterek, açık bir &amp;lsquo;main&amp;rsquo; yöntemi tanımlamaktan kaçınabilirsiniz. . &amp;ldquo;HelloWorld&amp;rdquo; nesnesinin tüm gövdesi &amp;ldquo;ana yöntem&amp;rdquo; olarak kabul edilir.
Gecikmeli Başlatma # resmi belgelere göre, &amp;ldquo;Uygulama&amp;rdquo;, Gecikmeli Başlatma adlı bir özelliği kullanır. Bu, nesne alanlarının ana yöntem çağrıldıktan sonra başlatıldığı anlamına gelir.
son sürüm Gecikmeli Başlatma # resmi belgelere göre, &amp;ldquo;Uygulama&amp;rdquo; Gecikmeli Başlatma. Bu, nesne alanlarının ana yöntem çağrıldıktan sonra başlatıldığı anlamına gelir.</description>
    </item>
    
    <item>
      <title>Desen Eşleştirme</title>
      <link>https://www.wikiod.com/tr/scala/desen-eslestirme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/desen-eslestirme/</guid>
      <description>Sözdizimi # seçici eşleşme kısmiFunction seçici eşleşme {olgu alternatiflerinin listesi) // Bu, yukarıdakilerin en yaygın şeklidir Parametreler # parametre Ayrıntılar seçici Değeri kalıpla eşleştirilen ifade. alternatifler &amp;ldquo;büyük/küçük harf&amp;rdquo; ile sınırlandırılmış alternatiflerin bir listesi. Basit Desen Eşleştirme # Bu örnek, bir girdinin birkaç değerle nasıl eşleştirileceğini gösterir:
def f(x: Int): String = x match { case 1 =&amp;gt; &amp;quot;One&amp;quot; case 2 =&amp;gt; &amp;quot;Two&amp;quot; case _ =&amp;gt; &amp;quot;Unknown!&amp;quot; } f(2) // &amp;quot;Two&amp;quot; f(3) // &amp;quot;Unknown!</description>
    </item>
    
    <item>
      <title>imalar</title>
      <link>https://www.wikiod.com/tr/scala/imalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/imalar/</guid>
      <description>Sözdizimi # örtük değer x: T = ??? Örtük sınıflar, kodlarını değiştirmek zorunda kalmadan mevcut türlere özel yöntemlerin eklenmesine izin verir, böylece kodun kontrolüne ihtiyaç duymadan türleri zenginleştirir.
Varolan bir sınıfı zenginleştirmek için örtük türlerin kullanılmasına genellikle &amp;lsquo;kütüphanemi zenginleştir&amp;rsquo; kalıbı denir.
Örtülü Sınıflardaki Kısıtlamalar
Örtülü sınıflar yalnızca başka bir sınıf, nesne veya özellik içinde var olabilir. Örtülü sınıflar yalnızca bir örtük olmayan birincil kurucu parametresine sahip olabilir. Aynı kapsamda, örtük sınıfla aynı ada sahip başka bir nesne, sınıf, özellik veya sınıf üyesi tanımı olamaz.</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/tr/scala/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/json/</guid>
      <description>Circe ile JSON # Circe, en/decode json için vaka sınıflarına derleme zamanında türetilmiş kodekler sağlar. Basit bir örnek şöyle görünür:
import io.circe._ import io.circe.generic.auto._ import io.circe.parser._ import io.circe.syntax._ case class User(id: Long, name: String) val user = User(1, &amp;quot;John Doe&amp;quot;) // {&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;} val json = user.asJson.noSpaces // Right(User(1L, &amp;quot;John Doe&amp;quot;)) val res: Either[Error, User] = decode[User](json) sprey-json ile JSON # spray-json, JSON ile çalışmanın kolay bir yolunu sağlar. Örtük biçimleri kullanarak, her şey &amp;ldquo;perde arkasında&amp;rdquo; olur:</description>
    </item>
    
    <item>
      <title>çıkarıcılar</title>
      <link>https://www.wikiod.com/tr/scala/ckarclar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/ckarclar/</guid>
      <description>Sözdizimi # val çıkarıcı(extractedValue1, _ /* yoksayılan ikinci çıkarılan değer */) = valueToBeExtracted valueToBeExtracted eşleşmesi { büyük/küçük harf çıkarıcı(extractedValue1, _) =&amp;gt; ???} val (tuple1, tuple2, tuple3) = tupleWith3Elements nesne Foo { def unapply(foo: Foo): Option[String] = Some(foo.x); } Vaka Sınıfı Çıkarıcılar # Bir vaka sınıfı, otomatik olarak dahil edilen çok sayıda standart ortak kod içeren bir sınıftır. Bunun bir yararı, Scala&amp;rsquo;nın vaka sınıflarıyla çıkarıcıları kullanmayı kolaylaştırmasıdır.
case class Person(name: String, age: Int) // Define the case class val p = Person(&amp;quot;Paola&amp;quot;, 42) // Instantiate a value with the case class type val Person(n, a) = p // Extract values n and a // n: String = Paola // a: Int = 42 Bu noktada, hem &amp;rsquo;n&amp;rsquo; hem de &amp;lsquo;a&amp;rsquo; programda &amp;lsquo;val&amp;rsquo;dir ve bu şekilde erişilebilir: p&amp;rsquo;den &amp;lsquo;çıkarıldığı&amp;rsquo; söylenir.</description>
    </item>
    
    <item>
      <title>Koleksiyonlar</title>
      <link>https://www.wikiod.com/tr/scala/koleksiyonlar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/koleksiyonlar/</guid>
      <description>Liste ve Vektör Hile Sayfası # Uygulamalar daha iyi performans gösterdiğinden, artık &amp;lsquo;Liste&amp;rsquo; yerine &amp;lsquo;Vector&amp;rsquo; kullanmak en iyi uygulamadır Performans özellikleri burada bulunabilir. &amp;ldquo;Vektör&amp;rdquo;, &amp;ldquo;Liste&amp;quot;nin kullanıldığı her yerde kullanılabilir.
Liste oluşturma
List[Int]() // Declares an empty list of type Int List.empty[Int] // Uses `empty` method to declare empty list of type Int Nil // A list of type Nothing that explicitly has nothing in it List(1, 2, 3) // Declare a list with some elements 1 :: 2 :: 3 :: Nil // Chaining element prepending to an empty list, in a LISP-style Elementi al</description>
    </item>
    
    <item>
      <title>Monadlar</title>
      <link>https://www.wikiod.com/tr/scala/monadlar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/monadlar/</guid>
      <description>Monad Tanımı # Gayri resmi olarak, bir monad &amp;lsquo;F[_]&amp;rsquo; olarak gösterilen, 2 işlevle paketlenmiş bir öğeler kabıdır: &amp;lsquo;flatMap&amp;rsquo; (bu kapsayıcıyı dönüştürmek için) ve &amp;ldquo;birim&amp;rdquo; (bu kapsayıcıyı oluşturmak için).
Yaygın kitaplık örnekleri arasında &amp;ldquo;List[T]&amp;rdquo;, &amp;ldquo;Set[T]&amp;rdquo; ve &amp;ldquo;Option[T]&amp;rdquo; bulunur.
Resmi tanımlama
Monad &amp;ldquo;M&amp;rdquo;, &amp;ldquo;flatMap&amp;rdquo; ve &amp;ldquo;unit&amp;rdquo; olmak üzere iki işlem içeren bir parametrik tür &amp;ldquo;M[T]&amp;ldquo;dir, örneğin:
trait M[T] { def flatMap[U](f: T =&amp;gt; M[U]): M[U] } def unit[T](x: T): M[T] Bu işlevler üç yasayı karşılamalıdır:</description>
    </item>
    
    <item>
      <title>Vaka Sınıfları</title>
      <link>https://www.wikiod.com/tr/scala/vaka-snflar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/vaka-snflar/</guid>
      <description>Sözdizimi # vaka sınıfı Foo() // Parametresiz vaka sınıflarının boş bir listesi olmalıdır vaka sınıfı Foo(a1: A1, &amp;hellip;, aN: AN) // a1 &amp;hellip; aN alanlarıyla bir vaka sınıfı oluşturun vaka nesnesi Çubuğu // Tek bir vaka sınıfı oluşturun Oluşturulan Kod Yapıları # &amp;ldquo;case&amp;rdquo; değiştiricisi, Scala derleyicisinin sınıf için otomatik olarak ortak ortak kod oluşturmasına neden olur. Bu kodu manuel olarak uygulamak sıkıcıdır ve bir hata kaynağıdır. Aşağıdaki vaka sınıfı tanımı:</description>
    </item>
    
    <item>
      <title>numaralandırmalar</title>
      <link>https://www.wikiod.com/tr/scala/numaralandrmalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/numaralandrmalar/</guid>
      <description>Scala numaralandırmasının birkaç sorunu olduğundan, &amp;ldquo;mühürlü özellik&amp;rdquo; ve &amp;ldquo;vaka nesneleri&amp;rdquo; ile yaklaşım tercih edilir:
Numaralandırmalar, silindikten sonra aynı türe sahiptir.
Derleyici “Eşleşme ayrıntılı değil”den şikayet etmez, eğer büyük/küçük harf kaçırılırsa scala.MatchError çalışma zamanında başarısız olur:
def isWeekendWithBug(day: WeekDays.Value): Boolean = day match { case WeekDays.Sun | WeekDays.Sat =&amp;gt; true }
isWeekendWithBug(WeekDays.Fri) scala.MatchError: Fri (of class scala.Enumeration$Val)
İle karşılaştırmak:
def isWeekendWithBug(day: WeekDay): Boolean = day match { case WeekDay.Sun | WeekDay.Sat =&amp;gt; true } Warning: match may not be exhaustive.</description>
    </item>
    
    <item>
      <title>Körleme</title>
      <link>https://www.wikiod.com/tr/scala/korleme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/scala/korleme/</guid>
      <description>Sözdizimi # aFunction(10)_ //&amp;rsquo;_&amp;rsquo; Kullanılması Derleyiciye, geri kalan parametre gruplarındaki tüm parametrelerin curried olacağını söyler. nArityFunction.curried //bir n-arity İşlevini eşdeğer bir köri sürümüne dönüştürür otherFunction(x)(_: String)(z) // İsteğe bağlı bir parametreyi körleme. Açıkça belirtilen türüne ihtiyacı var. Currying ne zaman kullanılır? # Currying birden çok argüman alan bir fonksiyonun değerlendirmesini, her biri tek bir argümanla bir fonksiyon dizisini değerlendirmeye çevirme tekniğidir.
Bu normalde örneğin şu durumlarda yararlıdır:
Bir fonksiyonun farklı argümanları farklı zamanlarda hesaplanır.</description>
    </item>
    
  </channel>
</rss>
