<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Intel x86 Assembly Dili ve Mikromimari Eğitimi on </title>
    <link>https://www.wikiod.com/tr/docs/x86/</link>
    <description>Recent content in Intel x86 Assembly Dili ve Mikromimari Eğitimi on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/tr/docs/x86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Intel x86 Assembly Dili ve Mikromimarisine Başlarken</title>
      <link>https://www.wikiod.com/tr/x86/intel-x86-assembly-dili-ve-mikromimarisine-baslarken/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/intel-x86-assembly-dili-ve-mikromimarisine-baslarken/</guid>
      <description>x86 Linux Merhaba Dünya Örneği # Bu, 32-bit x86 Linux için NASM derlemesinde sistem çağrılarını doğrudan kullanan (herhangi bir libc işlev çağrısı olmadan) temel bir Hello World programıdır. Alınması gereken çok şey var, ancak zamanla anlaşılır hale gelecektir. Noktalı virgül(;) ile başlayan satırlar yorumlardır.
Henüz düşük seviyeli Unix sistem programlamasını bilmiyorsanız, fonksiyonları asm&amp;rsquo;ye yazmak ve C veya C++ programlarından çağırmak isteyebilirsiniz. Ardından, POSIX sistem çağrısı API&amp;rsquo;sini ve onu kullanmak için ABI&amp;rsquo;yi öğrenmeden, kayıtları ve belleği nasıl kullanacağınızı öğrenmekle ilgilenebilirsiniz.</description>
    </item>
    
    <item>
      <title>Çağrı Kuralları</title>
      <link>https://www.wikiod.com/tr/x86/cagr-kurallar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/cagr-kurallar/</guid>
      <description>Kaynaklar # Genel bakış/karşılaştırmalar: Agner Fog&amp;rsquo;un güzel çağrı kuralı rehberi. Ayrıca, x86 ABI&amp;rsquo;ler (wikipedia): x86-64 Windows ve System V (Linux) dahil olmak üzere işlevler için çağrı kuralları.
SystemV x86-64 ABI (resmi standart). Windows dışındaki tüm işletim sistemleri tarafından kullanılır. (Bu github wiki sayfası, H.J. Lu tarafından güncel tutulmuştur, 32bit, 64bit ve x32 bağlantıları vardır. Ayrıca ABI yöneticileri/katkıda bulunanlar için resmi foruma bağlantılar.) Ayrıca [clang/gcc işaretinin /zero, ABI&amp;rsquo;nin yazıldığı gibi gerektirmemesine rağmen, dar argümanları 32bit&amp;rsquo;e[5] genişletir.</description>
    </item>
    
    <item>
      <title>Çok işlemcili yönetim</title>
      <link>https://www.wikiod.com/tr/x86/cok-islemcili-yonetim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/cok-islemcili-yonetim/</guid>
      <description>Parametreler # LAPIC kaydı Adres (APIC BASE ile ilgili) Yerel APIC Kimliği Kaydı +20s Sahte Kesinti Vektör Kaydı +0f0h Kesinti Komut Kaydı (ICR); bit 0-31 +300s Kesinti Komut Kaydı (ICR); bit 32-63 +310s LAPIC kayıtlarına erişmek için bir segmentin APIC Tabanından (IA32_APIC_BASE&amp;lsquo;de) başlayan adres aralığına ulaşabilmesi gerekir. Bu adres yeniden yerleştirilebilir ve teorik olarak alt bellekte bir yeri işaret edecek şekilde ayarlanabilir, böylece aralığı gerçek modda adreslenebilir hale getirir.
LAPIC aralığına yönelik okuma/yazma döngüleri ancak Bus Arabirim Birimine yayılmaz, böylece &amp;ldquo;arkasındaki&amp;rdquo; adreslere erişimi maskeler.</description>
    </item>
    
    <item>
      <title>Kayıt Temelleri</title>
      <link>https://www.wikiod.com/tr/x86/kayt-temelleri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/kayt-temelleri/</guid>
      <description>16-bit Kayıtlar # Intel orijinal 8086&amp;rsquo;yı tanımladığında, 20 bit adres veriyoluna sahip 16 bitlik bir işlemciydi (aşağıya bakın). 8 genel amaçlı 16 bit kayıt tanımladılar - ancak belirli talimatlar için onlara belirli roller verdiler:
AX Akümülatör kaydı. Birçok işlem kodu ya bu kaydı varsayıyordu ya da belirtilmişse daha hızlıydı. DX Veri kaydı. Bu bazen, örneğin bir çarpmanın sonucu olarak, &amp;ldquo;AX&amp;rdquo; ile 32 bitlik bir değerin yüksek 16 biti olarak birleştirilirdi. CX Sayım kaydı.</description>
    </item>
    
    <item>
      <title>montajcılar</title>
      <link>https://www.wikiod.com/tr/x86/montajclar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/montajclar/</guid>
      <description>Ağ Çapında Birleştirici - NASM # NASM, x86 mimarisi için açık ara en çok taşınan birleştiricidir - x86 tabanlı hemen hemen her İşletim Sistemi için (MacOS&amp;rsquo;a dahil edilmiş olsa bile) mevcuttur ve diğer platformlarda çapraz platform birleştirici olarak mevcuttur.
Bu derleyici Intel sözdizimini kullanır, ancak ağırlıklı olarak kendi &amp;ldquo;makro&amp;rdquo; diline odaklandığından diğerlerinden farklıdır - bu, programcının daha basit tanımlar kullanarak daha karmaşık ifadeler oluşturmasına ve yeni &amp;ldquo;talimatların&amp;rdquo; oluşturulmasına izin verir.</description>
    </item>
    
    <item>
      <title>Sistem Çağrı Mekanizmaları</title>
      <link>https://www.wikiod.com/tr/x86/sistem-cagr-mekanizmalar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/sistem-cagr-mekanizmalar/</guid>
      <description>BIOS çağrıları # BIOS ile nasıl etkileşim kurulur # Temel Giriş/Çıkış Sistemi veya BIOS, herhangi bir işletim sistemi çalışmadan önce bilgisayarı kontrol eden şeydir. Montaj kodu, BIOS tarafından sağlanan hizmetlere erişmek için kesme kullanır. Bir kesme şeklini alır
int &amp;lt;interrupt&amp;gt; ; interrupt must be a literal number, not in a register or memory Kesinti sayısı 0 ile 255 (0x00 - 0xFF) arasında olmalıdır.
Çoğu BIOS çağrısı, bir &amp;ldquo;fonksiyon seçimi&amp;rdquo; parametresi olarak &amp;lsquo;AH&amp;rsquo; kaydını kullanır ve bir veri parametresi olarak &amp;lsquo;AL&amp;rsquo; kaydını kullanır.</description>
    </item>
    
    <item>
      <title>Optimizasyon</title>
      <link>https://www.wikiod.com/tr/x86/optimizasyon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/optimizasyon/</guid>
      <description>x86 ailesi uzun süredir piyasada ve bu nedenle keşfedilen ve geliştirilen, herkesin bildiği veya belki de o kadar halka açık olmayan birçok püf noktası ve teknik var.
Bu hilelerin çoğu, birçok talimatın aynı şeyi etkili bir şekilde yapması gerçeğinden yararlanır - ancak farklı sürümler daha hızlıdır veya bellekten tasarruf sağlar veya Bayrakları etkilemez.
Burada keşfedilen bir dizi hile var. Her birinin Artıları ve Eksileri vardır, bu nedenle listelenmelidir.
Şüphe duyduğunuzda, x86 mimarisinin arkasındaki şirketten harika bir kaynak olan oldukça kapsamlı Intel 64 and IA-32 Architectures Optimization Reference Manual&amp;rsquo;e her zaman başvurabilirsiniz.</description>
    </item>
    
    <item>
      <title>Gerçek ve Korumalı modlar</title>
      <link>https://www.wikiod.com/tr/x86/gercek-ve-korumal-modlar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/gercek-ve-korumal-modlar/</guid>
      <description>Gerçek Mod # Intel orijinal x86&amp;rsquo;yı, 8086&amp;rsquo;yı (ve 8088 türevi) tasarladığında, 16 bit işlemcinin 16 bitten fazla adrese erişmesine izin vermek için Segmentasyonu dahil ettiler. Bunu, 16-bit adresleri, dört tanımladıkları 16-bitlik Segment Register&amp;rsquo;a göre yaparak yaptılar: Kod Segmenti (&amp;lsquo;CS&amp;rsquo;), Veri Segmenti (&amp;lsquo;DS&amp;rsquo;), Ekstra Segment (&amp;lsquo;ES&amp;rsquo;) ve Yığın Segmenti (SS).
Talimatların çoğu, hangi Segment Register&amp;rsquo;ın kullanılacağını ima ediyordu: Talimatlar Kod Segmentinden alındı, &amp;lsquo;PUSH&amp;rsquo; ve &amp;lsquo;POP&amp;rsquo; Yığın Segmentini ima etti ve basit veri referansları Veri Segmentini ima etti - ancak bu, herhangi birinde belleğe erişmek için geçersiz kılınabilir.</description>
    </item>
    
    <item>
      <title>Kontrol akışı</title>
      <link>https://www.wikiod.com/tr/x86/kontrol-aks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/kontrol-aks/</guid>
      <description>Test koşulları # Koşullu atlama kullanmak için bir koşulun test edilmesi gerekir. Bir koşulu test etmek burada yalnızca bayrakları kontrol etme eylemi anlamına gelir, gerçek atlama [Koşullu atlamalar](https://www.wikiod.com/tr/x86/kontrol-aks#Koşullu atlamalar) altında açıklanmıştır -atlar).
x86, her komutun potansiyel olarak ayarlayabileceği bir dizi işaret içeren EFLAGS kaydına güvenerek koşulları test eder.
&amp;ldquo;sub&amp;rdquo; veya &amp;ldquo;add&amp;rdquo; gibi aritmetik komutlar ve &amp;ldquo;xor&amp;rdquo; veya &amp;ldquo;and&amp;rdquo; gibi mantıksal komutlar açıkça &amp;ldquo;bayrakları ayarlar&amp;rdquo;. Bu, CF, OF, SF, ZF, AF, PF işaretlerinin bu talimatlarla değiştirildiği anlamına gelir.</description>
    </item>
    
    <item>
      <title>Sayfalama - Sanal Adresleme ve Bellek</title>
      <link>https://www.wikiod.com/tr/x86/sayfalama---sanal-adresleme-ve-bellek/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/tr/x86/sayfalama---sanal-adresleme-ve-bellek/</guid>
      <description>Giriiş # Tarih # İlk bilgisayarlar # İlk bilgisayarlar, programcının kod ve veri koyduğu bir bellek bloğuna ve bu ortamda yürütülen CPU&amp;rsquo;ya sahipti. O zamanlar bilgisayarların çok pahalı olduğu göz önüne alındığında, bir işi yapması, durup bir sonraki işin yüklenmesini beklemesi ve ardından onu işlemesi talihsiz bir durumdu.
Çoklu kullanıcı, çoklu işlem # Böylece bilgisayarlar hızla daha karmaşık hale geldi ve aynı anda birden fazla kullanıcıyı ve/veya programı destekledi - ancak işte o zaman basit &amp;ldquo;bir bellek bloğu&amp;rdquo; fikriyle sorunlar ortaya çıkmaya başladı.</description>
    </item>
    
  </channel>
</rss>
