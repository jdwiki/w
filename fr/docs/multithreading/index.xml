<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel multithreading on </title>
    <link>https://www.wikiod.com/fr/docs/multithreading/</link>
    <description>Recent content in Tutoriel multithreading on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/multithreading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec le multithreading</title>
      <link>https://www.wikiod.com/fr/multithreading/premiers-pas-avec-le-multithreading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/multithreading/premiers-pas-avec-le-multithreading/</guid>
      <description>Interblocages # Un blocage se produit lorsque chaque membre d&amp;rsquo;un groupe de deux threads ou plus doit attendre que l&amp;rsquo;un des autres membres fasse quelque chose (par exemple, pour libérer un verrou) avant de pouvoir continuer. Sans intervention, les threads attendront indéfiniment.
Un exemple de pseudocode d&amp;rsquo;une conception sujette aux blocages est :
thread_1 { acquire(A) ... acquire(B) ... release(A, B) } thread_2 { acquire(B) ... acquire(A) ... release(A, B) } Un blocage peut se produire lorsque thread_1 a acquis A, mais pas encore B, et thread_2 a acquis B, mais pas A.</description>
    </item>
    
    <item>
      <title>Exécuteurs</title>
      <link>https://www.wikiod.com/fr/multithreading/executeurs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/multithreading/executeurs/</guid>
      <description>Syntaxe # ThreadPoolExecutor
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unité TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unité TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, gestionnaire RejectedExecutionHandler)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unité TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unité TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, gestionnaire RejectedExecutionHandler)
Executors.callable(PrivilegedAction&amp;lt;?&amp;gt; action)
Executors.callable(PrivilegedExceptionAction&amp;lt;?&amp;gt; action)
Executors.callable(Tâche exécutable)
Executors.callable(Tâche exécutable, résultat T)
Executors.defaultThreadFactory()
Executors.newCachedThreadPool()
Executors.newCachedThreadPool(ThreadFactory threadFactory)
Executors.newFixedThreadPool(int nThreads)
Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</description>
    </item>
    
    <item>
      <title>Sémaphores et mutex</title>
      <link>https://www.wikiod.com/fr/multithreading/semaphores-et-mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/multithreading/semaphores-et-mutex/</guid>
      <description>Les sémaphores et les mutex sont des contrôles de concurrence utilisés pour synchroniser l&amp;rsquo;accès de plusieurs threads aux ressources partagées.
Sémaphore # Voici une brillante explication de cette question Stackoverflow:
Considérez les sémaphores comme des videurs dans une boîte de nuit. Il y a un dédié nombre de personnes autorisées dans le club à la fois. Si le club est plein personne n&amp;rsquo;est autorisé à entrer, mais dès qu&amp;rsquo;une personne sort une autre personne pourrait entrer.</description>
    </item>
    
  </channel>
</rss>
