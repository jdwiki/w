<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel de langage Swift on </title>
    <link>https://www.wikiod.com/fr/docs/swift/</link>
    <description>Recent content in Tutoriel de langage Swift on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Swift Language</title>
      <link>https://www.wikiod.com/fr/swift/premiers-pas-avec-swift-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/premiers-pas-avec-swift-language/</guid>
      <description>Votre premier programme Swift # Écrivez votre code dans un fichier nommé hello.swift :
print(&amp;quot;Hello, world!&amp;quot;) Pour compiler et exécuter un script en une seule étape, utilisez swift depuis le terminal (dans un répertoire où se trouve ce fichier) : Pour lancer un terminal, appuyez sur CTRL+ALT+T sur Linux, ou trouvez-le dans Launchpad sur macOS. Pour changer de répertoire, entrez cdnom_répertoire (ou cd .. pour revenir en arrière)
$ swift bonjour.</description>
    </item>
    
    <item>
      <title>Chaînes et caractères</title>
      <link>https://www.wikiod.com/fr/swift/chaines-et-caracteres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/chaines-et-caracteres/</guid>
      <description>Syntaxe # String.characters // Renvoie un tableau des caractères de la chaîne String.characters.count // Renvoie le nombre de caractères String.utf8 // Un String.UTF8View, renvoie les points de caractère UTF-8 dans la chaîne String.utf16 // Une String.UTF16View, renvoie les points de caractère UTF-16 dans la chaîne String.unicodeScalars // Un String.UnicodeScalarView, renvoie les points de caractère UTF-32 dans la chaîne String.isEmpty // Renvoie vrai si la chaîne ne contient pas de texte String.</description>
    </item>
    
    <item>
      <title>Énumérations</title>
      <link>https://www.wikiod.com/fr/swift/enumerations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/enumerations/</guid>
      <description>Comme les structures et contrairement aux classes, les énumérations sont des types de valeur et sont copiées au lieu d&amp;rsquo;être référencées lorsqu&amp;rsquo;elles sont transmises.
Pour plus d&amp;rsquo;informations sur les énumérations, consultez Le langage de programmation Swift.
Énumérations de base # Un [enum][1] fournit un ensemble de valeurs liées :
enum Direction { case up case down case left case right } enum Direction { case up, down, left, right } Les valeurs Enum peuvent être utilisées par leur nom complet, mais vous pouvez omettre le nom du type lorsqu&amp;rsquo;il peut être déduit :</description>
    </item>
    
    <item>
      <title>Lecture et écriture JSON</title>
      <link>https://www.wikiod.com/fr/swift/lecture-et-ecriture-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/lecture-et-ecriture-json/</guid>
      <description>Syntaxe # NSJSONSerialization.JSONObjectWithData(jsonData, options : NSJSONReadingOptions) // Renvoie un objet à partir de jsonData. Cette méthode se solde par un échec. NSJSONSerialization.dataWithJSONObject(jsonObject, options : NSJSONWritingOptions) // Renvoie NSData à partir d&amp;rsquo;un objet JSON. Transmettez NSJSONWritingOptions.PrettyPrinted dans les options pour une sortie plus lisible. Sérialisation, encodage et décodage JSON avec Apple Foundation et la bibliothèque standard Swift # La classe JSONSerialization est intégrée au framework Foundation d&amp;rsquo;Apple.
Lire JSON # La fonction JSONObjectWithData prend NSData et renvoie AnyObject.</description>
    </item>
    
    <item>
      <title>Cryptage AES</title>
      <link>https://www.wikiod.com/fr/swift/cryptage-aes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/cryptage-aes/</guid>
      <description>Cryptage AES en mode CBC avec un IV aléatoire (Swift 3.0) # Le iv est préfixé aux données cryptées
aesCBC128Encrypt créera un IV aléatoire et préfixé au code crypté. aesCBC128Decrypt utilisera le préfixe IV lors du décryptage.
Les entrées sont les données et les clés sont des objets de données. Si un formulaire encodé tel que Base64 est requis, convertissez vers et/ou depuis la méthode d&amp;rsquo;appel.
La clé doit avoir exactement une longueur de 128 bits (16 octets), 192 bits (24 octets) ou 256 bits (32 octets).</description>
    </item>
    
    <item>
      <title>Réflexion</title>
      <link>https://www.wikiod.com/fr/swift/reflexion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/reflexion/</guid>
      <description>Syntaxe # Mirror(reflecting: instance) // Initialise un miroir avec le sujet à refléter mirror.displayStyle // Style d&amp;rsquo;affichage utilisé pour les terrains de jeux Xcode mirror.description // Représentation textuelle de cette instance, voir CustomStringConvertible mirror.subjectType // Renvoie le type du sujet reflété mirror.superclassMirror // Renvoie le miroir de la super-classe du sujet reflété *** Remarques générales : *** Un Mirror est un struct utilisé dans l&amp;rsquo;introspection d&amp;rsquo;un objet dans Swift. Sa propriété la plus importante est le tableau des enfants.</description>
    </item>
    
    <item>
      <title>Protocoles</title>
      <link>https://www.wikiod.com/fr/swift/protocoles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/protocoles/</guid>
      <description>Les protocoles sont un moyen de spécifier comment utiliser un objet. Ils décrivent un ensemble de propriétés et de méthodes qu&amp;rsquo;une classe, une structure ou une énumération devrait fournir, bien que les protocoles n&amp;rsquo;imposent aucune restriction sur l&amp;rsquo;implémentation.
Un protocole Swift est un ensemble d&amp;rsquo;exigences que les types conformes doivent implémenter. Le protocole peut alors être utilisé dans la plupart des endroits où un type est attendu, par exemple les tableaux et les exigences génériques.</description>
    </item>
    
    <item>
      <title>Options</title>
      <link>https://www.wikiod.com/fr/swift/options/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/options/</guid>
      <description>« Une valeur facultative contient une valeur ou contient nil pour indiquer qu&amp;rsquo;une valeur est manquante »
Extrait de : Apple Inc. &amp;ldquo;Le langage de programmation Swift (édition Swift 3.1)&amp;rdquo;. iBooks. https://itun.es/us/k5SW7.l
Les cas d&amp;rsquo;utilisation facultatifs de base incluent : pour une constante (let), l&amp;rsquo;utilisation d&amp;rsquo;un facultatif dans une boucle (if-let), le déballage en toute sécurité d&amp;rsquo;une valeur facultative dans une méthode (guard-let) et dans le cadre de boucles de commutation (case-let ), par défaut à une valeur si nulle, en utilisant l&amp;rsquo;opérateur de coalescence (?</description>
    </item>
    
    <item>
      <title>Méthode Swizzling</title>
      <link>https://www.wikiod.com/fr/swift/methode-swizzling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/methode-swizzling/</guid>
      <description>Lors de l&amp;rsquo;utilisation de la méthode swizzling dans Swift, il y a deux exigences auxquelles vos classes/méthodes doivent se conformer :
Votre classe doit étendre NSObject Les fonctions que vous souhaitez swizzler doivent avoir l&amp;rsquo;attribut dynamic Pour une explication complète de la raison pour laquelle cela est nécessaire, consultez [Using Swift with Cocoa and Objective-C][2] :
Nécessite une répartition dynamique
Alors que l&amp;rsquo;attribut @objc expose votre API Swift à l&amp;rsquo;Objective-C runtime, il ne garantit pas l&amp;rsquo;envoi dynamique d&amp;rsquo;une propriété, méthode, indice ou initialiseur.</description>
    </item>
    
    <item>
      <title>Fermetures</title>
      <link>https://www.wikiod.com/fr/swift/fermetures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/swift/fermetures/</guid>
      <description>Syntaxe # var closureVar : (&amp;lt;parameters&amp;gt;) -&amp;gt; (&amp;lt;returnType&amp;gt;) // En tant que variable ou type de propriété typealias ClosureType = (&amp;lt;parameters&amp;gt;) -&amp;gt; (&amp;lt;returnType&amp;gt;) { [&amp;lt;captureList&amp;gt;] (&amp;lt;parameters&amp;gt;) &amp;lt;throws-ness&amp;gt; -&amp;gt; &amp;lt;returnType&amp;gt; in &amp;lt;statements&amp;gt; } // Complète la syntaxe de fermeture Pour plus d&amp;rsquo;informations sur les fermetures Swift, consultez la documentation Apple.
Bases de la fermeture # Closures (également appelés blocs ou lambdas) sont des morceaux de code qui peuvent être stockés et transmis dans votre programme.</description>
    </item>
    
  </channel>
</rss>
