<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>opencl Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/opencl/</link>
    <description>Recent content in opencl Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/opencl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec opencl</title>
      <link>https://www.wikiod.com/fr/opencl/premiers-pas-avec-opencl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/premiers-pas-avec-opencl/</guid>
      <description>Qu&amp;rsquo;est-ce qu&amp;rsquo;OpenCL ? # OpenCL est l&amp;rsquo;abréviation de Open Ccomputing Llangage. OpenCL est un cadre de programmation parallèle sur des plates-formes hétérogènes, appelées * dispositifs de calcul *, allant des processeurs aux GPU en passant par des plates-formes plus spéciales comme les FPGA. OpenCL fournit une interface standard pour le calcul parallèle sur ces appareils de calcul mais également le parallélisme inter-appareils. Il spécifie un langage de programmation, basé sur C99, et les exigences minimales des fonctions de base mises en œuvre sur les appareils compatibles OpenCL.</description>
    </item>
    
    <item>
      <title>Opérations atomiques</title>
      <link>https://www.wikiod.com/fr/opencl/operations-atomiques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/operations-atomiques/</guid>
      <description>Syntaxe # int atomic_add ( volatile __global int *p , int val)
unsigned int atomic_add ( volatile __global unsigned int *p , unsigned int val)
int atomic_add ( volatile __local int *p , int val)
unsigned int atomic_add ( volatile __local unsigned int *p ,unsigned int val)
Paramètres # p avec pointeur vers la cellule ajouté à la cellule Les performances dépendent du nombre d&amp;rsquo;opérations atomiques et de l&amp;rsquo;espace mémoire. Le travail en série ralentit presque toujours l&amp;rsquo;exécution du noyau car le GPU est un tableau SIMD et chaque unité d&amp;rsquo;un tableau attend d&amp;rsquo;autres unités si elles ne font pas le même type de travail.</description>
    </item>
    
    <item>
      <title>Exemple de noyau de générateur de nombres pseudo-aléatoires</title>
      <link>https://www.wikiod.com/fr/opencl/exemple-de-noyau-de-generateur-de-nombres-pseudo-aleatoires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/exemple-de-noyau-de-generateur-de-nombres-pseudo-aleatoires/</guid>
      <description>Paramètres # Paramètre Détails __global entier non signé * rnd_buffer unsigned int est standardisé par la norme OpenCL comme étant 32 bits * __global signifie la mémoire principale de l&amp;rsquo;appareil pour l&amp;rsquo;accès en lecture/écriture * rnd_buffer est juste un nom dans la portée du &amp;ldquo;programme opencl&amp;rdquo; (pas d&amp;rsquo;hôte mais de périphérique) Utilisation de la fonction de hachage entier de Thomas Wang # Fonction auxiliaire qui prend une graine et évalue :</description>
    </item>
    
    <item>
      <title>Principes de base du matériel OpenCL</title>
      <link>https://www.wikiod.com/fr/opencl/principes-de-base-du-materiel-opencl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/principes-de-base-du-materiel-opencl/</guid>
      <description>Cette rubrique présente certains des mécanismes de base sous-jacents de l&amp;rsquo;informatique parallèle qui sont nécessaires pour bien comprendre et utiliser OpenCL.
Threads et exécution # La clé du parallélisme est d&amp;rsquo;utiliser plusieurs threads pour résoudre un problème (duh.) mais il y a quelques différences avec la programmation multithread classique dans la façon dont les threads sont organisés.
Parlons d&amp;rsquo;abord de votre GPU typique, pour des raisons de simplicité, je vais me concentrer sur</description>
    </item>
    
    <item>
      <title>Configuration de base d&#39;OpenCL</title>
      <link>https://www.wikiod.com/fr/opencl/configuration-de-base-dopencl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/configuration-de-base-dopencl/</guid>
      <description>Avant d&amp;rsquo;utiliser OpenCL, il faut configurer son code pour l&amp;rsquo;utiliser. Cette rubrique se concentre sur la façon de faire fonctionner opencl dans votre projet et d&amp;rsquo;exécuter un noyau de base. Les exemples sont basés sur le wrapper C# OpenCL.NET mais comme le wrapper n&amp;rsquo;ajoute aucune abstraction à OpenCL, le code s&amp;rsquo;exécutera probablement avec très peu de modifications sur C/C++ également.
Les appels en C# peuvent ressembler à ceci : &amp;lsquo;Cl.GetPlatformIDs&amp;rsquo;. Pour l&amp;rsquo;API OpenCL de style C, vous appelleriez &amp;lsquo;clGetPlatformIDs&amp;rsquo; et pour le style C++ un &amp;lsquo;cl::GetPlatformIDs&amp;rsquo;</description>
    </item>
    
    <item>
      <title>Principes de base du noyau</title>
      <link>https://www.wikiod.com/fr/opencl/principes-de-base-du-noyau/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/principes-de-base-du-noyau/</guid>
      <description>Cette rubrique vise à expliquer les principes fondamentaux de l&amp;rsquo;écriture de noyaux pour opencl
Noyau en niveaux de gris # Construisons un noyau pour générer une image en niveaux de gris. Nous utiliserons des données d&amp;rsquo;image qui sont définies en utilisant des uints pour chaque composant et avec l&amp;rsquo;ordre RGBA.
__constant sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR; __kernel void Grayscale(__read_only image2d_t input, __write_only image2d_t output) { int2 gid = (int2)(get_global_id(0), get_global_id(1)); int2 size = get_image_dim(input); if(all(gid &amp;lt; size)){ uint4 pixel = read_imageui(input, sampler, gid); float4 color = convert_float4(pixel) / 255; color.</description>
    </item>
    
    <item>
      <title>Interaction de la mémoire hôte</title>
      <link>https://www.wikiod.com/fr/opencl/interaction-de-la-memoire-hote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencl/interaction-de-la-memoire-hote/</guid>
      <description>Cette rubrique met en évidence différentes manières de placer des données à un endroit où votre appareil peut y accéder.
Lecture d&amp;rsquo;un tableau # Pour lire un tableau du périphérique vers l&amp;rsquo;hôte, on appelle
clEnqueueReadBuffer($queue, $memobj, $blocking, $offset, $size, $target, 0, null, null); La $queue est la CommandQueue qui a été utilisée pour allouer la mémoire sur le périphérique. Le $memobj contient l&amp;rsquo;adresse de la mémoire de l&amp;rsquo;appareil, $offset et $size définissent plus précisément d&amp;rsquo;où et combien de données sont copiées.</description>
    </item>
    
  </channel>
</rss>
