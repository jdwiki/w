<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel angulaire 2 on </title>
    <link>https://www.wikiod.com/fr/docs/angular2/</link>
    <description>Recent content in Tutoriel angulaire 2 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/angular2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Angular 2</title>
      <link>https://www.wikiod.com/fr/angular2/premiers-pas-avec-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/premiers-pas-avec-angular-2/</guid>
      <description>Installer angular2 avec angular-cli # Cet exemple est une configuration rapide d&amp;rsquo;Angular 2 et explique comment générer un exemple de projet rapide.
Conditions préalables: # [Node.js v4][1] ou supérieur. [npm][2] v3 ou supérieur ou [fil][3]. Ouvrez un terminal et exécutez les commandes une par une :
npm install -g @angular/cli ou
yarn global add @angular/cli en fonction de votre choix de gestionnaire de packages.
La commande précédente installe @angular/cli globalement, en ajoutant l&amp;rsquo;exécutable &amp;ldquo;ng&amp;rdquo; à PATH.</description>
    </item>
    
    <item>
      <title>Mise à jour des formulaires angulaires 2</title>
      <link>https://www.wikiod.com/fr/angular2/mise-a-jour-des-formulaires-angulaires-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/mise-a-jour-des-formulaires-angulaires-2/</guid>
      <description>Angular 2 permet d&amp;rsquo;accéder à l&amp;rsquo;instance ngForm en créant une variable de modèle locale. Angular 2 expose des instances de directive comme ngForm en spécifiant la propriété exportAs des métadonnées de la directive. Maintenant, l&amp;rsquo;avantage ici est que sans trop de codage, vous pouvez accéder à l&amp;rsquo;instance ngForm et l&amp;rsquo;utiliser pour accéder aux valeurs soumises ou pour vérifier si tous les champs sont valides à l&amp;rsquo;aide de propriétés (valide, soumis, valeur, etc.</description>
    </item>
    
    <item>
      <title>Tuyaux</title>
      <link>https://www.wikiod.com/fr/angular2/tuyaux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/tuyaux/</guid>
      <description>Le caractère de pipe | est utilisé pour appliquer des pipes dans Angular 2. Les pipes sont très similaires aux filtres dans AngularJS en ce sens qu&amp;rsquo;ils aident tous les deux à transformer les données dans un format spécifié.
Paramètres # Fonction/Paramètre Explication @Pipe({nom, pur}) métadonnées pour le canal, doivent précéder immédiatement la classe de canal nom : chaîne ce que vous utiliserez dans le modèle pur : booléen est vrai par défaut, marquez-le comme faux pour que votre tuyau soit réévalué plus souvent transform( valeur, args[]?</description>
    </item>
    
    <item>
      <title>Ajouter dynamiquement des composants à l&#39;aide de ViewContainerRef.createComponent</title>
      <link>https://www.wikiod.com/fr/angular2/ajouter-dynamiquement-des-composants-a-laide-de-viewcontainerrefcreatecomponent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/ajouter-dynamiquement-des-composants-a-laide-de-viewcontainerrefcreatecomponent/</guid>
      <description>Un composant wrapper qui ajoute des composants dynamiques de manière déclarative # Un composant personnalisé qui prend le type d&amp;rsquo;un composant en entrée et crée une instance de ce type de composant à l&amp;rsquo;intérieur de lui-même. Lorsque l&amp;rsquo;entrée est mise à jour, le composant dynamique précédemment ajouté est supprimé et le nouveau ajouté à la place.
@Component({ selector: &#39;dcl-wrapper&#39;, template: `&amp;lt;div #target&amp;gt;&amp;lt;/div&amp;gt;` }) export class DclWrapper { @ViewChild(&#39;target&#39;, { read: ViewContainerRef }) target; @Input() type; cmpRef: ComponentRef; private isViewInitialized: boolean = false; constructor(private resolver: ComponentResolver) {} updateComponent() { if (!</description>
    </item>
    
    <item>
      <title>Se moquer de @ngrxStore</title>
      <link>https://www.wikiod.com/fr/angular2/se-moquer-de-ngrxstore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/se-moquer-de-ngrxstore/</guid>
      <description>@ngrx/Store est de plus en plus utilisé dans les projets Angular 2. A ce titre, le Store doit obligatoirement être injecté dans le constructeur de tout Composant ou Service qui souhaite l&amp;rsquo;utiliser. Tests unitaires Le magasin n&amp;rsquo;est pas aussi simple que de tester un service simple. Comme pour de nombreux problèmes, il existe une myriade de façons de mettre en œuvre des solutions. Cependant, la recette de base consiste à écrire une classe fictive pour l&amp;rsquo;interface Observer et à écrire une classe fictive pour Store.</description>
    </item>
    
    <item>
      <title>Sujets et observables angulaires RXJS avec requêtes API</title>
      <link>https://www.wikiod.com/fr/angular2/sujets-et-observables-angulaires-rxjs-avec-requetes-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/sujets-et-observables-angulaires-rxjs-avec-requetes-api/</guid>
      <description>Faire des requêtes API avec le service Angular 2 Http et RxJS est très similaire à travailler avec des promesses dans Angular 1.x.
Utilisez la classe Http pour effectuer des requêtes. La classe Http expose les méthodes d&amp;rsquo;émission des requêtes HTTP GET, POST, PUT, DELETE, PATCH, HEAD via les méthodes correspondantes. Il expose également une méthode générique &amp;ldquo;request&amp;rdquo; pour émettre tout type de requête HTTP.
Toutes les méthodes de la classe Http renvoient un Observable&amp;lt;Response&amp;gt;, auquel vous pouvez appliquer des opérations RxJS.</description>
    </item>
    
    <item>
      <title>Routage (3.0.0&#43;)</title>
      <link>https://www.wikiod.com/fr/angular2/routage-300-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/routage-300-/</guid>
      <description>Il y a quelques astuces supplémentaires que nous pouvons faire avec le routeur (comme restreindre l&amp;rsquo;accès), mais celles-ci peuvent être couvertes dans un tutoriel séparé.
Si vous avez besoin d&amp;rsquo;une nouvelle route, modifiez simplement app.routes.ts et suivez les étapes suivantes :
Importer le composant Ajoutez au tableau routes. Assurez-vous d&amp;rsquo;inclure un nouveau path et component. Contrôler l&amp;rsquo;accès vers ou depuis une route # Le routeur angulaire par défaut permet la navigation vers et depuis n&amp;rsquo;importe quel itinéraire sans condition.</description>
    </item>
    
    <item>
      <title>Bootstrap Module vide dans angular 2</title>
      <link>https://www.wikiod.com/fr/angular2/bootstrap-module-vide-dans-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/bootstrap-module-vide-dans-angular-2/</guid>
      <description>Un module vide # import { NgModule } from &#39;@angular/core&#39;; @NgModule({ declarations: [], // components your module owns. imports: [], // other modules your module needs. providers: [], // providers available to your module. bootstrap: [] // bootstrap this root component. }) export class MyModule {} Il s&amp;rsquo;agit d&amp;rsquo;un module vide ne contenant aucune déclaration, importation, fournisseur ou composant à amorcer. Utilisez ceci comme référence.
Module racine de l&amp;rsquo;application # import { NgModule } from &#39;@angular/core&#39;; import { BrowserModule } from &#39;@angular/platform-browser&#39;; import { AppComponent } from &#39;.</description>
    </item>
    
    <item>
      <title>Tester une application Angular 2</title>
      <link>https://www.wikiod.com/fr/angular2/tester-une-application-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/tester-une-application-angular-2/</guid>
      <description>Installation du framework de test Jasmine # Le moyen le plus courant de tester les applications Angular 2 consiste à utiliser le framework de test Jasmine. Jasmine vous permet de tester votre code dans le navigateur.
Installer # Pour commencer, tout ce dont vous avez besoin est le package jasmine-core (pas jasmine).
npm install jasmine-core --save-dev --save-exact Vérifier # Pour vérifier que Jasmine est correctement configuré, créez le fichier ./src/unit-tests.html avec le contenu suivant et ouvrez-le dans le navigateur.</description>
    </item>
    
    <item>
      <title>Détection des événements de redimensionnement</title>
      <link>https://www.wikiod.com/fr/angular2/detection-des-evenements-de-redimensionnement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/angular2/detection-des-evenements-de-redimensionnement/</guid>
      <description>Un composant écoutant l&amp;rsquo;événement de redimensionnement de la fenêtre. # Supposons que nous ayons un composant qui se cachera à une certaine largeur de fenêtre.
import { Component } from &#39;@angular/core&#39;; @Component({ ... template: ` &amp;lt;div&amp;gt; &amp;lt;p [hidden]=&amp;quot;!visible&amp;quot; (window:resize)=&amp;quot;onResize($event)&amp;quot; &amp;gt;Now you see me...&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;now you dont!&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ` ... }) export class MyComponent { visible: boolean = false; breakpoint: number = 768; constructor() { } onResize(event) { const w = event.</description>
    </item>
    
  </channel>
</rss>
