<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel sur le langage prologue on </title>
    <link>https://www.wikiod.com/fr/docs/prolog/</link>
    <description>Recent content in Tutoriel sur le langage prologue on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/prolog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec le langage Prolog</title>
      <link>https://www.wikiod.com/fr/prolog/premiers-pas-avec-le-langage-prolog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/premiers-pas-avec-le-langage-prolog/</guid>
      <description>Programmation de la base de données # Prolog catégorise tout en :
Atomes - Toute séquence de caractères qui ne commence pas par un alphabet majuscule. Par exemple - &amp;lsquo;a&amp;rsquo;, &amp;lsquo;b&amp;rsquo;, &amp;rsquo;d&amp;rsquo;accord&amp;rsquo; Numéros - Il n&amp;rsquo;y a pas de syntaxe spéciale pour les nombres, aucune déclaration n&amp;rsquo;est requise. Par exemple, 1, 22, 35.8 Variables - Une chaîne commençant par une majuscule ou un trait de soulignement (_). Par exemple, &amp;lsquo;X&amp;rsquo;, &amp;lsquo;Y&amp;rsquo;, &amp;lsquo;Abc&amp;rsquo;, &amp;lsquo;AA&amp;rsquo; Termes complexes - Ils sont constitués d&amp;rsquo;un foncteur et d&amp;rsquo;une suite d&amp;rsquo;arguments.</description>
    </item>
    
    <item>
      <title>Structures de contrôle</title>
      <link>https://www.wikiod.com/fr/prolog/structures-de-controle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/structures-de-controle/</guid>
      <description>Disjonction (OU logique), implicite vs explicite # Prolog essaie des clauses alternatives pour un prédicat dans l&amp;rsquo;ordre d&amp;rsquo;apparition :
likes(alice, music). likes(bob, hiking). // Either alice likes music, or bob likes hiking will succeed. L&amp;rsquo;opérateur de disjonction (OU) ; peut être utilisé pour exprimer cela en une seule règle :
likes(P,Q) :- ( P = alice , Q = music ) ; ( P = bob , Q = hiking ).</description>
    </item>
    
    <item>
      <title>Structures de données</title>
      <link>https://www.wikiod.com/fr/prolog/structures-de-donnees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/structures-de-donnees/</guid>
      <description>Listes d&amp;rsquo;associations # Dans tous les systèmes Prolog sérieux, des listes d&amp;rsquo;associations sont disponibles pour permettre un accès plus rapide que linéaire à une collection d&amp;rsquo;éléments. Ces listes d&amp;rsquo;associations sont généralement basées sur des arbres équilibrés comme les arbres AVL. Il existe une bibliothèque du domaine public appelée library(assoc) qui est livrée avec de nombreux systèmes Prolog et fournit des opérations O(log(N)) pour insérer, récupérer et modifier des éléments dans une collection.</description>
    </item>
    
    <item>
      <title>Monotonie</title>
      <link>https://www.wikiod.com/fr/prolog/monotonie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/monotonie/</guid>
      <description>Alternatives monotones pour les constructions non monotones # Voici des exemples d&amp;rsquo;utilisation de prédicats monotones au lieu de constructions impures et non monotones dans vos programmes :
dif/2 est destiné à être utilisé au lieu de constructions non monotones comme (\=)/2 les contraintes arithmétiques (CLP(FD), CLP(Q) et autres) sont destinées à être utilisées au lieu des prédicats arithmétiques modisés !/0 conduit presque toujours à des programmes non monotones et doit être évité complètement.</description>
    </item>
    
    <item>
      <title>Arbres de dérivation</title>
      <link>https://www.wikiod.com/fr/prolog/arbres-de-derivation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/arbres-de-derivation/</guid>
      <description>Arbre de preuve # L&amp;rsquo;arbre de preuve (aussi arbre de recherche ou arbre de dérivation) est un arbre qui montre l&amp;rsquo;exécution d&amp;rsquo;un programme Prolog. Cet arbre permet de visualiser le processus de retour en arrière chronologique présent dans Prolog. La racine de l&amp;rsquo;arbre représente la requête initiale et des branches sont créées lorsque des points de choix se produisent. Chaque nœud de l&amp;rsquo;arbre représente donc un objectif. Les branches ne deviennent des feuilles que lorsque l&amp;rsquo;un ou l&amp;rsquo;autre vrai/faux a été prouvé pour l&amp;rsquo;ensemble d&amp;rsquo;objectifs requis et que la recherche dans Prolog est effectuée de manière de gauche à droite en profondeur d&amp;rsquo;abord.</description>
    </item>
    
    <item>
      <title>Raisonner sur les données</title>
      <link>https://www.wikiod.com/fr/prolog/raisonner-sur-les-donnees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/raisonner-sur-les-donnees/</guid>
      <description>Une nouvelle section intitulée Structures de données a vu le jour où des explications sur certaines structures + quelques exemples simples de création sont fournis. Pour que son contenu reste concis et épuré, il ne doit contenir aucune documentation sur la manipulation des données.
Par conséquent, cette section a été renommée &amp;ldquo;Raisonnement sur les données&amp;rdquo; avec pour objectif la généralisation du raisonnement sur les données en Prolog. Cela pourrait inclure des sujets allant de «l&amp;rsquo;inférence descendante» à «l&amp;rsquo;exploration de listes», ainsi que de nombreux autres.</description>
    </item>
    
    <item>
      <title>Programmation en logique de contraintes</title>
      <link>https://www.wikiod.com/fr/prolog/programmation-en-logique-de-contraintes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/programmation-en-logique-de-contraintes/</guid>
      <description>CLP(FD) # Les contraintes CLP(FD) (domaines finis) implémentent l&amp;rsquo;arithmétique sur des entiers. Ils sont disponibles dans toutes les implémentations sérieuses de Prolog.
Il existe deux principaux cas d&amp;rsquo;utilisation des contraintes CLP(FD) :
Arithmétique entière déclarative Résoudre des problèmes combinatoires tels que la planification, l&amp;rsquo;ordonnancement et l&amp;rsquo;allocation des tâches. Exemples:
?- X #= 1+2. X = 3. ?- 3 #= Y+2. Y = 1. Notez que si is/2 devait être utilisé dans la deuxième requête, une erreur d&amp;rsquo;instanciation se produirait :</description>
    </item>
    
    <item>
      <title>Programmation d&#39;ordre supérieur</title>
      <link>https://www.wikiod.com/fr/prolog/programmation-dordre-superieur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/programmation-dordre-superieur/</guid>
      <description>call/N prédicats # La famille de prédicats call/N peut appeler des objectifs Prolog arbitraires à l&amp;rsquo;exécution :
?- G=true, call(G). true. ?- G=(true,false), call(G). false. liste de cartes/[2,3] # maplist/2 et maplist/3 sont des prédicats d&amp;rsquo;ordre supérieur, qui permettent de relever la définition d&amp;rsquo;un prédicat autour d&amp;rsquo;un seul élément vers des listes de tels éléments. Ces prédicats peuvent être définis en utilisant call/2 et call/3 comme blocs de construction et sont livrés avec de nombreux systèmes Prolog.</description>
    </item>
    
    <item>
      <title>Pureté logique</title>
      <link>https://www.wikiod.com/fr/prolog/purete-logique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/purete-logique/</guid>
      <description>dif/2 # Le prédicat dif/2 est un prédicat pur : il peut être utilisé dans toutes les directions et avec tous les modèles d&amp;rsquo;instanciation, toujours signifiant que ses deux arguments sont différents.
Unification # Unification est une relation pure. Il ne produit pas d&amp;rsquo;effets secondaires et peut être utilisé dans toutes les directions, avec l&amp;rsquo;un ou les deux arguments entièrement ou partiellement instanciés.
En Prolog, l&amp;rsquo;unification peut arriver
explicitement, en utilisant des prédicats intégrés comme (=)/2 ou unify_with_occurs_check/2 implicitement, lorsque l&amp;rsquo;unification est utilisée pour sélectionner une clause appropriée.</description>
    </item>
    
    <item>
      <title>Utilisation de Prolog moderne</title>
      <link>https://www.wikiod.com/fr/prolog/utilisation-de-prolog-moderne/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/prolog/utilisation-de-prolog-moderne/</guid>
      <description>CLP(FD) pour l&amp;rsquo;arithmétique entière # Traditionnellement, Prolog effectuait l&amp;rsquo;arithmétique en utilisant les opérateurs is et =:=. Cependant, plusieurs prologues actuels proposent CLP (FD) (programmation logique par contraintes sur des domaines finis) comme alternative plus propre à l&amp;rsquo;arithmétique entière. CLP(FD) est basé sur le stockage des contraintes qui s&amp;rsquo;appliquent à une valeur entière et sur leur combinaison en mémoire.
CLP(FD) est une extension dans la plupart des Prologs qui le supportent, il doit donc être chargé explicitement.</description>
    </item>
    
  </channel>
</rss>
