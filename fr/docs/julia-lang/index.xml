<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel de langue Julia on </title>
    <link>https://www.wikiod.com/fr/docs/julia-lang/</link>
    <description>Recent content in Tutoriel de langue Julia on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/julia-lang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Julia Language</title>
      <link>https://www.wikiod.com/fr/julia-lang/premiers-pas-avec-julia-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/premiers-pas-avec-julia-language/</guid>
      <description>Bonjour le monde! # println(&amp;quot;Hello, World!&amp;quot;) Pour exécuter Julia, obtenez d&amp;rsquo;abord l&amp;rsquo;interpréteur à partir de la [page de téléchargement] du site Web (http://julialang.org/downloads/). La version stable actuelle est la v0.5.0, et cette version est recommandée pour la plupart des utilisateurs. Certains développeurs de packages ou utilisateurs expérimentés peuvent choisir d&amp;rsquo;utiliser la version nocturne, qui est beaucoup moins stable.
Lorsque vous avez l&amp;rsquo;interpréteur, écrivez votre programme dans un fichier nommé hello.jl. Il peut ensuite être exécuté à partir d&amp;rsquo;un terminal système comme :</description>
    </item>
    
    <item>
      <title>pour les boucles</title>
      <link>https://www.wikiod.com/fr/julia-lang/pour-les-boucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/pour-les-boucles/</guid>
      <description>Syntaxe # pour i dans iter ; &amp;hellip;; fin tandis que cond ; &amp;hellip;; fin Pause Continuez @parallel (op) pour i dans iter ; &amp;hellip;; fin @parallel pour i dans iter ; &amp;hellip;; fin @goto étiquette @étiquette étiquette Chaque fois que cela rend le code plus court et plus facile à lire, envisagez d&amp;rsquo;utiliser des fonctions d&amp;rsquo;ordre supérieur, telles que map ou filter, au lieu de boucles.
Trouver le plus petit facteur premier # Dans certaines situations, on peut vouloir revenir d&amp;rsquo;une fonction avant de terminer une boucle entière.</description>
    </item>
    
    <item>
      <title>Fermetures</title>
      <link>https://www.wikiod.com/fr/julia-lang/fermetures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/fermetures/</guid>
      <description>Syntaxe # -x -&amp;gt; [corps]
(x, y) -&amp;gt; [corps] (xs&amp;hellip;) -&amp;gt; [corps] Dans les anciennes versions de Julia, les fermetures et les fonctions anonymes avaient une pénalité de performance d&amp;rsquo;exécution. Cette pénalité a été supprimée en 0.5.
## Introduction aux fermetures [Les fonctions] [1] sont une partie importante de la programmation Julia. Elles peuvent être définies directement dans les modules, auquel cas les fonctions sont appelées top-level. Mais les fonctions peuvent également être définies dans d&amp;rsquo;autres fonctions.</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/fr/julia-lang/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/json/</guid>
      <description>Syntaxe # en utilisant JSON JSON.parse(chaîne) JSON.json(obj) JSON.print(io, obj, retrait) Étant donné que ni les objets Julia Dict ni les objets JSON ne sont intrinsèquement ordonnés, il est préférable de ne pas se fier à l&amp;rsquo;ordre des paires clé-valeur dans un objet JSON.
Installation de JSON.jl # JSON est un format d&amp;rsquo;échange de données populaire. La bibliothèque JSON la plus populaire pour Julia est JSON.jl. Pour installer ce package, utilisez le gestionnaire de packages :</description>
    </item>
    
    <item>
      <title>Saisir</title>
      <link>https://www.wikiod.com/fr/julia-lang/saisir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/saisir/</guid>
      <description>Syntaxe # readline() lignes de lecture() chaîne de lecture (STDIN) chomp(str) ouvrir(f, fichier) contour des yeux (io) readstring(fichier) lire (fichier) readcsv (fichier) readdlm(fichier) Paramètres # Paramètre Détails chomp(str) Supprimez jusqu&amp;rsquo;à un retour à la ligne de fin d&amp;rsquo;une chaîne. str La chaîne à partir de laquelle supprimer une nouvelle ligne de fin. Notez que [strings][1] sont immuables par convention. Cette fonction renvoie une nouvelle chaîne. ouvrir(f, fichier) Ouvrez un fichier, appelez la fonction, puis fermez le fichier.</description>
    </item>
    
    <item>
      <title>Conditionnels</title>
      <link>https://www.wikiod.com/fr/julia-lang/conditionnels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/conditionnels/</guid>
      <description>Syntaxe # si cond ; corps; fin si cond ; corps; autre; corps; fin si cond ; corps; sinon cond ; corps; autre; fin si cond ; corps; sinon cond ; corps; fin -cond ? si vrai : iffalse cond &amp;amp;&amp;amp; si vrai cond || si faux ifelse(cond, iftrue, iffalse) Tous les opérateurs et fonctions conditionnels impliquent l&amp;rsquo;utilisation de conditions booléennes (&amp;ldquo;true&amp;rdquo; ou &amp;ldquo;false&amp;rdquo;). Dans Julia, le type des booléens est Bool.</description>
    </item>
    
    <item>
      <title>Métaprogrammation</title>
      <link>https://www.wikiod.com/fr/julia-lang/metaprogrammation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/metaprogrammation/</guid>
      <description>Syntaxe # nom de la macro (ex) &amp;hellip; fin citation &amp;hellip; fin :(&amp;hellip;) $x Meta.quot(x) QuoteNode(x) esc(x) Les fonctionnalités de métaprogrammation de Julia sont fortement inspirées de celles des langages de type Lisp et sembleront familières à ceux qui ont une certaine expérience de Lisp. La métaprogrammation est très puissante. Lorsqu&amp;rsquo;il est utilisé correctement, il peut conduire à un code plus concis et lisible.
Le quote ... end est une syntaxe quasiquote.</description>
    </item>
    
    <item>
      <title>Traitement parallèle</title>
      <link>https://www.wikiod.com/fr/julia-lang/traitement-parallele/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/traitement-parallele/</guid>
      <description>@async et @sync # Selon la documentation sous ?@async, &amp;ldquo;@async encapsule une expression dans une tâche&amp;rdquo;. Cela signifie que pour tout ce qui entre dans son champ d&amp;rsquo;application, Julia lancera cette tâche en cours d&amp;rsquo;exécution, mais passera ensuite à ce qui vient ensuite dans le script sans attendre la fin de la tâche. Ainsi, par exemple, sans la macro vous obtiendrez :
julia&amp;gt; @time sleep(2) 2.005766 seconds (13 allocations: 624 bytes) Mais avec la macro, vous obtenez :</description>
    </item>
    
    <item>
      <title>Tuples</title>
      <link>https://www.wikiod.com/fr/julia-lang/tuples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/tuples/</guid>
      <description>Syntaxe # un, un B a, b = xs () (un,) (un B) (un B&amp;hellip;) Tuple{T, U, V} NTuple{N, T} Tuple{T, U, Vararg{V}} Les tuples ont de bien meilleures performances d&amp;rsquo;exécution que [arrays][1] pour deux raisons : leurs types sont plus précis et leur immuabilité leur permet d&amp;rsquo;être alloués sur la pile au lieu du tas. Cependant, ce typage plus précis s&amp;rsquo;accompagne à la fois d&amp;rsquo;une surcharge de temps de compilation et de plus de difficulté à atteindre la [stabilité de type] [2].</description>
    </item>
    
    <item>
      <title>Tests unitaires</title>
      <link>https://www.wikiod.com/fr/julia-lang/tests-unitaires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/julia-lang/tests-unitaires/</guid>
      <description>Syntaxe # @test [expression] @test_throws [Exception] [expression] @testset &amp;ldquo;[nom]&amp;rdquo; commence ; [essais] ; fin Pkg.test([paquet]) La documentation de la bibliothèque standard pour Base.Test couvre des éléments supplémentaires au-delà de ceux présentés dans ces exemples.
Tester un paquet # Pour exécuter les tests unitaires d&amp;rsquo;un paquet, utilisez la fonction Pkg.test. Pour un package nommé MyPackage, la commande serait
julia&amp;gt; Pkg.test(&amp;quot;MyPackage&amp;quot;) Une sortie attendue serait similaire à
INFO: Computing test dependencies for MyPackage.</description>
    </item>
    
  </channel>
</rss>
