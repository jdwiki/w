<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel Kotlin on </title>
    <link>https://www.wikiod.com/fr/docs/kotlin/</link>
    <description>Recent content in Tutoriel Kotlin on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/kotlin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Kotlin</title>
      <link>https://www.wikiod.com/fr/kotlin/premiers-pas-avec-kotlin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/premiers-pas-avec-kotlin/</guid>
      <description>Bonjour le monde # Tous les programmes Kotlin commencent par la fonction &amp;ldquo;main&amp;rdquo;. Voici un exemple d&amp;rsquo;un simple programme Kotlin &amp;ldquo;Hello World&amp;rdquo;:
package my.program fun main(args: Array&amp;lt;String&amp;gt;) { println(&amp;quot;Hello, world!&amp;quot;) } Placez le code ci-dessus dans un fichier nommé Main.kt (ce nom de fichier est entièrement arbitraire)
Lors du ciblage de la JVM, la fonction sera compilée en tant que méthode statique dans une classe avec un nom dérivé du nom de fichier.</description>
    </item>
    
    <item>
      <title>Boucles à Kotlin</title>
      <link>https://www.wikiod.com/fr/kotlin/boucles-a-kotlin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/boucles-a-kotlin/</guid>
      <description>Dans Kotlin, les boucles sont compilées en boucles optimisées dans la mesure du possible. Par exemple, si vous parcourez une plage de nombres, le bytecode sera compilé dans une boucle correspondante basée sur des valeurs int simples pour éviter la surcharge de la création d&amp;rsquo;objets.
Boucle sur les itérables # Vous pouvez boucler sur n&amp;rsquo;importe quel itérable en utilisant la boucle for standard :
val list = listOf(&amp;quot;Hello&amp;quot;, &amp;quot;World&amp;quot;, &amp;quot;!&amp;quot;) for(str in list) { print(str) } Beaucoup de choses dans Kotlin sont itérables, comme les plages de nombres :</description>
    </item>
    
    <item>
      <title>Équivalents de flux Java 8</title>
      <link>https://www.wikiod.com/fr/kotlin/equivalents-de-flux-java-8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/equivalents-de-flux-java-8/</guid>
      <description>Kotlin fournit de nombreuses méthodes d&amp;rsquo;extension sur les collections et les itérables pour appliquer des opérations de style fonctionnel. Un type Séquence dédié permet la composition paresseuse de plusieurs de ces opérations.
À propos de la paresse # Si vous souhaitez traiter paresseusement une chaîne, vous pouvez convertir une Séquence en utilisant asSequence() avant la chaîne. À la fin de la chaîne de fonctions, vous vous retrouvez généralement avec une « séquence ».</description>
    </item>
    
    <item>
      <title>Énumération</title>
      <link>https://www.wikiod.com/fr/kotlin/enumeration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/enumeration/</guid>
      <description>Tout comme en Java, les classes enum de Kotlin disposent de méthodes synthétiques permettant de lister les constantes enum définies et d&amp;rsquo;obtenir une constante enum par son nom. Les signatures de ces méthodes sont les suivantes (en supposant que le nom de la classe enum est EnumClass):
EnumClass.valueOf(value: String): EnumClass EnumClass.values(): Array&amp;lt;EnumClass&amp;gt; La méthode valueOf() lève une IllegalArgumentException si le nom spécifié ne correspond à aucune des constantes enum définies dans la classe.</description>
    </item>
    
    <item>
      <title>Paramètres Vararg dans les fonctions</title>
      <link>https://www.wikiod.com/fr/kotlin/parametres-vararg-dans-les-fonctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/parametres-vararg-dans-les-fonctions/</guid>
      <description>Syntaxe # Mot-clé Vararg : vararg est utilisé dans une déclaration de méthode pour indiquer qu&amp;rsquo;un nombre variable de paramètres sera accepté. Opérateur de propagation : un astérisque (*) avant un tableau utilisé dans les appels de fonction pour &amp;ldquo;déplier&amp;rdquo; le contenu en paramètres individuels. Notions de base : utilisation du mot-clé vararg # Définissez la fonction à l&amp;rsquo;aide du mot-clé vararg.
fun printNumbers(vararg numbers: Int) { for (number in numbers) { println(number) } } Vous pouvez maintenant passer autant de paramètres (du type correct) dans la fonction que vous le souhaitez.</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>https://www.wikiod.com/fr/kotlin/interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/interfaces/</guid>
      <description>Voir aussi : Documentation de référence Kotlin pour les interfaces : Interfaces
Interface avec les implémentations par défaut # Une interface dans Kotlin peut avoir des implémentations par défaut pour les fonctions :
interface MyInterface { fun withImplementation() { print(&amp;quot;withImplementation() was called&amp;quot;) } } Les classes implémentant de telles interfaces pourront utiliser ces fonctions sans réimplémenter
class MyClass: MyInterface { // No need to reimplement here } val instance = MyClass() instance.</description>
    </item>
    
    <item>
      <title>Méthodes d&#39;extension</title>
      <link>https://www.wikiod.com/fr/kotlin/methodes-dextension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/methodes-dextension/</guid>
      <description>Syntaxe # fun TypeName.extensionName(params, &amp;hellip;) { /* body */ } // Déclaration fun &amp;lt;T: Any&amp;gt; TypeNameWithGenerics&amp;lt;T&amp;gt;.extensionName(params, &amp;hellip;) { /* body */ } // Déclaration avec des génériques myObj.extensionName(args, &amp;hellip;) // invocation Les extensions sont résolues statiquement. Cela signifie que la méthode d&amp;rsquo;extension à utiliser est déterminée par le type de référence de la variable à laquelle vous accédez ; peu importe le type de la variable au moment de l&amp;rsquo;exécution, la même méthode d&amp;rsquo;extension sera toujours appelée.</description>
    </item>
    
    <item>
      <title>Extensions Android Kotlin</title>
      <link>https://www.wikiod.com/fr/kotlin/extensions-android-kotlin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/extensions-android-kotlin/</guid>
      <description>Kotlin a une injection de vue intégrée pour Android, permettant d&amp;rsquo;ignorer la liaison manuelle ou le besoin de frameworks tels que ButterKnife. Certains des avantages sont une syntaxe plus agréable, un meilleur typage statique et donc moins sujet aux erreurs.
Utilisation des vues # En supposant que nous ayons une activité avec un exemple de mise en page appelé activity_main.xml :
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt; &amp;lt;LinearLayout xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot; android:layout_width=&amp;quot;match_parent&amp;quot; android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt; &amp;lt;Button android:id=&amp;quot;@+id/my_button&amp;quot; android:layout_width=&amp;quot;wrap_content&amp;quot; android:layout_height=&amp;quot;wrap_content&amp;quot; android:text=&amp;quot;My button&amp;quot;/&amp;gt; &amp;lt;/LinearLayout&amp;gt; Nous pouvons utiliser les extensions Kotlin pour appeler le bouton sans aucune liaison supplémentaire comme ceci :</description>
    </item>
    
    <item>
      <title>Expressions conditionnelles</title>
      <link>https://www.wikiod.com/fr/kotlin/expressions-conditionnelles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/expressions-conditionnelles/</guid>
      <description>Contrairement au switch de Java, l&amp;rsquo;instruction when n&amp;rsquo;a pas de comportement d&amp;rsquo;échec. Cela signifie que si une branche correspond, le flux de contrôle revient après son exécution et aucune instruction &amp;ldquo;break&amp;rdquo; n&amp;rsquo;est requise. Si vous souhaitez combiner les comportements pour plusieurs arguments, vous pouvez écrire plusieurs arguments séparés par des virgules :
when (x) { &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot; -&amp;gt; println(&amp;quot;either foo or bar&amp;quot;) else -&amp;gt; println(&amp;quot;didn&#39;t match anything&amp;quot;) } Correspondance des arguments de l&amp;rsquo;instruction When # Lorsqu&amp;rsquo;un argument est donné, l&amp;rsquo;instruction when correspond à l&amp;rsquo;argument par rapport aux branches dans l&amp;rsquo;ordre.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://www.wikiod.com/fr/kotlin/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/kotlin/exceptions/</guid>
      <description>Attraper l&amp;rsquo;exception avec try-catch-finally # La capture d&amp;rsquo;exceptions dans Kotlin ressemble beaucoup à Java
try { doSomething() } catch(e: MyException) { handle(e) } finally { cleanup() } Vous pouvez également intercepter plusieurs exceptions
try { doSomething() } catch(e: FileSystemException) { handle(e) } catch(e: NetworkException) { handle(e) } catch(e: MemoryException) { handle(e) } finally { cleanup() } try est également une expression et peut renvoyer une valeur
val s: String? = try { getString() } catch (e: Exception) { null } Kotlin n&amp;rsquo;a pas vérifié les exceptions, vous n&amp;rsquo;avez donc pas à intercepter d&amp;rsquo;exceptions.</description>
    </item>
    
  </channel>
</rss>
