<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vhdl Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/vhdl/</link>
    <description>Recent content in vhdl Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/vhdl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec vhdl</title>
      <link>https://www.wikiod.com/fr/vhdl/premiers-pas-avec-vhdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/premiers-pas-avec-vhdl/</guid>
      <description>Signaux vs variables, un bref aperçu de la sémantique de simulation du VHDL # Cet exemple traite d&amp;rsquo;un des aspects les plus fondamentaux du langage VHDL : la sémantique de simulation. Il est destiné aux débutants en VHDL et présente une vue simplifiée où de nombreux détails ont été omis (processus reportés, interface procédurale VHDL, variables partagées&amp;hellip;) Les lecteurs intéressés par la vraie sémantique complète devront se référer au Language Reference Manual (LRM).</description>
    </item>
    
    <item>
      <title>Conception de matériel numérique utilisant VHDL en bref</title>
      <link>https://www.wikiod.com/fr/vhdl/conception-de-materiel-numerique-utilisant-vhdl-en-bref/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/conception-de-materiel-numerique-utilisant-vhdl-en-bref/</guid>
      <description>Dans ce sujet, nous proposons une méthode simple pour concevoir correctement des circuits numériques simples avec VHDL. La méthode est basée sur des schémas blocs graphiques et un principe simple à retenir :
Pensez d&amp;rsquo;abord au matériel, codez VHDL ensuite
Il est destiné aux débutants en conception de matériel numérique utilisant VHDL, avec une compréhension limitée de la sémantique de synthèse du langage.
La conception de matériel numérique utilisant VHDL est simple, même pour les débutants, mais il y a quelques choses importantes à savoir et un petit ensemble de règles à respecter.</description>
    </item>
    
    <item>
      <title>Types protégés</title>
      <link>https://www.wikiod.com/fr/vhdl/types-proteges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/types-proteges/</guid>
      <description>Avant VHDL 1993, deux processus simultanés ne pouvaient communiquer qu&amp;rsquo;avec des signaux. Grâce à la sémantique de simulation du langage qui ne met à jour les signaux qu&amp;rsquo;entre les étapes de simulation, le résultat d&amp;rsquo;une simulation était déterministe : il ne dépendait pas de l&amp;rsquo;ordre choisi par l&amp;rsquo;ordonnanceur de simulation pour exécuter les processus.
[En fait, ce n&amp;rsquo;est pas vrai à 100%. Les processus peuvent également communiquer à l&amp;rsquo;aide d&amp;rsquo;entrées/sorties de fichiers.</description>
    </item>
    
    <item>
      <title>Attendre</title>
      <link>https://www.wikiod.com/fr/vhdl/attendre/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/attendre/</guid>
      <description>Syntaxe # attendre [sur SIGNAL1[, SIGNAL2[&amp;hellip;]]] [jusqu&amp;rsquo;à CONDITION] [pour TIMEOUT] ; Attendez; &amp;ndash; Attente éternelle attendre s1, s2 ; &amp;ndash; Attendre que les signaux s1 ou s2 (ou les deux) changent attendre que s1 = 15 ; &amp;ndash; Attendre que le signal s1 change et que sa nouvelle valeur soit 15 attendre que s1 = 15 pendant 10 ns ; &amp;ndash; Attendre que le signal s1 change et que sa nouvelle valeur soit 15 pendant au plus 10 ns Attendre la condition # Il est possible d&amp;rsquo;omettre les clauses on &amp;lt;sensitivity_list&amp;gt; et for &amp;lt;timeout&amp;gt;, comme dans :</description>
    </item>
    
    <item>
      <title>Fonctions de résolution, types non résolus et résolus</title>
      <link>https://www.wikiod.com/fr/vhdl/fonctions-de-resolution-types-non-resolus-et-resolus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/fonctions-de-resolution-types-non-resolus-et-resolus/</guid>
      <description>Les types VHDL peuvent être non résolus ou résolus. Le type bit déclaré par le package std.standard, par exemple, n&amp;rsquo;est pas résolu tandis que le type std_logic déclaré par le package ieee.std_logic_1164 est résolu.
Un signal dont le type n&amp;rsquo;est pas résolu ne peut pas être piloté (assigné) par plus d&amp;rsquo;un processus VHDL alors qu&amp;rsquo;un signal dont le type est résolu le peut.
L&amp;rsquo;utilisation de types résolus doit être réservée aux situations où l&amp;rsquo;intention est vraiment de modéliser un fil matériel (ou un ensemble de fils) piloté par plus d&amp;rsquo;un circuit matériel.</description>
    </item>
    
    <item>
      <title>D-Flip-Flops (DFF) et loquets</title>
      <link>https://www.wikiod.com/fr/vhdl/d-flip-flops-dff-et-loquets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/d-flip-flops-dff-et-loquets/</guid>
      <description>Les D-Flip-Flops (DFF) et les verrous sont des éléments de mémoire. Un DFF échantillonne son entrée sur l&amp;rsquo;un ou l&amp;rsquo;autre front de son horloge (pas les deux) tandis qu&amp;rsquo;un verrou est transparent sur un niveau de son activation et mémorisant sur l&amp;rsquo;autre. La figure suivante illustre la différence :
[![DFF vs comportement des verrous][1]][1]
La modélisation des DFF ou des verrous en VHDL est facile, mais il y a quelques aspects importants qui doivent être pris en compte :</description>
    </item>
    
    <item>
      <title>Analyse de synchronisation statique - qu&#39;est-ce que cela signifie lorsqu&#39;une conception échoue dans la synchronisation ?</title>
      <link>https://www.wikiod.com/fr/vhdl/analyse-de-synchronisation-statique---quest-ce-que-cela-signifie-lorsquune-conception-echoue-dans-la-synchronisation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/analyse-de-synchronisation-statique---quest-ce-que-cela-signifie-lorsquune-conception-echoue-dans-la-synchronisation/</guid>
      <description>Qu&amp;rsquo;est-ce que le timing ? # Le concept de synchronisation est davantage lié à la physique des bascules que VHDL, mais il s&amp;rsquo;agit d&amp;rsquo;un concept important que tout concepteur utilisant VHDL pour créer du matériel devrait connaître.
Lors de la conception de matériel numérique, nous créons généralement une logique synchrone. Cela signifie que nos données voyagent de bascule en bascule, éventuellement avec une logique combinatoire entre elles. Le schéma le plus basique de la logique synchrone qui intègre une fonction combinatoire est illustré ci-dessous :[!</description>
    </item>
    
    <item>
      <title>commentaires</title>
      <link>https://www.wikiod.com/fr/vhdl/commentaires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/commentaires/</guid>
      <description>Tout langage de programmation décent prend en charge les commentaires. En VHDL, ils sont particulièrement importants car la compréhension d&amp;rsquo;un code VHDL, même modérément sophistiqué, est souvent difficile.
Commentaires sur une seule ligne # Un commentaire sur une seule ligne commence par deux traits d&amp;rsquo;union (--) et s&amp;rsquo;étend jusqu&amp;rsquo;à la fin de la ligne. Exemple :
-- This process models the state register process(clock, aresetn) begin if aresetn = &#39;0&#39; then -- Active low, asynchronous reset state &amp;lt;= IDLE; elsif rising_edge(clock) then -- Synchronized on the rising edge of the clock state &amp;lt;= next_state; end if; end process; Commentaires délimités # Depuis VHDL 2008, un commentaire peut également s&amp;rsquo;étendre sur plusieurs lignes.</description>
    </item>
    
    <item>
      <title>Souvenirs</title>
      <link>https://www.wikiod.com/fr/vhdl/souvenirs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/souvenirs/</guid>
      <description>Cela couvre les mémoires à port unique et à double port.
Syntaxe # Type de mémoire pour une largeur et une profondeur constantes.
type MEMORY_TYPE is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0); Type de mémoire pour profondeur variable et largeur constante.
type MEMORY_TYPE is array (natural range &amp;lt;&amp;gt;) of std_logic_vector(WIDTH-1 downto 0); Registre à décalage # Un registre à décalage de longueur générique. Avec entrée série et sortie série.</description>
    </item>
    
    <item>
      <title>Littéraux</title>
      <link>https://www.wikiod.com/fr/vhdl/litteraux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/vhdl/litteraux/</guid>
      <description>Cela a comment spécifier des constantes, appelées littéraux en VHDL
Littéraux numériques # 16#A8# -- hex 2#100# -- binary 2#1000_1001_1111_0000 -- long number, adding (optional) _ (one or more) for readability 1234 -- decimal Littéral énuméré # type state_t is (START, READING, WRITING); -- user-defined enumerated type </description>
    </item>
    
  </channel>
</rss>
