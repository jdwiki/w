<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pthreads Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/pthreads/</link>
    <description>Recent content in pthreads Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/pthreads/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec les pthreads</title>
      <link>https://www.wikiod.com/fr/pthreads/premiers-pas-avec-les-pthreads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/pthreads/premiers-pas-avec-les-pthreads/</guid>
      <description>Installation ou configuration # Instructions détaillées sur la configuration ou l&amp;rsquo;installation de pthreads.
&amp;ldquo;Hello World&amp;rdquo; minimal avec des pthreads # #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; /* function to be run as a thread always must have the same signature: it has one void* parameter and returns void */ void *threadfunction(void *arg) { printf(&amp;quot;Hello, World!\n&amp;quot;); /*printf() is specified as thread-safe as of C11*/ return 0; } int main(void) { pthread_t thread; int createerror = pthread_create(&amp;amp;thread, NULL, threadfunction, NULL); /*creates a new thread with default attributes and NULL passed as the argument to the start routine*/ if (!</description>
    </item>
    
    <item>
      <title>Variables conditionnelles</title>
      <link>https://www.wikiod.com/fr/pthreads/variables-conditionnelles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/pthreads/variables-conditionnelles/</guid>
      <description>Les variables conditionnelles sont utiles dans les cas où vous voulez qu&amp;rsquo;un thread attende quelque chose qui se passe dans un autre thread. Par exemple, dans un scénario producteur/consommateur avec un ou plusieurs threads producteurs et un thread consommateur, des variables conditionnelles peuvent être utilisées pour signaler au thread consommateur que de nouvelles données sont disponibles.
Processus général
Une attente sur une variable conditionnelle (queueCond dans l&amp;rsquo;exemple producteur/consommateur) est toujours couplée à un mutex (le queueMutex dans l&amp;rsquo;exemple producteur/consommateur), et doit toujours être couplée à une variable d&amp;rsquo;état &amp;ldquo;normale&amp;rdquo; également (queue.</description>
    </item>
    
    <item>
      <title>Condition de concurrence dans les pthreads</title>
      <link>https://www.wikiod.com/fr/pthreads/condition-de-concurrence-dans-les-pthreads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/pthreads/condition-de-concurrence-dans-les-pthreads/</guid>
      <description>Lors de l&amp;rsquo;écriture d&amp;rsquo;applications multithreads, l&amp;rsquo;un des problèmes les plus courants rencontrés sont les conditions de concurrence. Nous documentons donc le Comment les détectez-vous ? et comment les gérez-vous ?
Exemple : Considérer aura deux threads T1 et T2. # Comment les détectez-vous ?
Si la même variable/ressource/emplacement mémoire est accessible par plusieurs threads et qu&amp;rsquo;au moins l&amp;rsquo;un des threads modifie la valeur de variable/ressource/emplacement mémoire, une condition de concurrence peut se produire.</description>
    </item>
    
  </channel>
</rss>
