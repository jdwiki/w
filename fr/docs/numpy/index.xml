<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel numpy on </title>
    <link>https://www.wikiod.com/fr/docs/numpy/</link>
    <description>Recent content in Tutoriel numpy on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/numpy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Commencer avec numpy</title>
      <link>https://www.wikiod.com/fr/numpy/commencer-avec-numpy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/commencer-avec-numpy/</guid>
      <description>Importation de base # Importez le module numpy pour en utiliser n&amp;rsquo;importe quelle partie.
import numpy as np La plupart des exemples utiliseront np comme raccourci pour numpy. Supposons que &amp;ldquo;np&amp;rdquo; signifie &amp;ldquo;numpy&amp;rdquo; dans les exemples de code.
x = np.array([1,2,3,4]) Installation sous Linux # NumPy est disponible dans les référentiels par défaut des distributions Linux les plus populaires et peut être installé de la même manière que les packages d&amp;rsquo;une distribution Linux sont généralement installés.</description>
    </item>
    
    <item>
      <title>Tableaux</title>
      <link>https://www.wikiod.com/fr/numpy/tableaux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/tableaux/</guid>
      <description>Les tableaux à N dimensions ou ndarrays sont l&amp;rsquo;objet principal de numpy utilisé pour stocker des éléments du même type de données. Ils fournissent une structure de données efficace supérieure aux tableaux Python ordinaires.
Dans la mesure du possible, exprimez les opérations sur les données en termes de tableaux et d&amp;rsquo;opérations vectorielles. Les opérations vectorielles s&amp;rsquo;exécutent beaucoup plus rapidement que les boucles for équivalentes
## Accès à la baie La syntaxe de tranche est i:j:k où i est l&amp;rsquo;index de départ (inclusif), j est l&amp;rsquo;index d&amp;rsquo;arrêt (exclusif) et k est la taille du pas.</description>
    </item>
    
    <item>
      <title>numpy.dot</title>
      <link>https://www.wikiod.com/fr/numpy/numpydot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/numpydot/</guid>
      <description>Syntaxe # numpy.dot(a, b, out=Aucun) Paramètres # Nom Détails un un tableau numpy b un tableau numpy sortie un tableau numpy numpy.dot
Renvoie le produit scalaire de a et b. Si a et b sont tous deux des scalaires ou des tableaux 1-D, alors un scalaire est renvoyé ; sinon un tableau est retourné. Si out est donné, il est renvoyé.
Multiplication matricielle # La multiplication matricielle peut être effectuée de deux manières équivalentes avec la fonction point.</description>
    </item>
    
    <item>
      <title>Génération de données aléatoires</title>
      <link>https://www.wikiod.com/fr/numpy/generation-de-donnees-aleatoires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/generation-de-donnees-aleatoires/</guid>
      <description>Le module &amp;ldquo;aléatoire&amp;rdquo; de NumPy fournit des méthodes pratiques pour générer des données aléatoires ayant la forme et la distribution souhaitées.
Voici la documentation officielle.
Génération de nombres aléatoires tirés de distributions spécifiques # Dessiner des échantillons à partir d&amp;rsquo;une distribution normale (gaussienne)
# Generate 5 random numbers from a standard normal distribution # (mean = 0, standard deviation = 1) np.random.randn(5) # Out: array([-0.84423086, 0.70564081, -0.39878617, -0.82719653, -0.4157447 ]) # This result can also be achieved with the more general np.</description>
    </item>
    
    <item>
      <title>Algèbre linéaire avec np.linalg</title>
      <link>https://www.wikiod.com/fr/numpy/algebre-lineaire-avec-nplinalg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/algebre-lineaire-avec-nplinalg/</guid>
      <description>Depuis la version 1.8, plusieurs des routines de np.linalg peuvent fonctionner sur une &amp;lsquo;pile&amp;rsquo; de matrices. Autrement dit, la routine peut calculer les résultats de plusieurs matrices si elles sont empilées. Par exemple, &amp;lsquo;A&amp;rsquo; ici est interprété comme deux matrices 3 par 3 empilées :
np.random.seed(123) A = np.random.rand(2,3,3) b = np.random.rand(2,3) x = np.linalg.solve(A, b) print np.dot(A[0,:,:], x[0,:]) # array([ 0.53155137, 0.53182759, 0.63440096]) print b[0,:] # array([ 0.53155137, 0.53182759, 0.</description>
    </item>
    
    <item>
      <title>Régression linéaire simple</title>
      <link>https://www.wikiod.com/fr/numpy/regression-lineaire-simple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/regression-lineaire-simple/</guid>
      <description>Ajustement d&amp;rsquo;une ligne (ou d&amp;rsquo;une autre fonction) à un ensemble de points de données.
Utilisation de np.polyfit # Nous créons un ensemble de données que nous adaptons ensuite avec une ligne droite $f(x) = m x + c$.
npoints = 20 slope = 2 offset = 3 x = np.arange(npoints) y = slope * x + offset + np.random.normal(size=npoints) p = np.polyfit(x,y,1) # Last argument is degree of polynomial Pour voir ce que nous avons fait :</description>
    </item>
    
    <item>
      <title>numpy.cross</title>
      <link>https://www.wikiod.com/fr/numpy/numpycross/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/numpycross/</guid>
      <description>Syntaxe # numpy.cross(a, b) # produit croisé de a et b (ou vecteurs dans a et b) numpy.cross(a, b, axisa=-1) #produit croisé de vecteurs dans a avec b, s.t. les vecteurs dans a sont disposés le long de l&amp;rsquo;axe axisa numpy.cross(a, b, axisa=-1, axisb=-1, axisc=-1) # produits croisés de vecteurs dans a et b, vecteurs de sortie disposés le long de l&amp;rsquo;axe spécifié par *axisc * numpy.cross(a, b, axis=None) # produits croisés de vecteurs en a et b, vecteurs en a, b, et en sortie disposés le long de l&amp;rsquo;axe axis Paramètres # Colonne Colonne un,b Dans l&amp;rsquo;utilisation la plus simple, &amp;lsquo;a&amp;rsquo; et &amp;lsquo;b&amp;rsquo; sont deux vecteurs à 2 ou 3 éléments.</description>
    </item>
    
    <item>
      <title>Fichier IO avec numpy</title>
      <link>https://www.wikiod.com/fr/numpy/fichier-io-avec-numpy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/fichier-io-avec-numpy/</guid>
      <description>Chargement de données numériques à partir de fichiers texte avec une structure cohérente # La fonction np.loadtxt peut être utilisée pour lire des fichiers de type csv :
# File: # # Col_1 Col_2 # 1, 1 # 2, 4 # 3, 9 np.loadtxt(&#39;/path/to/dir/csvlike.txt&#39;, delimiter=&#39;,&#39;, comments=&#39;#&#39;) # Output: # array([[ 1., 1.], # [ 2., 4.], # [ 3., 9.]]) Le même fichier peut être lu en utilisant une expression régulière avec np.</description>
    </item>
    
    <item>
      <title>sous-classement ndarray</title>
      <link>https://www.wikiod.com/fr/numpy/sous-classement-ndarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/sous-classement-ndarray/</guid>
      <description>Syntaxe # def __array_prepare__(self, out_arr: ndarray, context: Tuple[ufunc, Tuple, int] = None) -&amp;gt; ndarray: # appelé en chemin vers un ufunc
def __array_wrap__(self, out_arr: ndarray, context: Tuple[ufunc, Tuple, int] = None) -&amp;gt; ndarray: # appelé à la sortie d&#39;un ufunc
__array_priority__: int # utilisé pour déterminer sur quel argument invoquer les méthodes ci-dessus lorsqu&#39;un ufunc est appelé
def __array_finalize__(self, obj: ndarray): # appelé chaque fois qu&#39;une nouvelle instance de cette classe apparaît, même si cela se produit par des routes autres que __new__</description>
    </item>
    
    <item>
      <title>Filtrage des données</title>
      <link>https://www.wikiod.com/fr/numpy/filtrage-des-donnees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/numpy/filtrage-des-donnees/</guid>
      <description>Filtrer les données avec un tableau booléen # Lorsqu&amp;rsquo;un seul argument est fourni à la fonction where de numpy, il renvoie les indices du tableau d&amp;rsquo;entrée (la condition) qui sont évalués comme vrais (même comportement que numpy.nonzero). Cela peut être utilisé pour extraire les indices d&amp;rsquo;un tableau qui satisfont une condition donnée.
import numpy as np a = np.arange(20).reshape(2,10) # a = array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]]) # Generate boolean array indicating which values in a are both greater than 7 and less than 13 condition = np.</description>
    </item>
    
  </channel>
</rss>
