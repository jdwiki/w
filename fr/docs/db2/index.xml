<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel db2 on </title>
    <link>https://www.wikiod.com/fr/docs/db2/</link>
    <description>Recent content in Tutoriel db2 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/db2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec db2</title>
      <link>https://www.wikiod.com/fr/db2/premiers-pas-avec-db2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/premiers-pas-avec-db2/</guid>
      <description>Installation # Il existe différentes versions de DB2. L&amp;rsquo;un d&amp;rsquo;eux est LUW : Linux, UNIX et Windows.
DB2 LUW sous Linux / UNIX peut être installé avec ou sans root. Lorsqu&amp;rsquo;il est installé avec root, vous pouvez créer différentes instances en les associant à différents utilisateurs.
Lors de l&amp;rsquo;installation de DB2 LUW sans privilèges racine, vous pouvez installer DB2 dans votre répertoire personnel et votre utilisateur sera automatiquement la seule instance que cette installation peut avoir.</description>
    </item>
    
    <item>
      <title>Bonjour le monde;</title>
      <link>https://www.wikiod.com/fr/db2/bonjour-le-monde/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/bonjour-le-monde/</guid>
      <description>Création d&amp;rsquo;une base de données dans DB2 # CREATE DATABASE SAMPLEDB; Cela créera une nouvelle base de données appelée sampledb.
Connexion à une base de données dans DB2 # CONNECT TO SAMPLEDB; A partir de la ligne de commande (db2clp, terminal, db2cmd) vous pouvez écrire :
db2 CONNECT TO SAMPLEDB Créez une table dans DB2 appelée &amp;ldquo;employé&amp;rdquo; # L&amp;rsquo;instruction suivante créera une nouvelle table appelée employee :
CREATE TABLE EMPLOYEE ( EMPNO CHAR(6) NOT NULL, FIRSTNME VARCHAR(12) NOT NULL, LASTNAME VARCHAR(15) NOT NULL, SALARY DECIMAL(9,2) , PRIMARY KEY (EMPNO) ) Cela créera une nouvelle table appelée employee.</description>
    </item>
    
    <item>
      <title>Analyser les valeurs séparées par des virgules dans une colonne en plusieurs lignes</title>
      <link>https://www.wikiod.com/fr/db2/analyser-les-valeurs-separees-par-des-virgules-dans-une-colonne-en-plusieurs-lignes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/analyser-les-valeurs-separees-par-des-virgules-dans-une-colonne-en-plusieurs-lignes/</guid>
      <description>Syntaxe # WITH CTE_name (column_name[,&amp;hellip;]) AS ( SELECT nom_colonne[,&amp;hellip;] FROM table_base UNION TOUS SELECT nom_colonne[,&amp;hellip;] FROM nom_CTE WHERE &amp;lt;condition limite de récursivité&amp;gt; ) SELECT nom_colonne[,&amp;hellip;] FROM nom_CTE Requête récursive pour analyser les valeurs séparées par des virgules # Bien que le stockage de plusieurs valeurs dans une seule colonne enfreigne les règles de normalisation, il faut parfois faire face à des tables héritées mal conçues. Une requête récursive peut aider à convertir des valeurs séparées par des virgules en lignes distinctes.</description>
    </item>
    
    <item>
      <title>Où pas dans plusieurs colonnes</title>
      <link>https://www.wikiod.com/fr/db2/ou-pas-dans-plusieurs-colonnes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/ou-pas-dans-plusieurs-colonnes/</guid>
      <description>Filtrer plusieurs combinaisons de valeurs # Supposons que vous souhaitiez filtrer une requête sur deux colonnes, mais uniquement sur certaines combinaisons de ces colonnes. Par exemple, vous pouvez avoir le compte 60400 avec la référence JE, mais vous ne pouvez pas avoir le compte 60400 avec la référence ED, mais vous pouvez avoir le compte 60500 avec la référence ED.
select * from schema.table where (acct, ref) not in ( values (60400, &#39;ED&#39;), (60600, &#39;ED&#39;), (60701, &#39;ED&#39;), (70400, &#39;ED&#39;), (70500, &#39;ED&#39;), (70600, &#39;ED&#39;), (80800, &#39;ED&#39;) ); </description>
    </item>
    
    <item>
      <title>dashDB</title>
      <link>https://www.wikiod.com/fr/db2/dashdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/dashdb/</guid>
      <description>IBM dashDB est une famille de bases de données SQL. Son moteur est un mélange de DB2, Netezza et du [moteur en mémoire BLU][1]. Tout pilote DB2 pris en charge fonctionnera ; c&amp;rsquo;est un remplacement de DB2.
Les 3 gammes de produits pour dashDB sont : (1) IBM dashDB for Transactions : une base de données SQL cloud à usage général entièrement gérée. (2) IBM dashDB for Analytics : un entrepôt de données cloud SQL.</description>
    </item>
    
    <item>
      <title>Insérer dans une table en sélectionnant dans une autre table</title>
      <link>https://www.wikiod.com/fr/db2/inserer-dans-une-table-en-selectionnant-dans-une-autre-table/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/inserer-dans-une-table-en-selectionnant-dans-une-autre-table/</guid>
      <description>Insérer dans une table en sélectionnant dans une autre table # insert into schema.table (field1, field2) select &#39;Static Value&#39;, foreignField from schema.otherTable; </description>
    </item>
    
    <item>
      <title>Combinez plusieurs lignes en une seule valeur séparée par des virgules</title>
      <link>https://www.wikiod.com/fr/db2/combinez-plusieurs-lignes-en-une-seule-valeur-separee-par-des-virgules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/combinez-plusieurs-lignes-en-une-seule-valeur-separee-par-des-virgules/</guid>
      <description>Utilisation de la fonction listagg() # Supposons que vous ayez une table de prêts et une autre table de parcelles associée, où chaque prêt peut être associé à une ou plusieurs parcelles. Si vous souhaitez qu&amp;rsquo;une requête affiche chaque prêt et une liste de toutes ses parcelles associées, mais que vous ne souhaitiez que chaque prêt s&amp;rsquo;affiche une seule fois, vous pouvez utiliser quelque chose comme ceci :
select loan.loannumber, parcel_agg.</description>
    </item>
    
    <item>
      <title>Copier le tableau avec ou sans données</title>
      <link>https://www.wikiod.com/fr/db2/copier-le-tableau-avec-ou-sans-donnees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/copier-le-tableau-avec-ou-sans-donnees/</guid>
      <description>Exemple de copie d&amp;rsquo;une structure de table existante avec/sans données
Syntaxe # CREATE TABLE schemaName.table AS (SELECT colonnes FROM schemaName.table) WITH DATA Copier le tableau avec les données # CREATE TABLE myschema.tableNew AS ( SELECT * FROM myschema.tableOld ) WITH DATA Copier le tableau sans données # CREATE TABLE myschema.tableNew AS ( SELECT * FROM myschema.tableOld ) WITHOUT DATA Copier le tableau avec la clause where # CREATE TABLE myschema.tableNew AS ( SELECT * FROM myschema.</description>
    </item>
    
    <item>
      <title>Informations sur les contraintes DB2</title>
      <link>https://www.wikiod.com/fr/db2/informations-sur-les-contraintes-db2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/informations-sur-les-contraintes-db2/</guid>
      <description>Cette documentation aidera tous ceux qui recherchent toutes les contraintes sur une colonne d&amp;rsquo;une table. La requête peut être modifiée pour trouver la table/les colonnes en fonction du nom de la contrainte.
Obtenir des contraintes basées sur le nom de la colonne # select cst.constraint_schema, cst.constraint_name, fk.table_name, fk.ordinal_position, fk.column_name, pk.table_name, pk.column_name from qsys2.syscst cst join qsys2.syskeycst fk on fk.constraint_schema = cst.constraint_schema and fk.constraint_name = cst.constraint_name join qsys2.sysrefcst ref on ref.constraint_schema = cst.</description>
    </item>
    
    <item>
      <title>Table de dépôt</title>
      <link>https://www.wikiod.com/fr/db2/table-de-depot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/db2/table-de-depot/</guid>
      <description>Instructions de base pour supprimer une table dans DB2.
Syntaxe de base de la table de dépôt # db2 connect to {databaseName} db2 drop table {schema}.{table} db2 connect reset Le schéma n&amp;rsquo;est pas nécessaire s&amp;rsquo;il correspond au nom d&amp;rsquo;utilisateur actuel. Le préfixe &amp;ldquo;db2&amp;rdquo; n&amp;rsquo;est pas nécessaire si vous êtes déjà dans une invite de commande DB2.</description>
    </item>
    
  </channel>
</rss>
