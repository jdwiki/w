<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel de programmation dynamique on </title>
    <link>https://www.wikiod.com/fr/docs/dynamic-programming/</link>
    <description>Recent content in Tutoriel de programmation dynamique on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec la programmation dynamique</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/debuter-avec-la-programmation-dynamique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/debuter-avec-la-programmation-dynamique/</guid>
      <description>Introduction à la programmation dynamique # La programmation dynamique résout les problèmes en combinant les solutions aux sous-problèmes. Cela peut être analogue à la méthode diviser pour mieux régner, où le problème est divisé en sous-problèmes disjoints, les sous-problèmes sont résolus de manière récursive puis combinés pour trouver la solution du problème d&amp;rsquo;origine. En revanche, la programmation dynamique s&amp;rsquo;applique lorsque les sous-problèmes se chevauchent, c&amp;rsquo;est-à-dire lorsque les sous-problèmes partagent des sous-sous-problèmes.</description>
    </item>
    
    <item>
      <title>Problème de changement de pièces</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/probleme-de-changement-de-pieces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/probleme-de-changement-de-pieces/</guid>
      <description>Nombre de façons d&amp;rsquo;obtenir le total # Étant donné des pièces de différentes dénominations et un total, de combien de façons pouvons-nous combiner ces pièces pour obtenir le total ? Disons que nous avons coins = {1, 2, 3} et un total = 5, nous pouvons obtenir le total de 5 manières :
1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 2 3 Le problème est étroitement lié au problème du sac à dos.</description>
    </item>
    
    <item>
      <title>Résolution de problèmes de graphe à l&#39;aide de la programmation dynamique</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/resolution-de-problemes-de-graphe-a-laide-de-la-programmation-dynamique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/resolution-de-problemes-de-graphe-a-laide-de-la-programmation-dynamique/</guid>
      <description>Algorithme Floyd-Warshall # Couverture minimale des sommets # [Minimum Vertex Cover] (https://en.wikipedia.org/wiki/Vertex_cover) est un problème de graphe classique. Disons que dans une ville, nous avons quelques routes reliant quelques points. Représentons les routes à l&amp;rsquo;aide de bords et les points à l&amp;rsquo;aide de nœuds. Prenons deux exemples de graphiques :
[![Exemple de graphique, A-B, B-C, A-C, A-E, A-D, A-F, G-I, G-H, H-I, I-J, J-L, J-K, K-H][1]][1]
Nous voulons mettre des veilleurs sur certains points.</description>
    </item>
    
    <item>
      <title>Sélection d&#39;activité pondérée</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/selection-dactivite-ponderee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/selection-dactivite-ponderee/</guid>
      <description>Algorithme de planification pondérée des tâches # L&amp;rsquo;algorithme de planification pondérée des tâches peut également être appelé algorithme de sélection d&amp;rsquo;activité pondérée.
Le problème est que, étant donné certains travaux avec leur heure de début et leur heure de fin, et un profit que vous réalisez lorsque vous terminez le travail, quel est le profit maximum que vous pouvez réaliser étant donné que deux travaux ne peuvent pas être exécutés en parallèle ?</description>
    </item>
    
    <item>
      <title>Problème de sac à dos</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/probleme-de-sac-a-dos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/probleme-de-sac-a-dos/</guid>
      <description>Le problème du sac à dos ou du sac à dos est un problème d&amp;rsquo;optimisation combinatoire. Étant donné un ensemble d&amp;rsquo;éléments, chacun avec un poids et une valeur, déterminez le nombre de chaque élément à inclure dans une collection de sorte que le poids total soit inférieur ou égal à une limite donnée et que la valeur totale soit aussi grande que possible. Il tire son nom du problème rencontré par quelqu&amp;rsquo;un qui est contraint par un sac à dos de taille fixe et doit le remplir avec les objets les plus précieux.</description>
    </item>
    
    <item>
      <title>Algorithmes liés aux sous-séquences</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/algorithmes-lies-aux-sous-sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/algorithmes-lies-aux-sous-sequences/</guid>
      <description>Sous-séquence croissante la plus longue # La tâche consiste à trouver la longueur de la plus longue sous-séquence dans un tableau donné d&amp;rsquo;entiers de sorte que tous les éléments de la sous-séquence soient triés par ordre croissant. Par exemple, la longueur de la plus longue sous-séquence croissante (LIS) pour {15, 27, 14, 38, 26, 55, 46, 65, 85} est 6 et la plus longue sous-séquence croissante est * *{15, 27, 38, 55, 65, 85}**.</description>
    </item>
    
    <item>
      <title>Déformation temporelle dynamique</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/deformation-temporelle-dynamique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/deformation-temporelle-dynamique/</guid>
      <description>Introduction à la déformation temporelle dynamique # Dynamic Time Warping(DTW) est un algorithme permettant de mesurer la similarité entre deux séquences temporelles dont la vitesse peut varier. Par exemple, des similitudes dans la marche pourraient être détectées à l&amp;rsquo;aide de DTW, même si une personne marchait plus vite que l&amp;rsquo;autre, ou s&amp;rsquo;il y avait des accélérations et des décélérations au cours d&amp;rsquo;une observation. Il peut être utilisé pour faire correspondre un exemple de commande vocale avec d&amp;rsquo;autres commandes, même si la personne parle plus vite ou plus lentement que l&amp;rsquo;échantillon de voix préenregistré.</description>
    </item>
    
    <item>
      <title>Multiplication de chaîne matricielle</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/multiplication-de-chaine-matricielle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/multiplication-de-chaine-matricielle/</guid>
      <description>Solution récursive # Multiplication de chaîne matricielle est un problème d&amp;rsquo;optimisation qui peut être résolu à l&amp;rsquo;aide de la programmation dynamique. Étant donné une séquence de matrices, le but est de trouver la manière la plus efficace de multiplier ces matrices. Le problème n&amp;rsquo;est pas réellement d&amp;rsquo;effectuer les multiplications, mais simplement de décider de la séquence des multiplications matricielles impliquées.
Disons que nous avons deux matrices A1 et A2 de dimension m * n et p * q .</description>
    </item>
    
    <item>
      <title>Coupe de tige</title>
      <link>https://www.wikiod.com/fr/dynamic-programming/coupe-de-tige/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dynamic-programming/coupe-de-tige/</guid>
      <description>Couper la tige pour obtenir le maximum de profit # Étant donné une réglette de longueur n pouces et un tableau de longueur m de prix contenant les prix de toutes les pièces de taille inférieure à n. Il faut trouver la valeur maximale que l&amp;rsquo;on peut obtenir en découpant la tige et en vendant les morceaux. Par exemple, si la longueur de la tige est 8 et que les valeurs des différentes pièces sont données comme suit, alors la valeur maximale pouvant être obtenue est 22.</description>
    </item>
    
  </channel>
</rss>
