<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel de printemps on </title>
    <link>https://www.wikiod.com/fr/docs/spring/</link>
    <description>Recent content in Tutoriel de printemps on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec le printemps</title>
      <link>https://www.wikiod.com/fr/spring/debuter-avec-le-printemps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/debuter-avec-le-printemps/</guid>
      <description>Configuration (Configuration XML) # Étapes pour créer Hello Spring :
Enquêtez sur [Spring Boot] (https://www.wikiod.com/fr/spring-boot) pour voir si cela répondrait mieux à vos besoins. Avoir un projet configuré avec les bonnes dépendances. Il est recommandé d&amp;rsquo;utiliser Maven ou Gradle. créer une classe POJO, par ex. Employé.java créez un fichier XML dans lequel vous pouvez définir votre classe et vos variables. par exemple beans.xml créez votre classe principale, par ex. Client.java Incluez spring-beans (et ses dépendances transitives !</description>
    </item>
    
    <item>
      <title>Champs d&#39;application de haricot</title>
      <link>https://www.wikiod.com/fr/spring/champs-dapplication-de-haricot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/champs-dapplication-de-haricot/</guid>
      <description>Champs d&amp;rsquo;application supplémentaires dans les contextes Web # Plusieurs étendues sont disponibles uniquement dans un contexte d&amp;rsquo;application compatible Web :
request - une nouvelle instance de bean est créée par requête HTTP session - une nouvelle instance de bean est créée par session HTTP application - une nouvelle instance de bean est créée par ServletContext globalSession - une nouvelle instance de bean est créée par session globale dans l&amp;rsquo;environnement de portlet (dans l&amp;rsquo;environnement de servlet, la portée de session globale est égale à la portée de session) websocket - une nouvelle instance de bean est créée par session WebSocket Aucune configuration supplémentaire n&amp;rsquo;est requise pour déclarer et accéder aux beans de portée Web dans l&amp;rsquo;environnement Spring Web MVC.</description>
    </item>
    
    <item>
      <title>Créer et utiliser des beans</title>
      <link>https://www.wikiod.com/fr/spring/creer-et-utiliser-des-beans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/creer-et-utiliser-des-beans/</guid>
      <description>Câblage automatique de tous les beans d&amp;rsquo;un type spécifique # Si vous avez plusieurs implémentations de la même interface, Spring peut toutes les connecter automatiquement dans un objet de collection. Je vais utiliser un exemple utilisant un modèle Validator1
Foo classe:
public class Foo { private String name; private String emailAddress; private String errorMessage; /** Getters &amp;amp; Setters omitted **/ } Interface:
public interface FooValidator { public Foo validate(Foo foo); } Classe de validateur de nom :</description>
    </item>
    
    <item>
      <title>Configuration du contexte d&#39;application</title>
      <link>https://www.wikiod.com/fr/spring/configuration-du-contexte-dapplication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/configuration-du-contexte-dapplication/</guid>
      <description>Spring a fait en sorte que la configuration d&amp;rsquo;un ApplicationContext soit extrêmement flexible. Il existe de nombreuses façons d&amp;rsquo;appliquer chaque type de configuration, et elles peuvent toutes être mélangées et assorties de manière agréable.
La configuration Java est une forme de configuration explicite. Une classe annotée @Configuration est utilisée pour spécifier les beans qui feront partie de ApplicationContext, ainsi que pour définir et câbler les dépendances de chaque bean.
La configuration XML est une forme de configuration explicite.</description>
    </item>
    
    <item>
      <title>Noyau de ressort</title>
      <link>https://www.wikiod.com/fr/spring/noyau-de-ressort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/noyau-de-ressort/</guid>
      <description>Introduction à Spring Core # Spring est un vaste framework, donc le framework Spring a été divisé en plusieurs modules, ce qui rend le printemps léger. Certains modules importants sont :
Noyau de ressort AOP de printemps Printemps JDBC Transaction de printemps ORM du printemps Printemps MVC Tous les modules de Spring sont indépendants les uns des autres sauf Spring Core. Comme Spring core est le module de base, donc dans tous les modules, nous devons utiliser Spring Core</description>
    </item>
    
    <item>
      <title>Exécution et planification des tâches</title>
      <link>https://www.wikiod.com/fr/spring/execution-et-planification-des-taches/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/execution-et-planification-des-taches/</guid>
      <description>Expression cron # Une expression Cron se compose de six champs séquentiels -
second, minute, hour, day of month, month, day(s) of week et est déclaré comme suit
@Scheduled(cron = &amp;quot;* * * * * *&amp;quot;) Nous pouvons également définir le [fuseau horaire] [1] comme -
@Scheduled(cron=&amp;quot;* * * * * *&amp;quot;, zone=&amp;quot;Europe/Istanbul&amp;quot;) Remarques: -
syntax means example explanation ------------------------------------------------------------------------------------ * match any &amp;quot;* * * * * *&amp;quot; do always */x every x &amp;quot;*/5 * * * * *&amp;quot; do every five seconds ?</description>
    </item>
    
    <item>
      <title>Enregistrement conditionnel du haricot au printemps</title>
      <link>https://www.wikiod.com/fr/spring/enregistrement-conditionnel-du-haricot-au-printemps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/enregistrement-conditionnel-du-haricot-au-printemps/</guid>
      <description>Point important à noter lors de l&amp;rsquo;utilisation de la condition
La classe de condition est référencée en tant que classe directe (et non en tant que haricot de printemps), elle ne peut donc ** pas ** utiliser l&amp;rsquo;injection de propriété @Value, c&amp;rsquo;est-à-dire qu&amp;rsquo;aucun autre haricot de printemps ne peut y être injecté. À partir de la documentation Java - Les conditions doivent suivre les mêmes restrictions que BeanFactoryPostProcessor et veiller à ne jamais interagir avec les instances de bean.</description>
    </item>
    
    <item>
      <title>Injection de dépendance (DI) et inversion de contrôle (IoC)</title>
      <link>https://www.wikiod.com/fr/spring/injection-de-dependance-di-et-inversion-de-controle-ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/injection-de-dependance-di-et-inversion-de-controle-ioc/</guid>
      <description>Le code source des grandes applications logicielles est généralement organisé en plusieurs unités. La définition d&amp;rsquo;une unité varie normalement selon le langage de programmation utilisé. Par exemple, le code écrit dans un langage de programmation procédural (comme C) est organisé en &amp;ldquo;fonctions&amp;rdquo; ou &amp;ldquo;procédures&amp;rdquo;. De même, le code d&amp;rsquo;un langage de programmation orienté objet (comme Java, Scala et C#) est organisé en &amp;ldquo;classes&amp;rdquo;, &amp;ldquo;interfaces&amp;rdquo;, etc. Ces unités d&amp;rsquo;organisation de code peuvent être considérées comme des unités individuelles constituant l&amp;rsquo;application logicielle globale.</description>
    </item>
    
    <item>
      <title>RestTemplate</title>
      <link>https://www.wikiod.com/fr/spring/resttemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/resttemplate/</guid>
      <description>Téléchargement d&amp;rsquo;un gros fichier # Les méthodes getForObject et getForEntity de RestTemplate chargent la réponse entière en mémoire. Cela ne convient pas au téléchargement de fichiers volumineux car cela peut entraîner des exceptions de mémoire insuffisante. Cet exemple montre comment diffuser la réponse d&amp;rsquo;une requête GET.
RestTemplate restTemplate // = ...; // Optional Accept header RequestCallback requestCallback = request -&amp;gt; request.getHeaders() .setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL)); // Streams the response instead of loading it all in memory ResponseExtractor&amp;lt;Void&amp;gt; responseExtractor = response -&amp;gt; { // Here I write the response to a file but do what you like Path path = Paths.</description>
    </item>
    
    <item>
      <title>JdbcTemplate</title>
      <link>https://www.wikiod.com/fr/spring/jdbctemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/spring/jdbctemplate/</guid>
      <description>La classe JdbcTemplate exécute des requêtes SQL, des instructions de mise à jour et des appels de procédure stockée, effectue une itération sur les ResultSets et l&amp;rsquo;extraction des valeurs de paramètre renvoyées. Il intercepte également les exceptions JDBC et les traduit dans la hiérarchie d&amp;rsquo;exception générique, plus informative, définie dans le package org.springframework.dao.
Les instances de la classe JdbcTemplate sont thread-safe une fois configurées afin de pouvoir injecter en toute sécurité cette référence partagée dans plusieurs DAO.</description>
    </item>
    
  </channel>
</rss>
