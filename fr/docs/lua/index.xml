<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel Lua on </title>
    <link>https://www.wikiod.com/fr/docs/lua/</link>
    <description>Recent content in Tutoriel Lua on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/lua/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec Lua</title>
      <link>https://www.wikiod.com/fr/lua/debuter-avec-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/debuter-avec-lua/</guid>
      <description>Commentaires # Les commentaires sur une seule ligne en Lua commencent par -- et continuent jusqu&amp;rsquo;à la fin de la ligne :
-- this is single line comment -- need another line -- huh? Les commentaires de bloc commencent par --[[ et se terminent par ]] :
--[[ This is block comment. So, it can go on... and on... and on.... ]] Les commentaires de bloc utilisent le même style de délimiteurs que les chaînes longues ; n&amp;rsquo;importe quel nombre de signes égal peut être ajouté entre les parenthèses pour délimiter un commentaire :</description>
    </item>
    
    <item>
      <title>Correspondance de modèle</title>
      <link>https://www.wikiod.com/fr/lua/correspondance-de-modele/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/correspondance-de-modele/</guid>
      <description>Syntaxe # string.find(str, pattern [, init [, plain]]) &amp;ndash; Renvoie l&amp;rsquo;index de début et de fin de la correspondance dans str
string.match(str, pattern [, index]) &amp;ndash; Correspond à un modèle une fois (en commençant à l&amp;rsquo;index)
string.gmatch(str, pattern) &amp;ndash; Renvoie une fonction qui parcourt toutes les correspondances dans str
string.gsub(str, pattern, repl [, n]) &amp;ndash; Remplace les sous-chaînes (jusqu&amp;rsquo;à un maximum de n fois)
. représente tous les caractères
%a représente toutes les lettres</description>
    </item>
    
    <item>
      <title>Ensembles</title>
      <link>https://www.wikiod.com/fr/lua/ensembles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/ensembles/</guid>
      <description>Utilisation d&amp;rsquo;un tableau comme ensemble # Créer un ensemble # local set = {} -- empty set Créez un ensemble avec des éléments en définissant leur valeur sur &amp;ldquo;true&amp;rdquo; :
local set = {pear=true, plum=true} -- or initialize by adding the value of a variable: local fruit = &#39;orange&#39; local other_set = {[fruit] = true} -- adds &#39;orange&#39; Ajouter un membre à l&amp;rsquo;ensemble # ajouter un membre en définissant sa valeur sur &amp;ldquo;true&amp;rdquo;</description>
    </item>
    
    <item>
      <title>les tables</title>
      <link>https://www.wikiod.com/fr/lua/les-tables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/les-tables/</guid>
      <description>Syntaxe # ipairs(numeric_table) &amp;ndash; Table Lua avec itérateur d&amp;rsquo;indices numériques pairs(input_table) &amp;ndash; itérateur de table Lua générique key, value = next(input_table, input_key) &amp;ndash; Sélecteur de valeur de table Lua table.insert(input_table, [position], value) &amp;ndash; insère la valeur spécifiée dans la table d&amp;rsquo;entrée remove_value = table.remove(input_table, [position]) &amp;ndash; pop dernière ou supprimer la valeur spécifiée par la position Les tables sont la seule structure de données intégrée disponible dans Lua. C&amp;rsquo;est soit une simplicité élégante, soit une confusion, selon la façon dont vous le regardez.</description>
    </item>
    
    <item>
      <title>Booléens en Lua</title>
      <link>https://www.wikiod.com/fr/lua/booleens-en-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/booleens-en-lua/</guid>
      <description>Les booléens, la vérité et la fausseté sont simples en Lua. Réviser:
Il existe un type booléen avec exactement deux valeurs : &amp;ldquo;true&amp;rdquo; et &amp;ldquo;false&amp;rdquo;. Dans un contexte conditionnel (if, elseif, while, until), un booléen n&amp;rsquo;est pas nécessaire. N&amp;rsquo;importe quelle expression peut être utilisée. Dans un contexte conditionnel, &amp;ldquo;faux&amp;rdquo; et &amp;ldquo;nil&amp;rdquo; comptent comme faux, et tout le reste compte comme vrai. Bien que 3 implique déjà ceci : si vous venez d&amp;rsquo;autres langages, rappelez-vous que 0 et la chaîne vide comptent comme vrai dans les contextes conditionnels en Lua.</description>
    </item>
    
    <item>
      <title>Les fonctions</title>
      <link>https://www.wikiod.com/fr/lua/les-fonctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/les-fonctions/</guid>
      <description>Syntaxe # funcname = function(paramA, paramB, &amp;hellip;) corps ; return exprlist end &amp;ndash; une fonction simple fonction nomfonc(paramA, paramB, &amp;hellip;) corps ; return exprlist end &amp;ndash; raccourci pour ci-dessus local funcname = function(paramA, paramB, &amp;hellip;) body ; return exprlist end &amp;ndash; un lambda local nomfonction ; nomfonc = function(paramA, paramB, &amp;hellip;) corps ; return exprlist end &amp;ndash; lambda qui peut faire des appels récursifs fonction locale nomfonc(paramA, paramB, &amp;hellip;) corps ; return exprlist end &amp;ndash; raccourci pour ci-dessus funcname(paramA, paramB, &amp;hellip;) &amp;ndash; appelle une fonction local var = var ou &amp;ldquo;Default&amp;rdquo; &amp;ndash; un paramètre par défaut renvoie nil, &amp;ldquo;messages d&amp;rsquo;erreur&amp;rdquo; &amp;ndash; manière standard d&amp;rsquo;abandonner avec une erreur Les fonctions sont généralement définies avec function a(b,c) .</description>
    </item>
    
    <item>
      <title>La gestion des erreurs</title>
      <link>https://www.wikiod.com/fr/lua/la-gestion-des-erreurs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/la-gestion-des-erreurs/</guid>
      <description>Gestion des erreurs en Lua # En supposant que nous ayons la fonction suivante :
function foo(tab) return tab.a end -- Script execution errors out w/ a stacktrace when tab is not a table Améliorons-le un peu
function foo(tab) if type(tab) ~= &amp;quot;table&amp;quot; then error(&amp;quot;Argument 1 is not a table!&amp;quot;, 2) end return tab.a end -- This gives us more information, but script will still error out Si nous ne voulons pas qu&amp;rsquo;une fonction plante un programme même en cas d&amp;rsquo;erreur, il est standard dans lua de faire ce qui suit :</description>
    </item>
    
    <item>
      <title>Présentation de l&#39;API Lua C</title>
      <link>https://www.wikiod.com/fr/lua/presentation-de-lapi-lua-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/presentation-de-lapi-lua-c/</guid>
      <description>Syntaxe # lua_State *L = lua_open(); // Crée un nouvel état de VM ; Lua 5.0 two_State *L = twoL_newstate(); // Crée un nouvel état de VM ; Deux 5.1+ int luaL_dofile(lua_State *L, const char *filename); // Exécute un script lua avec le filename donné en utilisant le lua_State spécifié annuler luaL_openlibs(lua_State *L); // Charge toutes les bibliothèques standard dans le lua_State spécifié annuler lua_close(lua_State *L); // Ferme l&amp;rsquo;état de la VM et libère toutes les ressources à l&amp;rsquo;intérieur void lua_call(lua_State *L, int nargs, int nresults); // Appelle la luavalue à l&amp;rsquo;index -(nargs + 1) Lua fournit également une API C appropriée à sa machine virtuelle.</description>
    </item>
    
    <item>
      <title>Métatables</title>
      <link>https://www.wikiod.com/fr/lua/metatables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/metatables/</guid>
      <description>Syntaxe # [[local] mt = ]getmetatable(t) &amp;ndash;&amp;gt; récupérer la métatable associée pour &amp;lsquo;t&amp;rsquo; [[local] t = ]setmetatable(t, mt) &amp;ndash;&amp;gt; définit la métatable pour &amp;lsquo;t&amp;rsquo; sur &amp;lsquo;mt&amp;rsquo; et renvoie &amp;lsquo;t&amp;rsquo; Paramètres # Paramètre Détails t Variable faisant référence à une table lua ; peut également être un littéral de table. mt Table à utiliser comme métatable ; peut avoir zéro ou plusieurs champs de métaméthode définis. Certaines métaméthodes ne sont pas mentionnées ici.</description>
    </item>
    
    <item>
      <title>Arguments variadiques</title>
      <link>https://www.wikiod.com/fr/lua/arguments-variadiques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/lua/arguments-variadiques/</guid>
      <description>Varargs, comme on les appelle couramment, permet aux fonctions de prendre un nombre arbitraire d&amp;rsquo;arguments sans spécification. Tous les arguments donnés à une telle fonction sont regroupés dans une seule structure connue sous le nom de vararg list ; qui s&amp;rsquo;écrit ... en Lua. Il existe des méthodes de base pour extraire le nombre d&amp;rsquo;arguments donnés et la valeur de ces arguments à l&amp;rsquo;aide de la fonction select(), mais des modèles d&amp;rsquo;utilisation plus avancés peuvent exploiter pleinement la structure.</description>
    </item>
    
  </channel>
</rss>
