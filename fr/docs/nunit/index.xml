<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nunite Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/nunit/</link>
    <description>Recent content in nunite Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/nunit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Démarrer avec nunit</title>
      <link>https://www.wikiod.com/fr/nunit/demarrer-avec-nunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/nunit/demarrer-avec-nunit/</guid>
      <description>Pourquoi vous ne pouvez pas utiliser Assert.Equals # Vous êtes-vous déjà demandé pourquoi vous ne pouvez pas utiliser Assert.Equals() pour Nunit et MSTest. Si ce n&amp;rsquo;est pas le cas, vous devez peut-être commencer par savoir que vous ne pouvez pas utiliser cette méthode. Au lieu de cela, vous utiliseriez Assert.AreEqual() pour comparer deux objets pour l&amp;rsquo;égalité.
La raison ici est très simple. Comme toute classe, la classe Assert hérite de System.</description>
    </item>
    
    <item>
      <title>Écrire une contrainte personnalisée pour le modèle de contrainte</title>
      <link>https://www.wikiod.com/fr/nunit/ecrire-une-contrainte-personnalisee-pour-le-modele-de-contrainte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/nunit/ecrire-une-contrainte-personnalisee-pour-le-modele-de-contrainte/</guid>
      <description>Correspond approximativement à un entier # Supposons que nous voulions écrire une contrainte qui corresponde à un nombre, mais approximativement. Disons que vous êtes censé avoir &amp;lsquo;95&amp;rsquo; personnes dans une enquête, mais &amp;lsquo;93&amp;rsquo; ou &amp;lsquo;96&amp;rsquo; suffiront également. Nous pouvons écrire une contrainte personnalisée de la forme :
public class AlmostEqualToConstraint : Constraint { readonly int _expected; readonly double _expectedMin; readonly double _expectedMax; readonly int _percentageTolerance; public AlmostEqualToConstraint(int expected, int percentageTolerance) { _expected = expected; _expectedMin = expected * (1 - (double)percentageTolerance / 100); _expectedMax = expected * (1 + (double)percentageTolerance / 100); _percentageTolerance = percentageTolerance; Description = $&amp;quot;AlmostEqualTo {expected} with a tolerance of {percentageTolerance}%&amp;quot;; } public override ConstraintResult ApplyTo&amp;lt;TActual&amp;gt;(TActual actual) { if (typeof(TActual) !</description>
    </item>
    
    <item>
      <title>Assertions fluides</title>
      <link>https://www.wikiod.com/fr/nunit/assertions-fluides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/nunit/assertions-fluides/</guid>
      <description>Le formulaire Assert.That() de NUnit prend en charge l&amp;rsquo;utilisation de contraintes comme deuxième paramètre. Toutes les contraintes fournies par NUnit sont disponibles via les classes statiques Is, Has et Does. Les contraintes peuvent être combinées dans des expressions fluides à l&amp;rsquo;aide des méthodes intégrées And, Or et With. Les expressions peuvent être facilement étendues à l&amp;rsquo;aide des nombreuses méthodes de ConstraintExpression, telles que AtMost et Contains.
Utilisation avancée des contraintes # Les grandes assertions fluides deviennent plus difficiles à lire, mais lorsqu&amp;rsquo;elles sont combinées avec des classes qui ont de bonnes implémentations de ToString(), elles peuvent générer des messages d&amp;rsquo;erreur très utiles.</description>
    </item>
    
    <item>
      <title>Exécution et cycle de vie des tests</title>
      <link>https://www.wikiod.com/fr/nunit/execution-et-cycle-de-vie-des-tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/nunit/execution-et-cycle-de-vie-des-tests/</guid>
      <description>Exécution des tests dans un ordre donné # Normalement, vos tests doivent être créés de manière à ce que l&amp;rsquo;ordre d&amp;rsquo;exécution ne soit pas un problème. Cependant, il y aura toujours un cas limite où vous devrez enfreindre cette règle.
Le seul scénario que j&amp;rsquo;ai rencontré était avec R.NET dans lequel, dans un processus donné, vous ne pouvez initialiser qu&amp;rsquo;un seul moteur R et une fois éliminé, vous ne pouvez pas réinitialiser.</description>
    </item>
    
    <item>
      <title>Les attributs</title>
      <link>https://www.wikiod.com/fr/nunit/les-attributs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/nunit/les-attributs/</guid>
      <description>La version 1 de NUnit utilisait l&amp;rsquo;approche classique d&amp;rsquo;identification des tests basée sur l&amp;rsquo;héritage et les conventions de dénomination. Depuis la version 2.0, NUnit a utilisé des attributs personnalisés à cette fin.
Étant donné que les appareils de test NUnit n&amp;rsquo;héritent pas d&amp;rsquo;une classe de framework, le développeur est libre d&amp;rsquo;utiliser l&amp;rsquo;héritage d&amp;rsquo;autres manières. Et parce qu&amp;rsquo;il n&amp;rsquo;y a pas de convention arbitraire pour nommer les tests, le choix des noms peut être entièrement orienté vers la communication de l&amp;rsquo;objectif du test.</description>
    </item>
    
  </channel>
</rss>
