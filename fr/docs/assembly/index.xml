<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel sur le langage d&#39;assemblage on </title>
    <link>https://www.wikiod.com/fr/docs/assembly/</link>
    <description>Recent content in Tutoriel sur le langage d&#39;assemblage on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec le langage d&#39;assemblage</title>
      <link>https://www.wikiod.com/fr/assembly/premiers-pas-avec-le-langage-dassemblage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/premiers-pas-avec-le-langage-dassemblage/</guid>
      <description>Introduction # Le langage d&amp;rsquo;assemblage est une forme lisible par l&amp;rsquo;homme du langage machine ou du code machine qui est la séquence réelle de bits et d&amp;rsquo;octets sur laquelle la logique du processeur fonctionne. Il est généralement plus facile pour les humains de lire et de programmer en mnémoniques que binaire, octal ou hexadécimal, de sorte que les humains écrivent généralement du code en langage d&amp;rsquo;assemblage, puis utilisent un ou plusieurs programmes pour le convertir dans le format de langage machine compris par le processeur.</description>
    </item>
    
    <item>
      <title>Registres</title>
      <link>https://www.wikiod.com/fr/assembly/registres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/registres/</guid>
      <description>Que sont les registres ?
Le processeur peut fonctionner sur des valeurs numériques (nombres), mais celles-ci doivent d&amp;rsquo;abord être stockées quelque part. Les données sont stockées principalement en mémoire, ou à l&amp;rsquo;intérieur de l&amp;rsquo;opcode d&amp;rsquo;instruction (qui est généralement stocké également en mémoire), ou dans une mémoire spéciale sur puce placée directement dans le processeur, appelée registre.
Pour travailler avec la valeur dans le registre, vous n&amp;rsquo;avez pas besoin de l&amp;rsquo;adresser par adresse, mais des &amp;ldquo;noms&amp;rdquo; mnémoniques spéciaux sont utilisés, comme par exemple ax sur x86, ou A sur Z80, ou r0 sur ARM.</description>
    </item>
    
    <item>
      <title>La pile</title>
      <link>https://www.wikiod.com/fr/assembly/la-pile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/la-pile/</guid>
      <description>La pile d&amp;rsquo;ordinateurs est comme une pile de livres. PUSH en ajoute un en haut et POP enlève le plus haut. Comme dans la vraie vie, la pile ne peut pas être sans fin, elle a donc une taille maximale. La pile peut être utilisée pour trier des algorithmes, pour gérer une plus grande quantité de données ou pour sécuriser les valeurs des registres tout en effectuant une autre opération.</description>
    </item>
    
    <item>
      <title>Exemples Linux elf64 n&#39;utilisant pas la glibc</title>
      <link>https://www.wikiod.com/fr/assembly/exemples-linux-elf64-nutilisant-pas-la-glibc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/exemples-linux-elf64-nutilisant-pas-la-glibc/</guid>
      <description>Interface utilisateur # J&amp;rsquo;oserais dire que 80% du traitement qui se déroule dans les systèmes informatiques modernes ne nécessite pas d&amp;rsquo;interaction de l&amp;rsquo;utilisateur, comme le code du noyau pour Linux, OSX et Windows. Pour ceux qui le font, il y a deux fondamentaux qui sont l&amp;rsquo;interactivité via le clavier (dispositifs de pointage) et la console. Cet exemple et d&amp;rsquo;autres de ma série sont orientés autour de la console basée sur le texte (émulation VT100) et du clavier.</description>
    </item>
    
    <item>
      <title>Contrôle de flux</title>
      <link>https://www.wikiod.com/fr/assembly/controle-de-flux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/controle-de-flux/</guid>
      <description>Chaque morceau de logiciel non trivial a besoin de structures de contrôle de flux pour détourner le flux du programme en fonction des conditions.
L&amp;rsquo;assemblage étant le langage de programmation de niveau le plus bas, ne fournit que des primitives pour les structures de contrôle. En règle générale, les opérations de la machine affectent les flags dans le CPU et les branches/sauts conditionnels implémentent le contrôle de flux. En assemblage, toutes les structures de contrôle de niveau supérieur doivent être construites à partir de telles primitives.</description>
    </item>
    
    <item>
      <title>Interruptions</title>
      <link>https://www.wikiod.com/fr/assembly/interruptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/assembly/interruptions/</guid>
      <description>Pourquoi avons-nous besoin d&amp;rsquo;interruptions
Imaginons : Notre ordinateur est connecté à un clavier. Nous voulons entrer quelque chose. Lorsque nous appuyons sur la touche, rien ne se passe parce que l&amp;rsquo;ordinateur traite différentes choses et ne remarque pas que nous voulons quelque chose de lui. Nous avons besoin d&amp;rsquo;interruptions !
Les interruptions sont déclenchées par un logiciel (INT 80h) ou un matériel (pression de touche), elles se comportent comme un Call (elles sautent à un emplacement spécifique, exécutent du code et sautent à nouveau).</description>
    </item>
    
  </channel>
</rss>
