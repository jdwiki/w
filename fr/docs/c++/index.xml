<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel C&#43;&#43; on </title>
    <link>https://www.wikiod.com/fr/docs/c&#43;&#43;/</link>
    <description>Recent content in Tutoriel C&#43;&#43; on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec C&#43;&#43;</title>
      <link>https://www.wikiod.com/fr/c-/debuter-avec-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/debuter-avec-c-/</guid>
      <description>Bonjour le monde # Ce programme affiche &amp;ldquo;Hello World !&amp;rdquo; dans le flux de sortie standard :
#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; } A voir en direct sur Coliru.
Une analyse # Examinons chaque partie de ce code en détail :
#include &amp;lt;iostream&amp;gt; est une directive de préprocesseur qui inclut le contenu du fichier d&amp;rsquo;en-tête C++ standard iostream.
iostream is a standard library header file that contains definitions of the standard input and output streams.</description>
    </item>
    
    <item>
      <title>vecteurstd</title>
      <link>https://www.wikiod.com/fr/c-/vecteurstd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/vecteurstd/</guid>
      <description>Un vecteur est un tableau dynamique avec un stockage géré automatiquement. Les éléments d&amp;rsquo;un vecteur sont accessibles aussi efficacement que ceux d&amp;rsquo;un tableau, l&amp;rsquo;avantage étant que les vecteurs peuvent changer dynamiquement de taille.
En termes de stockage, les données vectorielles sont (généralement) placées dans une mémoire allouée dynamiquement, ce qui nécessite une surcharge mineure ; à l&amp;rsquo;inverse, C-arrays et std::array utilisent le stockage automatique par rapport à l&amp;rsquo;emplacement déclaré et n&amp;rsquo;ont donc pas de surcharge.</description>
    </item>
    
    <item>
      <title>Renvoyer plusieurs valeurs d&#39;une fonction</title>
      <link>https://www.wikiod.com/fr/c-/renvoyer-plusieurs-valeurs-dune-fonction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/renvoyer-plusieurs-valeurs-dune-fonction/</guid>
      <description>Il existe de nombreuses situations où il est utile de renvoyer plusieurs valeurs à partir d&amp;rsquo;une fonction : par exemple, si vous souhaitez saisir un article et renvoyer le prix et le nombre en stock, cette fonctionnalité peut être utile. Il existe de nombreuses façons de le faire en C++, et la plupart impliquent la STL. Cependant, si vous souhaitez éviter la STL pour une raison quelconque, il existe encore plusieurs façons de le faire, y compris structs/classes et arrays.</description>
    </item>
    
    <item>
      <title>La règle de trois, cinq et zéro</title>
      <link>https://www.wikiod.com/fr/c-/la-regle-de-trois-cinq-et-zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/la-regle-de-trois-cinq-et-zero/</guid>
      <description>Règle du zéro # Nous pouvons combiner les principes de la règle des cinq et [RAII] [1] pour obtenir une interface beaucoup plus légère : la règle du zéro : toute ressource qui doit être gérée doit être dans son propre type. Ce type devrait suivre la règle des cinq, mais tous les utilisateurs de cette ressource n&amp;rsquo;ont pas besoin d&amp;rsquo;écrire aucune des cinq fonctions membres spéciales et peuvent simplement toutes les définir par défaut.</description>
    </item>
    
    <item>
      <title>Lambda</title>
      <link>https://www.wikiod.com/fr/c-/lambda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/lambda/</guid>
      <description>Syntaxe # [default-capture, capture-list] (argument-list) mutable throw-specification attributes -&amp;gt; return-type { lambda-body } // Ordre des spécificateurs lambda et attributs. [capture-list] (argument-list) { lambda-body } // Définition lambda commune. [=] (argument-list) { lambda-body } // Capture toutes les variables locales nécessaires par valeur. [&amp;amp;] (argument-list) { lambda-body } // Capture toutes les variables locales nécessaires par référence. [capture-list] { lambda-body } // La liste d&amp;rsquo;arguments et les spécificateurs peuvent être omis.</description>
    </item>
    
    <item>
      <title>Pointeurs intelligents</title>
      <link>https://www.wikiod.com/fr/c-/pointeurs-intelligents/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/pointeurs-intelligents/</guid>
      <description>Syntaxe # std::shared_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_shared&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); std::shared_ptr&amp;lt;ClassType&amp;gt; variableName (nouveau ClassType(arg1, arg2, ...)); std::unique_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_unique&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); // C++14 std::unique_ptr&amp;lt;ClassType&amp;gt; variableName (nouveau ClassType(arg1, arg2, ...)); C++ n&amp;rsquo;est pas un langage géré en mémoire. La mémoire allouée dynamiquement (c&amp;rsquo;est-à-dire les objets créés avec new) sera &amp;ldquo;fuite&amp;rdquo; si elle n&amp;rsquo;est pas explicitement désallouée (avec delete). Il est de la responsabilité du programmeur de s&amp;rsquo;assurer que la mémoire allouée dynamiquement est libérée avant de supprimer le dernier pointeur vers cet objet.</description>
    </item>
    
    <item>
      <title>chaîne standard</title>
      <link>https://www.wikiod.com/fr/c-/chaine-standard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/chaine-standard/</guid>
      <description>Les chaînes sont des objets qui représentent des séquences de caractères. La classe standard string fournit une alternative simple, sûre et polyvalente à l&amp;rsquo;utilisation de tableaux explicites de char lorsqu&amp;rsquo;il s&amp;rsquo;agit de texte et d&amp;rsquo;autres séquences de caractères. La classe C++ string fait partie de l&amp;rsquo;espace de noms std et a été normalisée en 1998.
Syntaxe # // Déclaration de chaîne vide
std::string s;
// Construction à partir de const char* (c-string)</description>
    </item>
    
    <item>
      <title>Modèles</title>
      <link>https://www.wikiod.com/fr/c-/modeles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/modeles/</guid>
      <description>Les classes, les fonctions et (depuis C++14) les variables peuvent être modélisées. Un modèle est un morceau de code avec des paramètres libres qui deviendront une classe, une fonction ou une variable concrète lorsque tous les paramètres seront spécifiés. Les paramètres peuvent être des types, des valeurs ou eux-mêmes des modèles. Un modèle bien connu est std::vector, qui devient un type de conteneur concret lorsque le type d&amp;rsquo;élément est spécifié, par exemple, std::vector&amp;lt;int&amp;gt;.</description>
    </item>
    
    <item>
      <title>Métaprogrammation</title>
      <link>https://www.wikiod.com/fr/c-/metaprogrammation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/metaprogrammation/</guid>
      <description>En C++, la métaprogrammation fait référence à l&amp;rsquo;utilisation de macros ou de modèles pour générer du code au moment de la compilation.
En général, les macros sont mal vues dans ce rôle et les modèles sont préférés, bien qu&amp;rsquo;ils ne soient pas aussi génériques.
La métaprogrammation de modèles utilise souvent des calculs au moment de la compilation, que ce soit via des modèles ou des fonctions constexpr, pour atteindre ses objectifs de génération de code, mais les calculs au moment de la compilation ne sont pas de la métaprogrammation en soi.</description>
    </item>
    
    <item>
      <title>Enfilage</title>
      <link>https://www.wikiod.com/fr/c-/enfilage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/c-/enfilage/</guid>
      <description>Syntaxe # fil de discussion() fil (fil et autre) thread explicite (Function&amp;amp;&amp;amp; func, Args&amp;amp;&amp;amp;&amp;hellip; args) Paramètres # | Paramètre | Détails | | &amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | autre | Prend possession de other, other ne possède plus le fil | | fonc | Fonction à appeler dans un thread séparé | | arguments | Arguments pour func |
Quelques notes:
Deux objets std::thread ne peuvent jamais représenter le même thread.</description>
    </item>
    
  </channel>
</rss>
