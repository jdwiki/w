<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel .NET Framework on </title>
    <link>https://www.wikiod.com/fr/docs/dotnet/</link>
    <description>Recent content in Tutoriel .NET Framework on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/dotnet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec .NET Framework</title>
      <link>https://www.wikiod.com/fr/dotnet/premiers-pas-avec-net-framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/premiers-pas-avec-net-framework/</guid>
      <description>Bonjour tout le monde en C# # using System; class Program { // The Main() function is the first function to be executed in a program static void Main() { // Write the string &amp;quot;Hello World to the standard out Console.WriteLine(&amp;quot;Hello World&amp;quot;); } } Console.WriteLine a plusieurs surcharges. Dans ce cas, la chaîne &amp;ldquo;Hello World&amp;rdquo; est le paramètre, et il sortira le &amp;ldquo;Hello World&amp;rdquo; dans le flux de sortie standard pendant l&amp;rsquo;exécution.</description>
    </item>
    
    <item>
      <title>LINQ</title>
      <link>https://www.wikiod.com/fr/dotnet/linq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/linq/</guid>
      <description>LINQ (Language Integrated Query) est une expression qui récupère des données à partir d&amp;rsquo;une source de données. LINQ simplifie cette situation en offrant un modèle cohérent pour travailler avec des données sur différents types de sources et de formats de données. Dans une requête LINQ, vous travaillez toujours avec des objets. Vous utilisez les mêmes modèles de codage de base pour interroger et transformer des données dans des documents XML, des bases de données SQL, des ensembles de données ADO.</description>
    </item>
    
    <item>
      <title>Sérialisation JSON</title>
      <link>https://www.wikiod.com/fr/dotnet/serialisation-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/serialisation-json/</guid>
      <description>JavaScriptSerializer contre Json.NET
La classe JavaScriptSerializer a été introduite dans .NET 3.5 et est utilisé en interne par la couche de communication asynchrone de .NET pour les applications compatibles AJAX. Il peut être utilisé pour travailler avec JSON dans du code managé.
Malgré l&amp;rsquo;existence de la classe JavaScriptSerializer, Microsoft recommande d&amp;rsquo;utiliser la [bibliothèque Json.NET] open source (http://www.newtonsoft.com/json) pour la sérialisation et la désérialisation. Json.NET offre de meilleures performances et une interface plus conviviale pour mapper JSON à des classes personnalisées (un objet [JavaScriptConverter personnalisé](https://msdn.</description>
    </item>
    
    <item>
      <title>Bibliothèque parallèle de tâches (TPL)</title>
      <link>https://www.wikiod.com/fr/dotnet/bibliotheque-parallele-de-taches-tpl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/bibliotheque-parallele-de-taches-tpl/</guid>
      <description>Objectif et cas d&amp;rsquo;utilisation # L&amp;rsquo;objectif de la bibliothèque parallèle de tâches est de simplifier le processus d&amp;rsquo;écriture et de maintenance du code multithread et parallèle.
Quelques cas d&amp;rsquo;utilisation* :
Garder une interface utilisateur réactive en exécutant un travail en arrière-plan sur une tâche distincte Répartition de la charge de travail Permettre à une application cliente d&amp;rsquo;envoyer et de recevoir des requêtes en même temps (rest, TCP/UDP, ect) Lire et/ou écrire plusieurs fichiers à la fois *Le code doit être considéré au cas par cas pour le multithreading.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://www.wikiod.com/fr/dotnet/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/exceptions/</guid>
      <description>Lié:
MSDN : Exceptions et gestion des exceptions (Guide de programmation C#) MSDN : Gestion et émission d&amp;rsquo;exceptions * MSDN : CA1031 : ne pas intercepter les types d&amp;rsquo;exceptions générales MSDN : try-catch (référence C#) Attraper et relancer les exceptions interceptées # Lorsque vous souhaitez intercepter une exception et faire quelque chose, mais que vous ne pouvez pas continuer l&amp;rsquo;exécution du bloc de code en cours à cause de l&amp;rsquo;exception, vous pouvez renvoyer l&amp;rsquo;exception au prochain gestionnaire d&amp;rsquo;exceptions dans la pile des appels.</description>
    </item>
    
    <item>
      <title>Analyse DateTime</title>
      <link>https://www.wikiod.com/fr/dotnet/analyse-datetime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/analyse-datetime/</guid>
      <description>ParseExact # var dateString = &amp;quot;2015-11-24&amp;quot;; var date = DateTime.ParseExact(dateString, &amp;quot;yyyy-MM-dd&amp;quot;, null); Console.WriteLine(date); 24/11/2015 00:00:00
Notez que passer CultureInfo.CurrentCulture comme troisième paramètre est identique à passer null. Ou, vous pouvez transmettre une culture spécifique.
Formater les chaînes
La chaîne d&amp;rsquo;entrée peut être dans n&amp;rsquo;importe quel format correspondant à la chaîne de format
var date = DateTime.ParseExact(&amp;quot;24|201511&amp;quot;, &amp;quot;dd|yyyyMM&amp;quot;, null); Console.WriteLine(date); 24/11/2015 00:00:00
Tous les caractères qui ne sont pas des spécificateurs de format sont traités comme des littéraux</description>
    </item>
    
    <item>
      <title>Dictionnaires</title>
      <link>https://www.wikiod.com/fr/dotnet/dictionnaires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/dictionnaires/</guid>
      <description>Initialisation d&amp;rsquo;un dictionnaire avec un initialiseur de collection # // Translates to `dict.Add(1, &amp;quot;First&amp;quot;)` etc. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { { 1, &amp;quot;First&amp;quot; }, { 2, &amp;quot;Second&amp;quot; }, { 3, &amp;quot;Third&amp;quot; } }; // Translates to `dict[1] = &amp;quot;First&amp;quot;` etc. // Works in C# 6.0. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { [1] = &amp;quot;First&amp;quot;, [2] = &amp;quot;Second&amp;quot;, [3] = &amp;quot;Third&amp;quot; }; Ajout à un dictionnaire # Dictionary&amp;lt;int, string&amp;gt; dict = new Dictionary&amp;lt;int, string&amp;gt;(); dict.</description>
    </item>
    
    <item>
      <title>Injection de dépendance</title>
      <link>https://www.wikiod.com/fr/dotnet/injection-de-dependance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/injection-de-dependance/</guid>
      <description>Problèmes résolus par injection de dépendance
Si nous n&amp;rsquo;utilisions pas l&amp;rsquo;injection de dépendances, la classe Greeter pourrait ressembler davantage à ceci :
public class ControlFreakGreeter { public void Greet() { var greetingProvider = new SqlGreetingProvider( ConfigurationManager.ConnectionStrings[&amp;quot;myConnectionString&amp;quot;].ConnectionString); var greeting = greetingProvider.GetGreeting(); Console.WriteLine(greeting); } } C&amp;rsquo;est un &amp;ldquo;maniaque du contrôle&amp;rdquo; car il contrôle la création de la classe qui fournit le message d&amp;rsquo;accueil, il contrôle l&amp;rsquo;origine de la chaîne de connexion SQL et il contrôle la sortie.</description>
    </item>
    
    <item>
      <title>ADO.NET</title>
      <link>https://www.wikiod.com/fr/dotnet/adonet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/adonet/</guid>
      <description>ADO(ActiveX Data Objects).Net est un outil fourni par Microsoft qui permet d&amp;rsquo;accéder à des sources de données telles que SQL Server, Oracle et XML via ses composants. Les applications frontales .Net peuvent récupérer, créer et manipuler des données une fois qu&amp;rsquo;elles sont connectées à une source de données via ADO.Net avec les privilèges appropriés.
ADO.Net fournit une architecture sans connexion. Il s&amp;rsquo;agit d&amp;rsquo;une approche sécurisée pour interagir avec une base de données, car la connexion n&amp;rsquo;a pas besoin d&amp;rsquo;être maintenue pendant toute la session.</description>
    </item>
    
    <item>
      <title>Client HTTP</title>
      <link>https://www.wikiod.com/fr/dotnet/client-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/dotnet/client-http/</guid>
      <description>Les RFC HTTP/1.1 actuellement pertinentes sont :
* 7230 : Syntaxe et routage des messages
7231 : Sémantique et contenu 7232 : Requêtes conditionnelles * 7233 : Demandes de plage 7234 : Mise en cache 7235 : Authentification * 7239 : Extension HTTP transférée * 7240 : Préférer l&amp;rsquo;en-tête pour HTTP Il existe également les RFC informatifs suivants :
* 7236 : Enregistrements du schéma d&amp;rsquo;authentification
7237 : Enregistrements de méthode Et le RFC expérimental :</description>
    </item>
    
  </channel>
</rss>
