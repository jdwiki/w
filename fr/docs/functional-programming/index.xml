<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel de programmation fonctionnelle on </title>
    <link>https://www.wikiod.com/fr/docs/functional-programming/</link>
    <description>Recent content in Tutoriel de programmation fonctionnelle on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Initiation à la programmation fonctionnelle</title>
      <link>https://www.wikiod.com/fr/functional-programming/initiation-a-la-programmation-fonctionnelle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/functional-programming/initiation-a-la-programmation-fonctionnelle/</guid>
      <description>Fonctions pures # Les fonctions pures sont autonomes et n&amp;rsquo;ont aucun effet secondaire. Étant donné le même ensemble d&amp;rsquo;entrées, une fonction pure renverra toujours la même valeur de sortie.
La fonction suivante est pure :
function pure(data) { return data.total + 3; } Cependant, cette fonction n&amp;rsquo;est pas pure car elle modifie une variable externe :
function impure(data) { data.total += 3; return data.total; } Exemple:
data = { total: 6 }; pure(data); // outputs: 9 impure(data); // outputs: 9 (but now data.</description>
    </item>
    
    <item>
      <title>Boucles par fonctions récursives et récursives de queue</title>
      <link>https://www.wikiod.com/fr/functional-programming/boucles-par-fonctions-recursives-et-recursives-de-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/functional-programming/boucles-par-fonctions-recursives-et-recursives-de-queue/</guid>
      <description>Comme vous le savez déjà, pour des raisons d&amp;rsquo;immuabilité, vous ne pouvez pas traiter les données à l&amp;rsquo;aide de boucles for et while. Nous avons donc des fonctions récursives à sauver.
non récursif (où l&amp;rsquo;immuabilité n&amp;rsquo;est pas un problème) # function sum(numbers) { var total = 0; for (var i = numbers.length - 1; i &amp;gt;= 0; i--) { total += numbers[i]; } return total; } C&amp;rsquo;est un code procédural avec des mutations (sur total).</description>
    </item>
    
  </channel>
</rss>
