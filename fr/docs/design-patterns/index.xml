<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Modèles de conception Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/design-patterns/</link>
    <description>Recent content in Modèles de conception Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec les modèles de conception</title>
      <link>https://www.wikiod.com/fr/design-patterns/premiers-pas-avec-les-modeles-de-conception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/premiers-pas-avec-les-modeles-de-conception/</guid>
      <description>Introduction # Selon [Wikipédia][1] :
[A] modèle de conception de logiciel est une solution générale réutilisable à un problème courant dans un contexte donné de conception de logiciel. Ce n&amp;rsquo;est pas une conception finie qui peut être transformée directement en code source ou machine. Il s&amp;rsquo;agit d&amp;rsquo;une description ou d&amp;rsquo;un modèle de résolution d&amp;rsquo;un problème qui peut être utilisé dans de nombreuses situations différentes. Les modèles de conception sont des meilleures pratiques formalisées que le programmeur peut utiliser pour résoudre des problèmes courants lors de la conception d&amp;rsquo;une application ou d&amp;rsquo;un système.</description>
    </item>
    
    <item>
      <title>Usine</title>
      <link>https://www.wikiod.com/fr/design-patterns/usine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/usine/</guid>
      <description>Fournir une interface pour créer des familles d&amp;rsquo;objets liés ou dépendants sans spécifier leurs classes concrètes.
&amp;ndash; GOF 1994
Usine simple (Java) # Une usine diminue le couplage entre le code qui doit créer des objets à partir du code de création d&amp;rsquo;objet. La création d&amp;rsquo;objet ne se fait pas explicitement en appelant un constructeur de classe mais en appelant une fonction qui crée l&amp;rsquo;objet au nom de l&amp;rsquo;appelant. Un exemple Java simple est le suivant :</description>
    </item>
    
    <item>
      <title>Singleton</title>
      <link>https://www.wikiod.com/fr/design-patterns/singleton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/singleton/</guid>
      <description>Le modèle de conception Singleton est parfois considéré comme &amp;ldquo;* Anti pattern *&amp;rdquo;. Cela est dû au fait qu&amp;rsquo;il a quelques problèmes. Vous devez décider vous-même si vous pensez qu&amp;rsquo;il est approprié de l&amp;rsquo;utiliser. Ce sujet a été abordé plusieurs fois sur StackOverflow.
Voir: http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons
Singleton (Java) # Les singletons en Java sont très similaires à C #, car les deux langages sont orientés objet. Vous trouverez ci-dessous un exemple de classe singleton, où une seule version de l&amp;rsquo;objet peut être active pendant la durée de vie du programme (en supposant que le programme fonctionne sur un thread)</description>
    </item>
    
    <item>
      <title>Modèle de stratégie</title>
      <link>https://www.wikiod.com/fr/design-patterns/modele-de-strategie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/modele-de-strategie/</guid>
      <description>Exemple de modèle de stratégie en Java avec la classe Context # Stratégie:
Strategy est un modèle comportemental, qui permet de changer dynamiquement l&amp;rsquo;algorithme à partir d&amp;rsquo;une famille d&amp;rsquo;algorithmes liés.
UML du modèle de stratégie de Wikipedia
[![entrez la description de l&amp;rsquo;image ici][1]][1] :
import java.util.*; /* Interface for Strategy */ interface OfferStrategy { public String getName(); public double getDiscountPercentage(); } /* Concrete implementation of base Strategy */ class NoDiscountStrategy implements OfferStrategy{ public String getName(){ return this.</description>
    </item>
    
    <item>
      <title>Modèle de constructeur</title>
      <link>https://www.wikiod.com/fr/design-patterns/modele-de-constructeur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/modele-de-constructeur/</guid>
      <description>Sépare la construction d&amp;rsquo;un objet complexe de sa représentation afin qu&amp;rsquo;un même processus de construction puisse créer différentes représentations.
Séparer la logique de la représentation. Réutiliser la logique pour travailler avec différents ensembles de données. Java / Lombok # import lombok.Builder; @Builder public class Email { private String to; private String from; private String subject; private String body; } Exemple d&amp;rsquo;utilisation :
Email.builder().to(&amp;quot;email1@email.com&amp;quot;) .from(&amp;quot;email2@email.com&amp;quot;) .subject(&amp;quot;Email subject&amp;quot;) .body(&amp;quot;Email content&amp;quot;) .build(); Modèle de constructeur en Java avec composition # Intention:</description>
    </item>
    
    <item>
      <title>Motif décorateur</title>
      <link>https://www.wikiod.com/fr/design-patterns/motif-decorateur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/motif-decorateur/</guid>
      <description>Le modèle de décorateur permet à un utilisateur d&amp;rsquo;ajouter de nouvelles fonctionnalités à un objet existant sans modifier sa structure. Ce type de modèle de conception relève du modèle structurel car ce modèle agit comme un wrapper pour la classe existante.
Ce modèle crée une classe de décorateur qui enveloppe la classe d&amp;rsquo;origine et fournit des fonctionnalités supplémentaires en gardant intacte la signature des méthodes de classe.
Paramètres # Paramètre Descriptif Boisson ça peut être du thé ou du café VendingMachineDecorator # Définition de décorateur selon Wikipedia :</description>
    </item>
    
    <item>
      <title>Injection de dépendance</title>
      <link>https://www.wikiod.com/fr/design-patterns/injection-de-dependance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/injection-de-dependance/</guid>
      <description>L&amp;rsquo;idée générale derrière l&amp;rsquo;injection de dépendance est que vous concevez votre application autour de composants faiblement couplés tout en respectant le principe d&amp;rsquo;inversion de dépendance. En ne dépendant pas des implémentations concrètes, permet de concevoir des systèmes très flexibles.
L&amp;rsquo;idée de base derrière l&amp;rsquo;injection de dépendances est de créer un code plus faiblement couplé. Lorsqu&amp;rsquo;une classe, plutôt que de créer ses propres dépendances, prend ses dépendances à la place, la classe devient plus simple à tester en tant qu&amp;rsquo;unité ([unit testing][1]).</description>
    </item>
    
    <item>
      <title>Modèle de visiteur</title>
      <link>https://www.wikiod.com/fr/design-patterns/modele-de-visiteur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/modele-de-visiteur/</guid>
      <description>Exemple de modèle de visiteur en Java # Le modèle Visitor vous permet d&amp;rsquo;ajouter de nouvelles opérations ou méthodes à un ensemble de classes sans modifier la structure de ces classes.
Ce pattern est particulièrement utile lorsque vous souhaitez centraliser une opération particulière sur un objet sans étendre l&amp;rsquo;objet ou sans modifier l&amp;rsquo;objet.
Diagramme UML de wikipedia :
[![entrez la description de l&amp;rsquo;image ici][1]][1]
Extrait de code:
import java.util.HashMap; interface Visitable{ void accept(Visitor visitor); } interface Visitor{ void logGameStatistics(Chess chess); void logGameStatistics(Checkers checkers); void logGameStatistics(Ludo ludo); } class GameVisitor implements Visitor{ public void logGameStatistics(Chess chess){ System.</description>
    </item>
    
    <item>
      <title>Modèle de commande</title>
      <link>https://www.wikiod.com/fr/design-patterns/modele-de-commande/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/modele-de-commande/</guid>
      <description>Exemple de modèle de commande en Java # Définition [wikipédia] :
Le modèle de commande est un modèle de conception comportemental dans lequel un objet est utilisé pour encapsuler toutes les informations nécessaires pour effectuer une action ou déclencher un événement ultérieurement
Diagramme UML de [dofactory][2] :
[![entrez la description de l&amp;rsquo;image ici][3]][3]
Composants de base et flux de travail :
Command déclare une interface pour les commandes abstraites comme execute() Receiver sait comment exécuter une commande particulière Invoker contient ConcreteCommand, qui doit être exécuté Client crée ConcreteCommand et attribue Receiver ConcreteCommand définit la liaison entre Command et Receiver De cette manière, le modèle de commande dissocie Expéditeur (Client) de Récepteur via Invocateur.</description>
    </item>
    
    <item>
      <title>Modèle de référentiel</title>
      <link>https://www.wikiod.com/fr/design-patterns/modele-de-referentiel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/design-patterns/modele-de-referentiel/</guid>
      <description>À propos de l&amp;rsquo;implémentation de IEnumerable&amp;lt;TEntity&amp;gt; Get(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter) : l&amp;rsquo;idée est d&amp;rsquo;utiliser des expressions telles que i =&amp;gt; x.id == 17 pour écrire demandes génériques. C&amp;rsquo;est un moyen d&amp;rsquo;interroger des données sans utiliser le langage de requête spécifique de votre technologie. L&amp;rsquo;implémentation est assez étendue, vous pouvez donc envisager d&amp;rsquo;autres alternatives, comme des méthodes spécifiques sur vos référentiels implémentés : un CompanyRepository imaginaire pourrait fournir la méthode GetByName(string name).</description>
    </item>
    
  </channel>
</rss>
