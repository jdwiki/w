<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel sur le langage C# on </title>
    <link>https://www.wikiod.com/fr/docs/csharp/</link>
    <description>Recent content in Tutoriel sur le langage C# on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec le langage C#</title>
      <link>https://www.wikiod.com/fr/csharp/premiers-pas-avec-le-langage-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/premiers-pas-avec-le-langage-c/</guid>
      <description>Création d&amp;rsquo;une nouvelle application console (Visual Studio) # Ouvrez Visual Studio
Dans la barre d&amp;rsquo;outils, allez dans Fichier → Nouveau projet
Sélectionnez le type de projet Application console
Ouvrez le fichier &amp;ldquo;Program.cs&amp;rdquo; dans l&amp;rsquo;explorateur de solutions
Ajoutez le code suivant à Main() :
public class Program { public static void Main() { // Prints a message to the console. System.Console.WriteLine(&amp;ldquo;Hello, World!&amp;rdquo;);
/* Wait for the user to press a key. This is a common way to prevent the console window from terminating and disappearing before the programmer can see the contents of the window, when the application is run via Start from within VS.</description>
    </item>
    
    <item>
      <title>Fonctionnalités C# 6.0</title>
      <link>https://www.wikiod.com/fr/csharp/fonctionnalites-c-60/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/fonctionnalites-c-60/</guid>
      <description>Cette sixième itération du langage C# est fournie par le compilateur Roslyn. Ce compilateur est sorti avec la version 4.6 du .NET Framework, mais il peut générer du code de manière rétrocompatible pour permettre de cibler les versions antérieures du framework. Le code C# version 6 peut être compilé de manière totalement rétrocompatible avec .NET 4.0. Il peut également être utilisé pour les frameworks antérieurs, mais certaines fonctionnalités nécessitant une prise en charge de framework supplémentaire peuvent ne pas fonctionner correctement.</description>
    </item>
    
    <item>
      <title>Fonctionnalités C# 7.0</title>
      <link>https://www.wikiod.com/fr/csharp/fonctionnalites-c-70/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/fonctionnalites-c-70/</guid>
      <description>C# 7.0 est la septième version de C#. Cette version contient de nouvelles fonctionnalités : prise en charge de la langue pour Tuples, fonctions locales, déclarations &amp;ldquo;out var&amp;rdquo;, séparateurs de chiffres, littéraux binaires, correspondance de modèles, expressions de lancement, &amp;ldquo;ref return&amp;rdquo; et &amp;ldquo;ref local&amp;rdquo; et liste étendue des membres du corps d&amp;rsquo;expression.
Référence officielle : Quoi de neuf dans C# 7
Prise en charge de la langue pour les tuples # Bases # Un tuple est une liste ordonnée et finie d&amp;rsquo;éléments.</description>
    </item>
    
    <item>
      <title>Méthodes d&#39;extension</title>
      <link>https://www.wikiod.com/fr/csharp/methodes-dextension/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/methodes-dextension/</guid>
      <description>Syntaxe # public static ReturnType MyExtensionMethod (cette cible TargetType) public static ReturnType MyExtensionMethod (cette cible TargetType, TArg1 arg1, &amp;hellip;) Paramètres # Paramètre Détails ce Le premier paramètre d&amp;rsquo;une méthode d&amp;rsquo;extension doit toujours être précédé du mot clé this, suivi de l&amp;rsquo;identifiant avec lequel se référer à l&amp;rsquo;instance &amp;ldquo;actuelle&amp;rdquo; de l&amp;rsquo;objet que vous étendez Les méthodes d&amp;rsquo;extension sont du sucre syntaxique qui permet d&amp;rsquo;invoquer des méthodes statiques sur des instances d&amp;rsquo;objet comme si elles étaient un membre du type lui-même.</description>
    </item>
    
    <item>
      <title>Requêtes LINQ</title>
      <link>https://www.wikiod.com/fr/csharp/requetes-linq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/requetes-linq/</guid>
      <description>LINQ est un acronyme qui signifie Language INtegrated Query. Il s&amp;rsquo;agit d&amp;rsquo;un concept qui intègre un langage de requête en offrant un modèle cohérent pour travailler avec des données sur différents types de sources et de formats de données ; vous utilisez les mêmes modèles de codage de base pour interroger et transformer des données dans des documents XML, des bases de données SQL, des ensembles de données ADO.NET, des collections .</description>
    </item>
    
    <item>
      <title>Mots clés</title>
      <link>https://www.wikiod.com/fr/csharp/mots-cles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/mots-cles/</guid>
      <description>Keywords sont des identificateurs prédéfinis et réservés ayant une signification particulière pour le compilateur. Ils ne peuvent pas être utilisés comme identifiants dans votre programme sans le préfixe @. Par exemple, @if est un identifiant légal mais pas le mot clé if.
C# a une collection prédéfinie de &amp;ldquo;mots clés&amp;rdquo; (ou mots réservés) qui ont chacun une fonction spéciale. Ces mots ne peuvent pas être utilisés comme identifiants (noms de variables, méthodes, classes, etc.</description>
    </item>
    
    <item>
      <title>Mot clé de rendement</title>
      <link>https://www.wikiod.com/fr/csharp/mot-cle-de-rendement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/mot-cle-de-rendement/</guid>
      <description>Lorsque vous utilisez le mot clé yield dans une instruction, vous indiquez que la méthode, l&amp;rsquo;opérateur ou l&amp;rsquo;accesseur get dans lequel il apparaît est un itérateur. L&amp;rsquo;utilisation de yield pour définir un itérateur supprime le besoin d&amp;rsquo;une classe supplémentaire explicite (la classe qui contient l&amp;rsquo;état d&amp;rsquo;une énumération) lorsque vous implémentez le modèle IEnumerable et IEnumerator pour un type de collection personnalisé.
Syntaxe # rendement de rendement [TYPE] rupture de rendement Mettre le mot clé yield dans une méthode avec le type de retour IEnumerable, IEnumerable&amp;lt;T&amp;gt;, IEnumerator ou IEnumerator&amp;lt;T&amp;gt; indique au compilateur de générer une implémentation du type de retour (IEnumerable ou IEnumerator) qui, lorsqu&amp;rsquo;il est bouclé, exécute la méthode jusqu&amp;rsquo;à chaque &amp;ldquo;rendement&amp;rdquo; pour obtenir chaque résultat.</description>
    </item>
    
    <item>
      <title>Utilisation de l&#39;instruction</title>
      <link>https://www.wikiod.com/fr/csharp/utilisation-de-linstruction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/utilisation-de-linstruction/</guid>
      <description>Fournit une syntaxe pratique qui garantit l&amp;rsquo;utilisation correcte des objets IDisposable.
Syntaxe # en utilisant (jetable) { } en utilisant (IDisposable jetable = new MyDisposable()) { } L&amp;rsquo;objet dans l&amp;rsquo;instruction using doit implémenter l&amp;rsquo;interface IDisposable.
using(var obj = new MyObject()) { } class MyObject : IDisposable { public void Dispose() { // Cleanup } } Des exemples plus complets pour l&amp;rsquo;implémentation de IDisposable peuvent être trouvés dans [MSDN docs][1].
[1] : https://msdn.</description>
    </item>
    
    <item>
      <title>Gestion des exceptions</title>
      <link>https://www.wikiod.com/fr/csharp/gestion-des-exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/gestion-des-exceptions/</guid>
      <description>Création d&amp;rsquo;exceptions personnalisées # Vous êtes autorisé à implémenter des exceptions personnalisées qui peuvent être levées comme n&amp;rsquo;importe quelle autre exception. Cela a du sens lorsque vous souhaitez distinguer vos exceptions des autres erreurs lors de l&amp;rsquo;exécution.
Dans cet exemple, nous allons créer une exception personnalisée pour une gestion claire des problèmes que l&amp;rsquo;application peut rencontrer lors de l&amp;rsquo;analyse d&amp;rsquo;une entrée complexe.
Création d&amp;rsquo;une classe d&amp;rsquo;exception personnalisée # Pour créer une exception personnalisée, créez une sous-classe de &amp;ldquo;Exception&amp;rdquo; :</description>
    </item>
    
    <item>
      <title>Attente asynchrone</title>
      <link>https://www.wikiod.com/fr/csharp/attente-asynchrone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/csharp/attente-asynchrone/</guid>
      <description>En C #, une méthode déclarée async ne se bloquera pas dans un processus synchrone, si vous utilisez des opérations basées sur les E/S (par exemple, accès Web, travail avec des fichiers, &amp;hellip;). Le résultat de ces méthodes marquées asynchrones peut être attendu via l&amp;rsquo;utilisation du mot-clé &amp;ldquo;wait&amp;rdquo;.
Une méthode async peut renvoyer void, Task ou Task&amp;lt;T&amp;gt;.
Le type de retour Task attendra que la méthode se termine et le résultat sera void.</description>
    </item>
    
  </channel>
</rss>
