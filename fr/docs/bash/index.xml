<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel Bash on </title>
    <link>https://www.wikiod.com/fr/docs/bash/</link>
    <description>Recent content in Tutoriel Bash on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/bash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Bash</title>
      <link>https://www.wikiod.com/fr/bash/premiers-pas-avec-bash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/premiers-pas-avec-bash/</guid>
      <description>Bonjour le monde # Coque interactive # Le shell Bash est couramment utilisé de manière interactive : Il vous permet d&amp;rsquo;entrer et de modifier des commandes, puis de les exécuter lorsque vous appuyez sur la touche Retour. De nombreux systèmes d&amp;rsquo;exploitation basés sur Unix et de type Unix utilisent Bash comme shell par défaut (notamment Linux et macOS). Le terminal entre automatiquement dans un processus shell Bash interactif au démarrage.</description>
    </item>
    
    <item>
      <title>Tableaux</title>
      <link>https://www.wikiod.com/fr/bash/tableaux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/tableaux/</guid>
      <description>Affectations de tableau # Affectation de la liste
Si vous êtes familier avec Perl, C ou Java, vous pourriez penser que Bash utiliserait des virgules pour séparer les éléments d&amp;rsquo;un tableau, mais ce n&amp;rsquo;est pas le cas ; à la place, Bash utilise des espaces :
# Array in Perl my @array = (1, 2, 3, 4); # Array in Bash array=(1 2 3 4) Créez un tableau avec de nouveaux éléments :</description>
    </item>
    
    <item>
      <title>Utiliser le piège pour réagir aux signaux et aux événements système</title>
      <link>https://www.wikiod.com/fr/bash/utiliser-le-piege-pour-reagir-aux-signaux-et-aux-evenements-systeme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/utiliser-le-piege-pour-reagir-aux-signaux-et-aux-evenements-systeme/</guid>
      <description>Syntaxe # trap action sigspec&amp;hellip; # Lance &amp;ldquo;action&amp;rdquo; sur une liste de signaux trap sigspec&amp;hellip; # Omettre l&amp;rsquo;action réinitialise les traps pour les signaux Paramètres # Paramètre Signification -p Liste des pièges actuellement installés -l Liste des noms de signaux et des numéros correspondants L&amp;rsquo;utilitaire trap est un shell spécial intégré. C&amp;rsquo;est défini dans POSIX, mais bash ajoute également quelques extensions utiles.
Les exemples compatibles avec POSIX commencent par #!/bin/sh et les exemples commençant par #!</description>
    </item>
    
    <item>
      <title>Variables internes</title>
      <link>https://www.wikiod.com/fr/bash/variables-internes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/variables-internes/</guid>
      <description>Un aperçu des variables internes de Bash, où, comment et quand les utiliser.
Les variables internes de Bash en un coup d&amp;rsquo;œil # variables Détails $* / $@ Paramètres positionnels de fonction/script (arguments). Développez comme suit :
$* et $@ sont identiques à $1 $2 ... (notez qu&amp;rsquo;il est généralement inutile de les laisser sans guillemets)
&amp;quot;$* &amp;quot; est identique à &amp;quot;$1 $2 ...&amp;quot; 1 &amp;quot;$@&amp;quot; est identique à &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot; .</description>
    </item>
    
    <item>
      <title>Extension des paramètres bash</title>
      <link>https://www.wikiod.com/fr/bash/extension-des-parametres-bash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/extension-des-parametres-bash/</guid>
      <description>Le caractère $ introduit l&amp;rsquo;expansion des paramètres, la substitution de commande ou l&amp;rsquo;expansion arithmétique. Le nom du paramètre ou le symbole à développer peut être entouré d&amp;rsquo;accolades, qui sont facultatives mais servent à protéger la variable à développer des caractères qui la suivent immédiatement et qui pourraient être interprétés comme faisant partie du nom.
Pour en savoir plus, consultez le Manuel de l&amp;rsquo;utilisateur de Bash.
Syntaxe # ${parameter:offset} # Sous-chaîne commençant à offset ${parameter:offset:length} # Sous-chaîne de longueur &amp;ldquo;length&amp;rdquo; commençant à offset ${#paramètre} # Longueur du paramètre ${parameter/pattern/string} # Remplace la première occurrence de pattern par string ${parameter//pattern/string} # Remplace toutes les occurrences de pattern par string ${parameter/#pattern/string} # Remplacer pattern par string si pattern est au début ${parameter/%pattern/string} # Remplacer pattern par string si pattern est à la fin ${parameter#pattern} # Supprime la correspondance la plus courte du motif depuis le début du paramètre ${parameter##pattern} # Supprime la correspondance la plus longue du motif depuis le début du paramètre ${parameter%pattern} # Supprime la correspondance la plus courte du motif à la fin du paramètre ${parameter%%pattern} # Supprime la correspondance la plus longue du motif à partir de la fin du paramètre ${parameter:-word} # Développer en mot si le paramètre n&amp;rsquo;est pas défini/non défini ${paramètre :=mot} # Développer en mot si le paramètre n&amp;rsquo;est pas défini/non défini et que le paramètre est défini ${parameter:+word} # Développer en mot si le paramètre est défini/défini Modification de la casse des caractères alphabétiques # En majuscule</description>
    </item>
    
    <item>
      <title>Redirection</title>
      <link>https://www.wikiod.com/fr/bash/redirection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/redirection/</guid>
      <description>Syntaxe # command &amp;lt;/path/to/file # Redirige l&amp;rsquo;entrée standard vers le fichier command &amp;gt;/path/to/file # Redirige la sortie standard vers flie command file_descriptor&amp;gt;/path/to/file # Redirige la sortie de file_descriptor vers le fichier command &amp;gt;&amp;amp;file_descriptor # Redirige la sortie vers file_descriptor command file_descriptor&amp;gt;&amp;amp;another_file_descriptor # Redirige file_descriptor vers another_file_descriptor command &amp;lt;&amp;amp;file_descriptor # Redirige file_descriptor vers l&amp;rsquo;entrée standard command &amp;amp;&amp;gt;/path/to/file # Redirige la sortie standard et l&amp;rsquo;erreur standard vers le fichier Paramètres # Paramètre Détails descripteur de fichier interne Un nombre entier.</description>
    </item>
    
    <item>
      <title>Ici les documents et ici les chaînes</title>
      <link>https://www.wikiod.com/fr/bash/ici-les-documents-et-ici-les-chaines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/ici-les-documents-et-ici-les-chaines/</guid>
      <description>Exécuter la commande avec le document ici # ssh -p 21 example@example.com &amp;lt;&amp;lt;EOF echo &#39;printing pwd&#39; echo &amp;quot;\$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF $ est échappé car nous ne voulons pas qu&amp;rsquo;il soit développé par le shell actuel, c&amp;rsquo;est-à-dire que $(pwd) doit être exécuté sur le shell distant.
Autrement:
ssh -p 21 example@example.com &amp;lt;&amp;lt;&#39;EOF&#39; echo &#39;printing pwd&#39; echo &amp;quot;$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF Remarque : L&amp;rsquo;EOF de fermeture devrait être au début de la ligne (pas d&amp;rsquo;espaces avant).</description>
    </item>
    
    <item>
      <title>Les fonctions</title>
      <link>https://www.wikiod.com/fr/bash/les-fonctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/les-fonctions/</guid>
      <description>Syntaxe # Définissez une fonction avec le mot clé function :
function f { }
Définissez une fonction avec () :
f(){ }
Définissez une fonction avec à la fois le mot-clé function et () :
function f(){ }
Fonctions avec arguments # Dans helloJohn.sh :
#!/bin/bash greet() { local name=&amp;quot;$1&amp;quot; echo &amp;quot;Hello, $name&amp;quot; } greet &amp;quot;John Doe&amp;quot; # running above script $ bash helloJohn.sh Hello, John Doe Si vous ne modifiez pas l&amp;rsquo;argument de quelque manière que ce soit, il n&amp;rsquo;est pas nécessaire de le copier dans une variable locale - simplement echo &amp;quot;Hello, $1&amp;quot;.</description>
    </item>
    
    <item>
      <title>Liste des fichiers</title>
      <link>https://www.wikiod.com/fr/bash/liste-des-fichiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/liste-des-fichiers/</guid>
      <description>Syntaxe # ls [OPTION]&amp;hellip; [FICHIER]&amp;hellip; Paramètres # Options Descriptif -a, --tout Liste toutes les entrées, y compris celles qui commencent par un point -A, --presque-tout Lister toutes les entrées sauf . et .. -c Trier les fichiers par heure de changement -d, --répertoire Lister les entrées du répertoire -h, --lisible par l&#39;homme Afficher les tailles dans un format lisible par l&amp;rsquo;homme (c&amp;rsquo;est-à-dire &amp;lsquo;K&amp;rsquo;, &amp;lsquo;M&amp;rsquo;) -H Comme ci-dessus uniquement avec des puissances de 1000 au lieu de 1024 -l Afficher le contenu au format longue liste -o Format de liste longue sans informations de groupe -r, --reverse Afficher le contenu dans l&amp;rsquo;ordre inverse -s, --taille Taille d&amp;rsquo;impression de chaque fichier en blocs -S Trier par taille de fichier --sort=MOT Trier le contenu par mot.</description>
    </item>
    
    <item>
      <title>Trouver</title>
      <link>https://www.wikiod.com/fr/bash/trouver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/bash/trouver/</guid>
      <description>find est une commande permettant de rechercher de manière récursive dans un répertoire des fichiers (ou des répertoires) correspondant à un critère, puis d&amp;rsquo;effectuer une action sur les fichiers sélectionnés.
trouver l&amp;rsquo;action search_path selection_criteria
Syntaxe # find [-H] [-L] [-P] [-D options de débogage] [-Olevel] [chemin&amp;hellip;] [expression] Recherche d&amp;rsquo;un fichier par nom ou extension # Pour trouver des fichiers/répertoires avec un nom spécifique, relatif à pwd :
$ find . -name &amp;quot;myFile.</description>
    </item>
    
  </channel>
</rss>
