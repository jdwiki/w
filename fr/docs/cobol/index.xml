<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cobol Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/cobol/</link>
    <description>Recent content in Cobol Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/cobol/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec cobol</title>
      <link>https://www.wikiod.com/fr/cobol/debuter-avec-cobol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/debuter-avec-cobol/</guid>
      <description>Bonjour le monde # HELLO * HISTORIC EXAMPLE OF HELLO WORLD IN COBOL IDENTIFICATION DIVISION. PROGRAM-ID. HELLO. PROCEDURE DIVISION. DISPLAY &amp;quot;HELLO, WORLD&amp;quot;. STOP RUN. L&amp;rsquo;époque de la disposition des cartes perforées et des entrées en majuscules uniquement est loin derrière. Pourtant, la plupart des implémentations COBOL gèrent toujours la même disposition de code. Même les implémentations actuelles suivent la même chose (souvent même en majuscules) compilées et en production.
Une implémentation moderne bien formatée pourrait ressembler à :</description>
    </item>
    
    <item>
      <title>Instruction APPEL</title>
      <link>https://www.wikiod.com/fr/cobol/instruction-appel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/instruction-appel/</guid>
      <description>L&amp;rsquo;instruction COBOL CALL permet d&amp;rsquo;accéder aux routines de bibliothèque compilées.
[![entrez la description de l&amp;rsquo;image ici][1]][1]
[1] : http://i.stack.imgur.com/USCTk.png
Instruction CALL # COBOL peut utiliser une liaison statique pour l&amp;rsquo;instruction suivante. GnuCOBOL utilise la liaison dynamique par défaut pour tous les symboles externes connus au moment de la compilation, même lorsque le symbole est un littéral :
CALL &amp;quot;subprogram&amp;quot; USING a b c *&amp;gt; run a (possibly static linked) sub program *&amp;gt; passing three fields CALL some-prog USING a b c *&amp;gt; some-prog is a PIC X item and can be changed *&amp;gt; at run-time to do a dynamic lookup Cette instruction force la résolution d&amp;rsquo;édition des liens au moment de la compilation.</description>
    </item>
    
    <item>
      <title>Installation de GnuCOBOL avec GNULinux</title>
      <link>https://www.wikiod.com/fr/cobol/installation-de-gnucobol-avec-gnulinux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/installation-de-gnucobol-avec-gnulinux/</guid>
      <description>Installation GNU/Linux # Pour la plupart des distributions GNU/Linux, une version de GnuCOBOL est disponible dans les dépôts. GnuCOBOL était à l&amp;rsquo;origine OpenCOBOL, renommé lorsque le projet est devenu un projet GNU officiel. De nombreux référentiels utilisent encore open-cobol comme nom de package (en août 2016).
Pour Fedora et d&amp;rsquo;autres gestionnaires de paquets basés sur RPM
sudo yum install open-cobol Pour les packages basés sur Debian, Ubuntu et APT
sudo apt install open-cobol Il s&amp;rsquo;agit généralement de la version 1.</description>
    </item>
    
    <item>
      <title>Instruction ALTER</title>
      <link>https://www.wikiod.com/fr/cobol/instruction-alter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/instruction-alter/</guid>
      <description>La déclaration ALTER bien-aimée. Modifie la cible d&amp;rsquo;un paragraphe ALLER À.
Ne fait plus partie du standard COBOL, toujours pris en charge par de nombreux compilateurs pour des raisons de compatibilité descendante. (Le diagramme de syntaxe est grisé pour montrer qu&amp;rsquo;il ne s&amp;rsquo;agit plus de COBOL standard).
[![entrez la description de l&amp;rsquo;image ici][1]][1]
[1] : http://i.stack.imgur.com/ytIYo.png
Un exemple artificiel utilisant ALTER # identification division. program-id. altering. date-written. 2015-10-28/06:36-0400. remarks. Demonstrate ALTER.</description>
    </item>
    
    <item>
      <title>ACCEPTER l&#39;instruction</title>
      <link>https://www.wikiod.com/fr/cobol/accepter-linstruction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/accepter-linstruction/</guid>
      <description>L&amp;rsquo;instruction COBOL ACCEPT est utilisée pour récupérer les données du système.
[![ACCEPTER instruction][1]][1]
[1] : http://i.stack.imgur.com/DdpJO.png
ACCEPTER l&amp;rsquo;instruction # ACCEPT variable. ACCEPT variable FROM CONSOLE. ACCEPT variable FROM ENVIRONMENT &amp;quot;path&amp;quot;. ACCEPT variable FROM COMMAND-LINE. ACCEPT variable FROM ARGUMENT-NUMBER ACCEPT variable FROM ARGUMENT-VALUE ACCEPT variable AT 0101. ACCEPT screen-variable. ACCEPT today FROM DATE. ACCEPT today FROM DATE YYYYMMDD. ACCEPT thetime FROM TIME. ACCEPT theday FROM DAY. ACCEPT theday FROM DAY YYYYDDD. ACCEPT weekday FROM DAY-OF-WEEK.</description>
    </item>
    
    <item>
      <title>Déclaration de sortie</title>
      <link>https://www.wikiod.com/fr/cobol/declaration-de-sortie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/declaration-de-sortie/</guid>
      <description>L&amp;rsquo;instruction COBOL EXIT est un verbe de contrôle de flux de terminaison.
EXIT vient en quelques saveurs :
&amp;ldquo;EXIT&amp;rdquo; nu est un point final commun pour une série de procédures. EXIT PARAGRAPH, EXIT SECTION fournit un moyen de quitter une procédure structurée sans exécuter aucune des instructions suivantes. EXIT FUNCTION, EXIT METHOD, EXIT PROGRAM marque la fin logique d&amp;rsquo;un module de code. EXIT PERFORM sort d&amp;rsquo;une boucle d&amp;rsquo;exécution en ligne. EXIT PERFORM CYCLE provoque une boucle d&amp;rsquo;exécution en ligne pour commencer l&amp;rsquo;itération suivante.</description>
    </item>
    
    <item>
      <title>Instruction DEBUT</title>
      <link>https://www.wikiod.com/fr/cobol/instruction-debut/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/instruction-debut/</guid>
      <description>L&amp;rsquo;instruction START fournit un moyen de positionner une lecture dans un fichier pour une récupération séquentielle ultérieure (par clé).
[![Diagramme de syntaxe de l&amp;rsquo;instruction START][1]][1]
Le relationnel clé peut inclure (mais n&amp;rsquo;est pas limité à) :
LA CLÉ EST PLUS GRANDE QUE
LA CLÉ EST &amp;gt;
LA CLÉ EST INFÉRIEURE À
LA CLE EST &amp;lt;
LA CLÉ EST ÉGALE À
CLÉ EST =
LA CLÉ N&amp;rsquo;EST PAS PLUS GRANDE QUE</description>
    </item>
    
    <item>
      <title>Instruction ÉCRIRE</title>
      <link>https://www.wikiod.com/fr/cobol/instruction-ecrire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/instruction-ecrire/</guid>
      <description>L&amp;rsquo;instruction &amp;lsquo;WRITE&amp;rsquo; libère des enregistrements logiques vers une ressource de stockage &amp;lsquo;output&amp;rsquo; ou &amp;lsquo;input-output&amp;rsquo;, et pour le positionnement logique des lignes dans une page logique.
ECRITURE séquentielle
[![WRITE diagramme de syntaxe séquentielle][1]][1]
ÉCRIRE au hasard
[![WRITE diagramme de syntaxe aléatoire][2]][2]
[1] : https://i.stack.imgur.com/iKYKy.png [2] : https://i.stack.imgur.com/4lqh5.png
ÉCRIRE exemples # WRITE record-buff WRITE indexed-record WITH LOCK ON INVALID KEY DISPLAY &amp;quot;Key exists, REWRITING...&amp;quot; END-DISPLAY PERFORM rewrite-key END-WRITE IF indexed-file-status NOT EQUAL ZERO THEN DISPLAY &amp;quot;Write problem: &amp;quot; indexed-file-status UPON SYSERR END-DISPLAY PERFORM evasive-manoeuvres END-IF WRITE record-name-1 AFTER ADVANCING PAGE WRITE record-name-1 FROM header-record-1 AFTER ADVANCING 2 LINES AT END-OF-PAGE PERFORM write-page-header PERFORM write-last-detail-reminder END-WRITE </description>
    </item>
    
    <item>
      <title>Fonctions intrinsèques</title>
      <link>https://www.wikiod.com/fr/cobol/fonctions-intrinseques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/fonctions-intrinseques/</guid>
      <description>Les fonctions intrinsèques sont incluses dans la norme COBOL en tant qu&amp;rsquo;ensemble de fonctions qui renvoient des valeurs à partir d&amp;rsquo;un algorithme spécifique, avec zéro ou plusieurs arguments. Ces fonctions intrinsèques sont fournies en tant qu&amp;rsquo;installation du compilateur et du système d&amp;rsquo;exécution. Les éléments de retour sont des champs COBOL temporaires et peuvent être des données de caractères, des champs de bits ou des valeurs numériques.
Les exemples incluent les fonctions trigonométriques, les routines de date et d&amp;rsquo;heure, les conversions de type de données, l&amp;rsquo;écart type et d&amp;rsquo;autres algorithmes de support.</description>
    </item>
    
    <item>
      <title>Instruction CONTINUER</title>
      <link>https://www.wikiod.com/fr/cobol/instruction-continuer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/cobol/instruction-continuer/</guid>
      <description>L&amp;rsquo;instruction CONTINUE entraîne la poursuite du flux de contrôle à l&amp;rsquo;instruction suivante. Pas tout à fait un non-op, car il peut influencer le flux de contrôle lorsqu&amp;rsquo;il se trouve à l&amp;rsquo;intérieur de séquences d&amp;rsquo;instructions composées, en particulier IF/THEN/ELSE.
[![entrez la description de l&amp;rsquo;image ici][1]][1]
[1] : http://i.stack.imgur.com/xZ1Kz.png
Un pratique ? exemple au début du développement et de la construction avec et sans aides au débogage.
CALL &amp;quot;CBL_OC_DUMP&amp;quot; USING structure ON EXCEPTION CONTINUE END-CALL Ce code, bien que coûteux, autorisera les vidages mémoire formatés lorsque le module CBL_OC_DUMP est lié à l&amp;rsquo;exécutable, mais échouera sans danger lorsqu&amp;rsquo;il ne l&amp;rsquo;est pas.</description>
    </item>
    
  </channel>
</rss>
