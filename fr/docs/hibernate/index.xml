<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hiberner Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/hibernate/</link>
    <description>Recent content in Hiberner Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/hibernate/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec l&#39;hibernation</title>
      <link>https://www.wikiod.com/fr/hibernate/premiers-pas-avec-lhibernation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/premiers-pas-avec-lhibernation/</guid>
      <description>Utilisation de la configuration XML pour configurer Hibernate # Je crée un fichier appelé database-servlet.xml quelque part sur le classpath.
Au départ, votre fichier de configuration ressemblera à ceci :
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt; &amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:jdbc=&amp;quot;http://www.springframework.org/schema/jdbc&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot; xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd&amp;quot;&amp;gt; &amp;lt;/beans&amp;gt; Vous remarquerez que j&amp;rsquo;ai importé les espaces de noms Spring tx et jdbc. C&amp;rsquo;est parce que nous allons les utiliser assez fortement dans ce fichier de configuration.</description>
    </item>
    
    <item>
      <title>Stratégie de dénomination personnalisée</title>
      <link>https://www.wikiod.com/fr/hibernate/strategie-de-denomination-personnalisee/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/strategie-de-denomination-personnalisee/</guid>
      <description>Création et utilisation d&amp;rsquo;une stratégie de dénomination implicite personnalisée # La création d&amp;rsquo;une [ImplicitNamingStrategy][1] personnalisée vous permet de modifier la façon dont Hibernate attribuera des noms aux attributs Entity non explicitement nommés, y compris les clés étrangères, les clés uniques, les colonnes d&amp;rsquo;identification, les colonnes de base, etc.
Par exemple, par défaut, Hibernate générera des clés étrangères qui sont hachées et ressemblent à :
FKe6hidh4u0qh8y1ijy59s2ee6m Bien que ce ne soit souvent pas un problème, vous souhaiterez peut-être que le nom soit plus descriptif, par exemple :</description>
    </item>
    
    <item>
      <title>ActiverDésactiver le journal SQL</title>
      <link>https://www.wikiod.com/fr/hibernate/activerdesactiver-le-journal-sql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/activerdesactiver-le-journal-sql/</guid>
      <description>La journalisation de ces requêtes est ** lente **, encore plus lente qu&amp;rsquo;Hibernate ne l&amp;rsquo;est habituellement. Il utilise également une énorme quantité d&amp;rsquo;espace de journalisation. N&amp;rsquo;utilisez pas la journalisation dans les scénarios où les performances sont requises. Utilisez-le uniquement lorsque vous testez les requêtes générées par Hibernate.
Utilisation d&amp;rsquo;un fichier de configuration de journalisation # Dans le fichier de configuration de journalisation de votre choix, définissez la journalisation des packages suivants sur les niveaux indiqués :</description>
    </item>
    
    <item>
      <title>Hiberner les relations d&#39;entité à l&#39;aide d&#39;annotations</title>
      <link>https://www.wikiod.com/fr/hibernate/hiberner-les-relations-dentite-a-laide-dannotations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/hiberner-les-relations-dentite-a-laide-dannotations/</guid>
      <description>Paramètres # Annotation Détails @OneToOne Spécifie une relation un à un avec un objet correspondant. @OneToMany Spécifie un seul objet qui correspond à plusieurs objets. @ManyToOne Spécifie une collection d&amp;rsquo;objets mappés à un seul objet. @Entité Spécifie un objet mappé à une table de base de données. @Table Spécifie à quelle table de base de données cet objet correspond également. @JoinColumn Spécifie dans quelle colonne une clé étrangère est stockée. @JoinTable Spécifie une table intermédiaire qui stocke les clés étrangères.</description>
    </item>
    
    <item>
      <title>L&#39;optimisation des performances</title>
      <link>https://www.wikiod.com/fr/hibernate/loptimisation-des-performances/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/loptimisation-des-performances/</guid>
      <description>Utiliser la composition au lieu de l&amp;rsquo;héritage # Hibernate a quelques stratégies d&amp;rsquo;héritage. Le type d&amp;rsquo;héritage JOINED fait un JOIN entre l&amp;rsquo;entité enfant et l&amp;rsquo;entité parent.
Le problème avec cette approche est que Hibernate toujours apporte les données de toutes les tables impliquées dans l&amp;rsquo;héritage.
Par exemple, si vous avez les entités Bicycle et MountainBike utilisant le type d&amp;rsquo;héritage JOINED :
@Entity @Inheritance(strategy = InheritanceType.JOINED) public abstract class Bicycle { } Et:</description>
    </item>
    
    <item>
      <title>Chargement paresseux vs chargement impatient</title>
      <link>https://www.wikiod.com/fr/hibernate/chargement-paresseux-vs-chargement-impatient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/chargement-paresseux-vs-chargement-impatient/</guid>
      <description>Chargement paresseux vs chargement impatient # La récupération ou le chargement de données peuvent être principalement classés en deux types : impatients et paresseux.
Pour utiliser Hibernate, assurez-vous d&amp;rsquo;en ajouter la dernière version à la section des dépendances de votre fichier pom.xml :
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hibernate-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.1.Final&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; **1. Chargement impatient et chargement paresseux **
La première chose dont nous devrions discuter ici est ce que sont le chargement paresseux et le chargement impatient :</description>
    </item>
    
    <item>
      <title>Mise en cache</title>
      <link>https://www.wikiod.com/fr/hibernate/mise-en-cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/mise-en-cache/</guid>
      <description>Activation de la mise en cache Hibernate dans WildFly # Pour activer [Second Level Caching][1] pour Hibernate dans WildFly, ajoutez cette propriété à votre fichier persistence.xml :
&amp;lt;property name=&amp;quot;hibernate.cache.use_second_level_cache&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; Vous pouvez également activer [Query Caching][1] avec cette propriété :
&amp;lt;property name=&amp;quot;hibernate.cache.use_query_cache&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt; WildFly ne vous oblige pas à définir un fournisseur de cache lors de l&amp;rsquo;activation du cache de second niveau d&amp;rsquo;Hibernate, car Infinispan est utilisé par défaut. Cependant, si vous souhaitez utiliser un fournisseur de cache alternatif, vous pouvez le faire avec la propriété hibernate.</description>
    </item>
    
    <item>
      <title>Critères et projections</title>
      <link>https://www.wikiod.com/fr/hibernate/criteres-et-projections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/criteres-et-projections/</guid>
      <description>Utiliser des filtres # @Filter est utilisé comme camp WHERE, voici quelques exemples
Entité étudiante
@Entity @Table(name = &amp;quot;Student&amp;quot;) public class Student { /*...*/ @OneToMany @Filter(name = &amp;quot;active&amp;quot;, condition = &amp;quot;EXISTS(SELECT * FROM Study s WHERE state = true and s.id = study_id)&amp;quot;) Set&amp;lt;StudentStudy&amp;gt; studies; /* getters and setters methods */ } Entité d&amp;rsquo;étude
@Entity @Table(name = &amp;quot;Study&amp;quot;) @FilterDef(name = &amp;quot;active&amp;quot;) @Filter(name = &amp;quot;active&amp;quot;, condition=&amp;quot;state = true&amp;quot;) public class Study { /*.</description>
    </item>
    
    <item>
      <title>Hibernation et JPA</title>
      <link>https://www.wikiod.com/fr/hibernate/hibernation-et-jpa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/hibernation-et-jpa/</guid>
      <description>Relation entre Hibernate et JPA # Hibernate est une implémentation de la norme [JPA][1]. En tant que tel, tout ce qui y est dit est également vrai pour Hibernate.
Hibernate a quelques extensions pour JPA. De plus, la façon de configurer un fournisseur JPA est spécifique au fournisseur. Cette section de documentation ne doit contenir que ce qui est spécifique à Hibernate.
[1] : https://www.wikiod.com/fr/jpa/premiers-pas-avec-jpa#Installation ou configuration</description>
    </item>
    
    <item>
      <title>Requêtes SQL natives</title>
      <link>https://www.wikiod.com/fr/hibernate/requetes-sql-natives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/hibernate/requetes-sql-natives/</guid>
      <description>Requête simple # En supposant que vous ayez un handle sur l&amp;rsquo;objet Hibernate Session, dans ce cas nommé session :
List&amp;lt;Object[]&amp;gt; result = session.createNativeQuery(&amp;quot;SELECT * FROM some_table&amp;quot;).list(); for (Object[] row : result) { for (Object col : row) { System.out.print(col); } } Cela récupérera toutes les lignes dans some_table et les placera dans la variable result et imprimera chaque valeur.
Exemple pour obtenir un résultat unique # Object pollAnswered = getCurrentSession().</description>
    </item>
    
  </channel>
</rss>
