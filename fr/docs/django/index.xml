<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel Django on </title>
    <link>https://www.wikiod.com/fr/docs/django/</link>
    <description>Recent content in Tutoriel Django on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec Django</title>
      <link>https://www.wikiod.com/fr/django/debuter-avec-django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/debuter-avec-django/</guid>
      <description>Démarrer un projet # Django est un framework de développement web basé sur Python. Django 1.11 (la dernière version stable) nécessite l&amp;rsquo;installation de Python 2.7, 3.4, 3.5 ou 3.6. En supposant que pip est disponible, l&amp;rsquo;installation est aussi simple que d&amp;rsquo;exécuter la commande suivante. Gardez à l&amp;rsquo;esprit que l&amp;rsquo;omission de la version comme indiqué ci-dessous installera la dernière version de django :
$ pip install django Pour installer une version spécifique de django, supposons que la version soit django 1.</description>
    </item>
    
    <item>
      <title>Commandes de gestion</title>
      <link>https://www.wikiod.com/fr/django/commandes-de-gestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/commandes-de-gestion/</guid>
      <description>Les commandes de gestion sont des scripts puissants et flexibles qui peuvent effectuer des actions sur votre projet Django ou la base de données sous-jacente. En plus des diverses commandes par défaut, il est possible d&amp;rsquo;écrire les vôtres !
Par rapport aux scripts Python classiques, l&amp;rsquo;utilisation du cadre de commande de gestion signifie qu&amp;rsquo;un travail de configuration fastidieux est automatiquement effectué pour vous dans les coulisses.
Les commandes de gestion peuvent être appelées soit depuis :</description>
    </item>
    
    <item>
      <title>Des modèles</title>
      <link>https://www.wikiod.com/fr/django/des-modeles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/des-modeles/</guid>
      <description>Dans le cas de base, un modèle est une classe Python qui correspond à une seule table de base de données. Les attributs de la classe correspondent aux colonnes de la table et une instance de la classe représente une ligne dans la table de la base de données. Les modèles héritent de django.db.models.Model qui fournit une API riche pour ajouter et filtrer les résultats de la base de données.</description>
    </item>
    
    <item>
      <title>Intergiciel</title>
      <link>https://www.wikiod.com/fr/django/intergiciel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/intergiciel/</guid>
      <description>L&amp;rsquo;intergiciel de Django est un framework qui permet au code de s&amp;rsquo;accrocher au traitement des réponses/requêtes et de modifier l&amp;rsquo;entrée ou la sortie de Django.
Le middleware doit être ajouté à votre liste settings.py MIDDLEWARE_CLASSES avant d&amp;rsquo;être inclus dans l&amp;rsquo;exécution. La liste par défaut fournie par Django lors de la création d&amp;rsquo;un nouveau projet est la suivante :
MIDDLEWARE_CLASSES = [ &#39;django.middleware.security.SecurityMiddleware&#39;, &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;django.middleware.common.CommonMiddleware&#39;, &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, &#39;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#39;, &#39;django.contrib.messages.middleware.MessageMiddleware&#39;, &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;, ] Ce sont toutes les fonctions qui s&amp;rsquo;exécuteront dans ** l&amp;rsquo;ordre ** à chaque requête (une fois avant qu&amp;rsquo;elle n&amp;rsquo;atteigne votre code de vue dans views.</description>
    </item>
    
    <item>
      <title>Réglages</title>
      <link>https://www.wikiod.com/fr/django/reglages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/reglages/</guid>
      <description>Masquer des données secrètes à l&amp;rsquo;aide d&amp;rsquo;un fichier JSON # Lors de l&amp;rsquo;utilisation d&amp;rsquo;un VCS tel que Git ou SVN, certaines données secrètes ne doivent jamais être versionnées (que le référentiel soit public ou privé).
Parmi ces données, vous trouverez le paramètre SECRET_KEY et le mot de passe de la base de données.
Une pratique courante pour masquer ces paramètres du contrôle de version consiste à créer un fichier secrets.json à la racine de votre projet ([merci &amp;ldquo;Two Scoops of Django&amp;rdquo; pour l&amp;rsquo;idée][1]):</description>
    </item>
    
    <item>
      <title>Routage d&#39;URL</title>
      <link>https://www.wikiod.com/fr/django/routage-durl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/routage-durl/</guid>
      <description>Définir l&amp;rsquo;espace de noms d&amp;rsquo;URL pour une application réutilisable (Django 1.9+) # Configurez l&amp;rsquo;URLconf de votre application pour qu&amp;rsquo;elle utilise automatiquement un espace de noms d&amp;rsquo;URL en définissant l&amp;rsquo;attribut app_name :
# In &amp;lt;myapp&amp;gt;/urls.py from django.conf.urls import url from .views import overview app_name = &#39;myapp&#39; urlpatterns = [ url(r&#39;^$&#39;, overview, name=&#39;overview&#39;), ] Cela définira l&amp;rsquo;espace de noms de l&amp;rsquo;application sur &#39;myapp&#39; lorsqu&amp;rsquo;il est inclus dans l&amp;rsquo;URLconf racine &amp;gt;. L&amp;rsquo;utilisateur de votre application réutilisable n&amp;rsquo;a pas besoin d&amp;rsquo;effectuer de configuration autre que d&amp;rsquo;inclure vos URL :</description>
    </item>
    
    <item>
      <title>Backends d&#39;authentification</title>
      <link>https://www.wikiod.com/fr/django/backends-dauthentification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/backends-dauthentification/</guid>
      <description>Backend d&amp;rsquo;authentification des e-mails # L&amp;rsquo;authentification par défaut de Django fonctionne sur les champs username et password. Le backend d&amp;rsquo;authentification par e-mail authentifiera les utilisateurs en fonction de l&amp;rsquo;&amp;ldquo;e-mail&amp;rdquo; et du &amp;ldquo;mot de passe&amp;rdquo;.
from django.contrib.auth import get_user_model class EmailBackend(object): &amp;quot;&amp;quot;&amp;quot; Custom Email Backend to perform authentication via email &amp;quot;&amp;quot;&amp;quot; def authenticate(self, username=None, password=None): user_model = get_user_model() try: user = user_model.objects.get(email=username) if user.check_password(password): # check valid password return user # return user to be authenticated except user_model.</description>
    </item>
    
    <item>
      <title>ArrayField - un champ spécifique à PostgreSQL</title>
      <link>https://www.wikiod.com/fr/django/arrayfield---un-champ-specifique-a-postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/arrayfield---un-champ-specifique-a-postgresql/</guid>
      <description>Syntaxe # depuis django.contrib.postgres.fields importer ArrayField classe ArrayField(base_field, size=None, **options) FooModel.objects.filter(array_field_name__contains=[objects, to, check]) FooModel.objects.filter(array_field_name__contained_by=[objects, to, check]) Notez que bien que le paramètre size soit passé à PostgreSQL, PostgreSQL ne l&amp;rsquo;appliquera pas.
Lorsque vous utilisez ArrayField, gardez à l&amp;rsquo;esprit ce mot d&amp;rsquo;avertissement de la [documentation des tableaux Postgresql][1].
Astuce : les tableaux ne sont pas des ensembles ; la recherche d&amp;rsquo;éléments de tableau spécifiques peut être un signe de mauvaise conception de la base de données.</description>
    </item>
    
    <item>
      <title>Modèles</title>
      <link>https://www.wikiod.com/fr/django/modeles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/modeles/</guid>
      <description>Empêcher les méthodes sensibles d&amp;rsquo;être appelées dans les modèles # Lorsqu&amp;rsquo;un objet est exposé au contexte du modèle, ses méthodes sans arguments sont disponibles. Ceci est utile lorsque ces fonctions sont des &amp;ldquo;getters&amp;rdquo;. Mais cela peut être dangereux si ces méthodes modifient certaines données ou ont des effets secondaires. Même si vous faites probablement confiance à l&amp;rsquo;auteur du modèle, il peut ne pas être conscient des effets secondaires d&amp;rsquo;une fonction ou penser appeler le mauvais attribut par erreur.</description>
    </item>
    
    <item>
      <title>Ensembles de requêtes</title>
      <link>https://www.wikiod.com/fr/django/ensembles-de-requetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/django/ensembles-de-requetes/</guid>
      <description>Un Queryset est fondamentalement une liste d&amp;rsquo;objets dérivés d&amp;rsquo;un Model, par une compilation de requêtes de base de données.
Réduire le nombre de requêtes sur le champ ForeignKey (problème n+1) # Problème # Les ensembles de requêtes Django sont évalués de manière paresseuse. Par exemple:
# models.py: class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): author = models.ForeignKey(Author, related_name=&#39;books&#39;) title = models.CharField(max_length=100) # views.py def myview(request): # Query the database books = Book.</description>
    </item>
    
  </channel>
</rss>
