<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel common-lisp on </title>
    <link>https://www.wikiod.com/fr/docs/common-lisp/</link>
    <description>Recent content in Tutoriel common-lisp on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec common-lisp</title>
      <link>https://www.wikiod.com/fr/common-lisp/premiers-pas-avec-common-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/premiers-pas-avec-common-lisp/</guid>
      <description>Ressources d&amp;rsquo;apprentissage Common Lisp # Livres en ligne
Ce sont des livres librement accessibles en ligne.
Practical Common Lisp par Peter Seibel est une bonne introduction à CL pour les programmeurs expérimentés, qui tente de mettre en évidence dès le début ce qui rend CL différent des autres langages. Common Lisp: A Gentle Introduction to Symbolic Computation by David S. Touretzky est une bonne introduction pour les débutants en programmation. Common Lisp : Une approche interactive par Stuart C.</description>
    </item>
    
    <item>
      <title>ASDF - Une autre installation de définition de système</title>
      <link>https://www.wikiod.com/fr/common-lisp/asdf---une-autre-installation-de-definition-de-systeme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/asdf---une-autre-installation-de-definition-de-systeme/</guid>
      <description>[ASDF - Une autre installation de définition de système] [1]
[1] : https://common-lisp.net/project/asdf/
ASDF est un outil permettant de spécifier comment les systèmes du logiciel Common Lisp sont constitués de composants (sous-systèmes et fichiers), et comment opérer sur ces composants dans le bon ordre afin qu&amp;rsquo;ils puissent être compilés, chargés, testés, etc.
Système ASDF simple avec une structure de répertoire plate # Considérez ce projet simple avec une structure de répertoire plate :</description>
    </item>
    
    <item>
      <title>ANSI Common Lisp, la norme de langage et sa documentation</title>
      <link>https://www.wikiod.com/fr/common-lisp/ansi-common-lisp-la-norme-de-langage-et-sa-documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/ansi-common-lisp-la-norme-de-langage-et-sa-documentation/</guid>
      <description>Common Lisp HyperSpec # Common Lisp a une norme, qui a été initialement publiée en 1994 en tant que norme ANSI.
Le [Common Lisp HyperSpec][1], abrégé CLHS, fourni par [LispWorks][2] est une documentation HTML souvent utilisée, dérivée du document standard. [L&amp;rsquo;HyperSpec peut également être téléchargé et utilisé localement][3].
Les environnements de développement Common Lisp permettent généralement de consulter la documentation HyperSpec pour les symboles Lisp.
Pour [GNU Emacs][4] il y a [clhs.</description>
    </item>
    
    <item>
      <title>macros</title>
      <link>https://www.wikiod.com/fr/common-lisp/macros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/macros/</guid>
      <description>Le but des macros # Les macros sont destinées à générer du code, à transformer du code et à fournir de nouvelles notations. Ces nouvelles notations peuvent être plus adaptées pour mieux exprimer le programme, par exemple en fournissant des constructions au niveau du domaine ou de nouveaux langages intégrés.
Les macros peuvent rendre le code source plus explicite, mais le débogage peut être rendu plus difficile. En règle générale, il ne faut pas utiliser de macros lorsqu&amp;rsquo;une fonction normale suffit.</description>
    </item>
    
    <item>
      <title>CLOS - le système d&#39;objets Common Lisp</title>
      <link>https://www.wikiod.com/fr/common-lisp/clos---le-systeme-dobjets-common-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/clos---le-systeme-dobjets-common-lisp/</guid>
      <description>Mixins et interfaces # Common Lisp n&amp;rsquo;a pas d&amp;rsquo;interfaces au sens de certains langages (par exemple, Java), et ce type d&amp;rsquo;interface est moins nécessaire étant donné que Common Lisp prend en charge plusieurs fonctions d&amp;rsquo;héritage et génériques. Cependant, le même type de motifs peut être réalisé facilement en utilisant des classes mixin. Cet exemple montre la spécification d&amp;rsquo;une interface de collection avec plusieurs fonctions génériques correspondantes.
;; Specification of the COLLECTION &amp;quot;interface&amp;quot; (defclass collection () () (:documentation &amp;quot;A collection mixin.</description>
    </item>
    
    <item>
      <title>Travailler avec SLIME</title>
      <link>https://www.wikiod.com/fr/common-lisp/travailler-avec-slime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/travailler-avec-slime/</guid>
      <description>Utilisation de REPL # CL-USER&amp;gt; (+ 2 3) 5 CL-USER&amp;gt; (sin 1.5) 0.997495 CL-USER&amp;gt; (mapcar (lambda (x) (+ x 2)) &#39;(1 2 3)) (3 4 5) Le résultat qui est imprimé après l&amp;rsquo;évaluation n&amp;rsquo;est pas seulement une chaîne : il y a un objet Lisp complet derrière qui peut être inspecté en cliquant dessus avec le bouton droit de la souris et en choisissant Inspecter.
La saisie multiligne est également possible : utilisez C-j pour insérer une nouvelle ligne.</description>
    </item>
    
    <item>
      <title>format</title>
      <link>https://www.wikiod.com/fr/common-lisp/format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/format/</guid>
      <description>Paramètres # Liste Lambda (format DESTINATION CONTROL-STRING &amp;amp;REST FORMAT-ARGUMENTS) DESTINATION la chose à écrire. Cela peut être un flux de sortie, t (raccourci pour *standard-output*), ou nil (qui crée une chaîne dans laquelle écrire) CHAÎNE-CONTRÔLE la chaîne de modèle. Il peut s&amp;rsquo;agir d&amp;rsquo;une chaîne primitive ou elle peut contenir des directives de commande préfixées par tilde qui spécifient et transforment d&amp;rsquo;une manière ou d&amp;rsquo;une autre des arguments supplémentaires. FORMAT-ARGUMENTS arguments supplémentaires potentiels requis par le CONTROL-STRING donné.</description>
    </item>
    
    <item>
      <title>LOOP, une macro Common Lisp pour l&#39;itération</title>
      <link>https://www.wikiod.com/fr/common-lisp/loop-une-macro-common-lisp-pour-literation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/loop-une-macro-common-lisp-pour-literation/</guid>
      <description>Itération parallèle # Plusieurs clauses FOR sont autorisées dans une LOOP. La boucle se termine lorsque la première de ces clauses se termine :
(loop for a in &#39;(1 2 3 4 5) for b in &#39;(a b c) collect (list a b)) ;; Evaluates to: ((1 a) (2 b) (3 c)) D&amp;rsquo;autres clauses qui déterminent si la boucle doit continuer peuvent être combinées :
(loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) collect a) ;; Evaluates to: (1 2 3) (loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) repeat 1 collect a) ;; Evaluates to: (1) Déterminez quelle liste est la plus longue, en coupant l&amp;rsquo;itération dès que la réponse est connue :</description>
    </item>
    
    <item>
      <title>Contre les cellules et les listes</title>
      <link>https://www.wikiod.com/fr/common-lisp/contre-les-cellules-et-les-listes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/contre-les-cellules-et-les-listes/</guid>
      <description>Qu&amp;rsquo;est-ce qu&amp;rsquo;une cellule contre ? # Une contre-cellule, également connue sous le nom de paire pointillée (en raison de sa représentation imprimée), est simplement une paire de deux objets. Une cellule cons est créée par la fonction cons et les éléments de la paire sont extraits à l&amp;rsquo;aide des fonctions car et cdr.
(cons &amp;quot;a&amp;quot; 4) Par exemple, cela renvoie une paire dont le premier élément (qui peut être extrait avec car) est &amp;quot;a&amp;quot;, et dont le deuxième élément (qui peut être extrait avec cdr) est 4.</description>
    </item>
    
    <item>
      <title>séquence - comment diviser une séquence</title>
      <link>https://www.wikiod.com/fr/common-lisp/sequence---comment-diviser-une-sequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/common-lisp/sequence---comment-diviser-une-sequence/</guid>
      <description>Syntaxe # split regex target-string &amp;amp; key start end limit with-registers-p omit-unmatched-p sharedp =&amp;gt; list lispworks : séquence de séparateurs de séquences séparées et clé de test de début de fin de clé coalesce-separators =&amp;gt; séquences séquence délimiteur de séquence fractionnée séquence &amp;amp; clé début fin de-fin compter supprimer-vide-sous-seqs test test-pas clé =&amp;gt; liste des sous-séquences Séparer les chaînes à l&amp;rsquo;aide d&amp;rsquo;expressions régulières # La bibliothèque CL-PPCRE fournit la fonction split qui nous permet de diviser les chaînes en sous-chaînes qui correspondent à une expression régulière, en supprimant les parties de la chaîne qui ne correspondent pas.</description>
    </item>
    
  </channel>
</rss>
