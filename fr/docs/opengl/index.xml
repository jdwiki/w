<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel opengl on </title>
    <link>https://www.wikiod.com/fr/docs/opengl/</link>
    <description>Recent content in Tutoriel opengl on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/opengl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec opengl</title>
      <link>https://www.wikiod.com/fr/opengl/debuter-avec-opengl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/debuter-avec-opengl/</guid>
      <description>Configuration manuelle d&amp;rsquo;OpenGL sous Windows # Exemple de code complet inclus à la fin * Composants Windows pour OpenGL WGL WGL (peut être prononcé wiggle) signifie &amp;ldquo;Windows-GL&amp;rdquo;, comme dans &amp;ldquo;une interface entre Windows et OpenGL&amp;rdquo; - un ensemble de fonctions de l&amp;rsquo;API Windows pour communiquer avec OpenGL. Les fonctions WGL ont un préfixe wgl et ses jetons ont un préfixe WGL_.
La version par défaut d&amp;rsquo;OpenGL prise en charge sur les systèmes Microsoft est 1.</description>
    </item>
    
    <item>
      <title>Texturation</title>
      <link>https://www.wikiod.com/fr/opengl/texturation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/texturation/</guid>
      <description>Bases de la texturation # Une texture est une forme de stockage de données qui permet un accès pratique non seulement à des entrées de données particulières, mais également à des points d&amp;rsquo;échantillonnage mélangeant (interpolant) plusieurs entrées ensemble.
Dans OpenGL, les textures peuvent être utilisées pour beaucoup de choses, mais le plus souvent, il s&amp;rsquo;agit de mapper une image sur un polygone (par exemple un triangle). Afin de mapper la texture sur un triangle (ou un autre polygone), nous devons indiquer à chaque sommet à quelle partie de la texture il correspond.</description>
    </item>
    
    <item>
      <title>Encapsuler des objets OpenGL avec C&#43;&#43; RAII</title>
      <link>https://www.wikiod.com/fr/opengl/encapsuler-des-objets-opengl-avec-c-raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/encapsuler-des-objets-opengl-avec-c-raii/</guid>
      <description>Exemples de différentes façons de faire fonctionner des objets OpenGL avec C++ RAII.
L&amp;rsquo;encapsulation RAII des objets OpenGL présente des dangers. Le plus inévitable est que les objets OpenGL sont associés au contexte OpenGL qui les a créés. Ainsi, la destruction d&amp;rsquo;un objet C++ RAII doit être effectuée dans un contexte OpenGL qui partage la propriété de l&amp;rsquo;objet OpenGL géré par cet objet C++.
Cela signifie également que si tous les contextes qui possèdent l&amp;rsquo;objet sont détruits, alors tous les objets OpenGL encapsulés RAII existants essaieront de détruire les objets qui n&amp;rsquo;existent plus.</description>
    </item>
    
    <item>
      <title>Mathématiques 3D</title>
      <link>https://www.wikiod.com/fr/opengl/mathematiques-3d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/mathematiques-3d/</guid>
      <description>Introduction aux matrices # Lorsque vous programmez en OpenGL ou dans toute autre API graphique, vous vous heurtez à un mur de briques lorsque vous n&amp;rsquo;êtes pas très bon en mathématiques. Ici, je vais vous expliquer avec un exemple de code comment vous pouvez réaliser un mouvement/mise à l&amp;rsquo;échelle et bien d&amp;rsquo;autres trucs sympas avec votre objet 3D.
Prenons un cas réel&amp;hellip; Vous avez créé un cube impressionnant (en trois dimensions) dans OpenGL et vous voulez le déplacer dans n&amp;rsquo;importe quelle direction.</description>
    </item>
    
    <item>
      <title>Éclairage de base</title>
      <link>https://www.wikiod.com/fr/opengl/eclairage-de-base/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/eclairage-de-base/</guid>
      <description>Modèle d&amp;rsquo;éclairage Phong # REMARQUE : Cet exemple est WIP, il sera mis à jour avec des diagrammes, des images, plus d&amp;rsquo;exemples, etc.
Qu&amp;rsquo;est-ce que Phong ?
Phong est un modèle d&amp;rsquo;éclairage très basique, mais d&amp;rsquo;apparence réelle, pour les surfaces, composé de trois parties : éclairage ambiant, diffus et spéculaire.
Éclairage ambiant:
L&amp;rsquo;éclairage ambiant est la plus simple des trois parties à comprendre et à calculer. L&amp;rsquo;éclairage ambiant est une lumière qui inonde la scène et éclaire l&amp;rsquo;objet uniformément dans toutes les directions.</description>
    </item>
    
    <item>
      <title>Shaders</title>
      <link>https://www.wikiod.com/fr/opengl/shaders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/shaders/</guid>
      <description>Syntaxe # #version version_number // Quelle version GLSL nous utilisons void main() { /* Code */ } // Fonction principale du shader dans le nom du type ; // Spécifie un paramètre d&amp;rsquo;entrée - GLSL 1.30 nom du type de sortie ; // Spécifie un paramètre de sortie - GLSL 1.30 nom du type d&amp;rsquo;entrée ; // Paramètre pour l&amp;rsquo;entrée et la sortie - GLSL 1.30 Paramètres # Paramètre Détails taper Le type du paramètre, il doit être un type intégré GLSL.</description>
    </item>
    
    <item>
      <title>Chargement et compilation des shaders</title>
      <link>https://www.wikiod.com/fr/opengl/chargement-et-compilation-des-shaders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/chargement-et-compilation-des-shaders/</guid>
      <description>Ces exemples montrent différentes manières de charger et de compiler des shaders. Tous les exemples doivent inclure le code de gestion des erreurs.
Les objets Shader, tels que créés à partir de glCreateShader ne font pas grand-chose. Ils contiennent le code compilé pour une seule étape, mais ils n&amp;rsquo;ont même pas besoin de contenir le code compilé complet pour cette étape. À bien des égards, ils fonctionnent comme des fichiers objet C et C++.</description>
    </item>
    
    <item>
      <title>Vue et projection OGL</title>
      <link>https://www.wikiod.com/fr/opengl/vue-et-projection-ogl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/vue-et-projection-ogl/</guid>
      <description>À propos de la matrice de modèle, de la matrice de vue, de la projection orthographique et en perspective
Implémenter une caméra dans OGL 4.0 GLSL 400 # Si nous voulons regarder une scène comme si nous l&amp;rsquo;avions photographiée avec un appareil photo, nous devons d&amp;rsquo;abord définir certaines choses :
La position à partir de laquelle la scène est vue, la position de l&amp;rsquo;œil &amp;lsquo;pos&amp;rsquo;. Le point que nous regardons dans la scène (&amp;rsquo;target&amp;rsquo;).</description>
    </item>
    
    <item>
      <title>Tampons de trame</title>
      <link>https://www.wikiod.com/fr/opengl/tampons-de-trame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/tampons-de-trame/</guid>
      <description>Notions de base sur les framebuffers # Framebuffer est un type de tampon qui stocke les valeurs de couleur, les informations de profondeur et de pochoir des pixels en mémoire. Lorsque vous dessinez quelque chose dans OpenGL, la sortie est stockée dans le * tampon de trame par défaut * et vous voyez alors les valeurs de couleur de ce tampon à l&amp;rsquo;écran. Vous pouvez également créer votre propre framebuffer qui peut être utilisé pour de nombreux effets de post-traitement sympas tels que * échelle de gris, flou, profondeur de champ, distorsions, reflets *&amp;hellip;</description>
    </item>
    
    <item>
      <title>Utilisation des VAO</title>
      <link>https://www.wikiod.com/fr/opengl/utilisation-des-vao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opengl/utilisation-des-vao/</guid>
      <description>L&amp;rsquo;objet Vertex Array stocke comment opengl doit interpréter un ensemble de VBO.
Essentiellement, cela vous évitera d&amp;rsquo;appeler glVertexAttribPointer chaque fois que vous souhaitez rendre un nouveau maillage.
Si vous ne voulez pas gérer les VAO, vous pouvez simplement en créer un et le lier lors de l&amp;rsquo;initialisation du programme et prétendre qu&amp;rsquo;ils n&amp;rsquo;existent pas.
Syntaxe # annuler glEnableVertexAttribArray​(GLuint attribIndex);
void glDisableVertexAttribArray​(GLuint attribIndex);
void glVertexAttribPointer(GLuint attribIndex, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);</description>
    </item>
    
  </channel>
</rss>
