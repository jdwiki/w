<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haxe Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/haxe/</link>
    <description>Recent content in haxe Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/haxe/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Commencer avec haxe</title>
      <link>https://www.wikiod.com/fr/haxe/commencer-avec-haxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/commencer-avec-haxe/</guid>
      <description>Bonjour le monde # Conditions # Une version de la boîte à outils Haxe doit être installée Haxe doit être présent dans votre chemin système La ligne de commande doit être accessible ##Code
Accédez au répertoire de projet souhaité et créez un fichier source &amp;ldquo;Test.hx&amp;rdquo; avec le contenu suivant :
class Test { static function main() { trace(&amp;quot;Hello world&amp;quot;); } } Les fichiers sources de Haxe sont appelés modules. Un module devrait définir un type (abstract, class, enum, interface ou typedef) avec le même identifiant que le nom du module - dans ce cas la classe Test.</description>
    </item>
    
    <item>
      <title>Énumérations</title>
      <link>https://www.wikiod.com/fr/haxe/enumerations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/enumerations/</guid>
      <description>Syntaxe # enum identifiant { constructeurs } Capture des valeurs d&amp;rsquo;énumération # Les valeurs transmises en tant qu&amp;rsquo;arguments du constructeur enum peuvent être capturées dans des variables à l&amp;rsquo;aide de [pattern matching][1].
Supposons l&amp;rsquo;énumération suivante :
enum Color { RGB(r : Int, g : Int, b : Int); HSV(h : Int, s : Float, v : Float); } La valeur du canal rouge peut être capturée comme suit :
var color = Color.</description>
    </item>
    
    <item>
      <title>Boucles</title>
      <link>https://www.wikiod.com/fr/haxe/boucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/boucles/</guid>
      <description>Syntaxe # for (identifiant de variable dans itérer la collection) { expression } tandis que (condition) { expression } faire { expression } tandis que (condition); Pause; Continuez; Pour # Les [boucles for][1] itèrent sur une collection itérative. Une collection itérative est une classe qui s&amp;rsquo;unifie structurellement avec les types Iterator&amp;lt;T&amp;gt; ou Iterable&amp;lt;T&amp;gt; de la bibliothèque standard Haxe.
Une boucle for qui enregistre les nombres compris entre 0 et 10 (exclusif) peut s&amp;rsquo;écrire comme suit :</description>
    </item>
    
    <item>
      <title>Correspondance de modèle</title>
      <link>https://www.wikiod.com/fr/haxe/correspondance-de-modele/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/correspondance-de-modele/</guid>
      <description>La correspondance de modèles est le processus de création de branches en fonction des modèles fournis. Toutes les correspondances de modèles sont effectuées dans une expression switch, et les expressions case individuelles représentent les modèles.
Les règles fondamentales du pattern matching sont :
les motifs seront toujours assortis de haut en bas ; le motif le plus élevé qui correspond à la valeur d&amp;rsquo;entrée voit son expression exécutée ; un motif _ correspond à n&amp;rsquo;importe quoi, donc case _: est égal à default:.</description>
    </item>
    
    <item>
      <title>Résumés</title>
      <link>https://www.wikiod.com/fr/haxe/resumes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/resumes/</guid>
      <description>Syntaxe # abstrait identifiant(type sous-jacent) { &amp;hellip; } abstrait identifiant(type sous-jacent) de typeA de typeB &amp;hellip; à typeA à typeB { &amp;hellip; } Un type abstrait est un type compile-time qui se résout en type sous-jacent au run-time. Cela signifie que le type abstrait n&amp;rsquo;existe pas dans le code source généré par le compilateur Haxe. À sa place sont placés le type sous-jacent ou les types définis pour le transtypage implicite.</description>
    </item>
    
    <item>
      <title>Ramification</title>
      <link>https://www.wikiod.com/fr/haxe/ramification/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/haxe/ramification/</guid>
      <description>Syntaxe # si (condition) { &amp;hellip; } si (condition) { &amp;hellip; } sinon { &amp;hellip; } si (condition) { &amp;hellip; } sinon si (condition) { &amp;hellip; } sinon { &amp;hellip; } // Les accolades sont facultatives pour les déclarations sur une seule ligne if (condition) &amp;hellip; else if (condition) &amp;hellip; else &amp;hellip; switch (expression) { case pattern: &amp;hellip; default: &amp;hellip; } condition ? expression si vrai : expression si faux ; Toutes les expressions de branchement permettent de retourner des expressions évaluées.</description>
    </item>
    
  </channel>
</rss>
