<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel sur le langage d&#39;assemblage et la microarchitecture Intel x86 on </title>
    <link>https://www.wikiod.com/fr/docs/x86/</link>
    <description>Recent content in Tutoriel sur le langage d&#39;assemblage et la microarchitecture Intel x86 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/x86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Intel x86 Assembly Language &amp; Microarchitecture</title>
      <link>https://www.wikiod.com/fr/x86/premiers-pas-avec-intel-x86-assembly-language--microarchitecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/premiers-pas-avec-intel-x86-assembly-language--microarchitecture/</guid>
      <description>x86 Linux Hello World Example # Il s&amp;rsquo;agit d&amp;rsquo;un programme de base Hello World en assemblage NASM pour Linux x86 32 bits, utilisant directement les appels système (sans aucun appel de fonction libc). C&amp;rsquo;est beaucoup à assimiler, mais avec le temps, cela deviendra compréhensible. Les lignes commençant par un point-virgule (;) sont des commentaires.
Si vous ne connaissez pas déjà la programmation des systèmes Unix de bas niveau, vous pouvez simplement écrire des fonctions dans asm et les appeler à partir de programmes C ou C++.</description>
    </item>
    
    <item>
      <title>Conventions d&#39;appel</title>
      <link>https://www.wikiod.com/fr/x86/conventions-dappel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/conventions-dappel/</guid>
      <description>Ressources # Vues d&amp;rsquo;ensemble/comparaisons : [Le guide des conventions d&amp;rsquo;appel d&amp;rsquo;Agner Fog] [2]. Aussi, [x86 ABIs (wikipedia)][1] : conventions d&amp;rsquo;appel pour les fonctions, y compris x86-64 Windows et System V (Linux).
[SystemV x86-64 ABI (norme officielle)][3]. Utilisé par tous les systèmes d&amp;rsquo;exploitation sauf Windows. ([Cette page wiki github][4], tenue à jour par H.J. Lu, contient des liens vers 32 bits, 64 bits et x32. Liens également vers le forum officiel pour les mainteneurs/contributeurs d&amp;rsquo;ABI.</description>
    </item>
    
    <item>
      <title>Gestion multiprocesseur</title>
      <link>https://www.wikiod.com/fr/x86/gestion-multiprocesseur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/gestion-multiprocesseur/</guid>
      <description>Paramètres # Registre LAPIC Adresse (Par rapport à APIC BASE) Registre d&amp;rsquo;identification APIC local +20h Registre des vecteurs d&amp;rsquo;interruptions parasites +0f0h Registre de commande d&amp;rsquo;interruption (ICR); bits 0-31 +300h Registre de commande d&amp;rsquo;interruption (ICR); mèches 32-63 +310h Pour accéder aux registres LAPIC, un segment doit pouvoir atteindre la plage d&amp;rsquo;adresses commençant à APIC Base (dans IA32_APIC_BASE). Cette adresse est relocalisable et peut théoriquement être définie pour pointer quelque part dans la mémoire inférieure, rendant ainsi la plage adressable en mode réel.</description>
    </item>
    
    <item>
      <title>S&#39;inscrire</title>
      <link>https://www.wikiod.com/fr/x86/sinscrire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/sinscrire/</guid>
      <description>Registres 16 bits # Lorsqu&amp;rsquo;Intel a défini le 8086 d&amp;rsquo;origine, il s&amp;rsquo;agissait d&amp;rsquo;un processeur 16 bits avec un bus d&amp;rsquo;adresse 20 bits (voir ci-dessous). Ils ont défini 8 registres 16 bits à usage général - mais leur ont donné des rôles spécifiques pour certaines instructions :
AX Le registre de l&amp;rsquo;accumulateur. De nombreux opcodes assumaient ce registre ou étaient plus rapides s&amp;rsquo;il était spécifié. DX Le registre de données. Cela était parfois combiné comme les 16 bits de poids fort d&amp;rsquo;une valeur 32 bits avec AX - par exemple, à la suite d&amp;rsquo;une multiplication.</description>
    </item>
    
    <item>
      <title>Assembleurs</title>
      <link>https://www.wikiod.com/fr/x86/assembleurs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/assembleurs/</guid>
      <description>Assembleur Netwide - NASM # NASM est de loin l&amp;rsquo;assembleur le plus porté pour l&amp;rsquo;architecture x86 - il est disponible pour pratiquement tous les systèmes d&amp;rsquo;exploitation basés sur le x86 (même inclus avec MacOS), et est disponible en tant qu&amp;rsquo;assembleur multiplateforme sur d&amp;rsquo;autres plateformes.
Cet assembleur utilise la syntaxe Intel, mais il est différent des autres car il se concentre fortement sur son propre langage &amp;ldquo;macro&amp;rdquo; - cela permet au programmeur de créer des expressions plus complexes en utilisant des définitions plus simples, permettant de créer de nouvelles &amp;ldquo;instructions&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Mécanismes d&#39;appel système</title>
      <link>https://www.wikiod.com/fr/x86/mecanismes-dappel-systeme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/mecanismes-dappel-systeme/</guid>
      <description>Appels BIOS # Comment interagir avec le BIOS # Le système d&amp;rsquo;entrée/sortie de base, ou BIOS, est ce qui contrôle l&amp;rsquo;ordinateur avant l&amp;rsquo;exécution de tout système d&amp;rsquo;exploitation. Pour accéder aux services fournis par le BIOS, le code assembleur utilise des interruptions. Une interruption prend la forme
int &amp;lt;interrupt&amp;gt; ; interrupt must be a literal number, not in a register or memory Le numéro d&amp;rsquo;interruption doit être compris entre 0 et 255 (0x00 - 0xFF), inclus.</description>
    </item>
    
    <item>
      <title>Optimisation</title>
      <link>https://www.wikiod.com/fr/x86/optimisation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/optimisation/</guid>
      <description>La famille x86 existe depuis longtemps, et en tant que telle, de nombreuses astuces et techniques ont été découvertes et développées qui sont de notoriété publique - ou peut-être pas si publiques.
La plupart de ces astuces tirent parti du fait que de nombreuses instructions font effectivement la même chose - mais différentes versions sont plus rapides, ou économisent de la mémoire, ou n&amp;rsquo;affectent pas les drapeaux.
Voici un certain nombre de trucs qui ont été découverts.</description>
    </item>
    
    <item>
      <title>Modes réels vs protégés</title>
      <link>https://www.wikiod.com/fr/x86/modes-reels-vs-proteges/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/modes-reels-vs-proteges/</guid>
      <description>Mode réel # Lorsqu&amp;rsquo;Intel a conçu le x86 d&amp;rsquo;origine, le 8086 (et le dérivé du 8088), ils ont inclus la segmentation pour permettre au processeur 16 bits d&amp;rsquo;accéder à plus de 16 bits d&amp;rsquo;adresse. Ils l&amp;rsquo;ont fait en faisant en sorte que les adresses 16 bits soient relatives à un registre de segment 16 bits donné, dont ils ont défini quatre : segment de code (CS), segment de données (DS), segment supplémentaire (ES) et segment de pile (SS).</description>
    </item>
    
    <item>
      <title>Flux de contrôle</title>
      <link>https://www.wikiod.com/fr/x86/flux-de-controle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/flux-de-controle/</guid>
      <description>Conditions de test # Pour utiliser un saut conditionnel, une condition doit être testée. ** Tester une condition ** ici se réfère uniquement à l&amp;rsquo;acte de vérifier les drapeaux, le saut réel est décrit sous [Sauts conditionnels] (https://www.wikiod.com/fr/x86/flux-de-controle#Sauts conditionnels -sauts).
x86 teste les conditions en s&amp;rsquo;appuyant sur le registre EFLAGS, qui contient un ensemble d&amp;rsquo;indicateurs que chaque instruction peut potentiellement définir.
Les instructions arithmétiques, comme sub ou add, et les instructions logiques, comme xor ou and, &amp;ldquo;définissent les drapeaux&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Radiomessagerie - Adressage virtuel et mémoire</title>
      <link>https://www.wikiod.com/fr/x86/radiomessagerie---adressage-virtuel-et-memoire/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/x86/radiomessagerie---adressage-virtuel-et-memoire/</guid>
      <description>Introduction # Histoire # Les premiers ordinateurs # Les premiers ordinateurs avaient un bloc de mémoire dans lequel le programmeur mettait du code et des données, et le processeur s&amp;rsquo;exécutait dans cet environnement. Étant donné que les ordinateurs étaient alors très chers, il était regrettable qu&amp;rsquo;il fasse un travail, s&amp;rsquo;arrête et attende que le prochain travail y soit chargé, puis traite celui-ci.
Multi-utilisateur, multi-traitement # Ainsi, les ordinateurs sont rapidement devenus plus sophistiqués et ont pris en charge plusieurs utilisateurs et/ou programmes simultanément - mais c&amp;rsquo;est à ce moment-là que des problèmes ont commencé à survenir avec l&amp;rsquo;idée simple &amp;ldquo;un bloc de mémoire&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>
