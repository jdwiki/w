<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embarcadero Delphi Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/delphi/</link>
    <description>Recent content in Embarcadero Delphi Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/delphi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Embarcadero Delphi</title>
      <link>https://www.wikiod.com/fr/delphi/premiers-pas-avec-embarcadero-delphi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/premiers-pas-avec-embarcadero-delphi/</guid>
      <description>Bonjour le monde # Ce programme, enregistré dans un fichier nommé HelloWorld.dpr, se compile dans une application console qui affiche &amp;ldquo;Hello World&amp;rdquo; sur la console :
program HelloWorld; {$APPTYPE CONSOLE} begin WriteLn(&#39;Hello World&#39;); end. Afficher &amp;lsquo;Hello World&amp;rsquo; en utilisant la VCL # Ce programme utilise VCL, la bibliothèque de composants d&amp;rsquo;interface utilisateur par défaut de Delphi, pour imprimer &amp;ldquo;Hello World&amp;rdquo; dans une boîte de message. La VCL encapsule la plupart des composants WinAPI couramment utilisés.</description>
    </item>
    
    <item>
      <title>Utilisation de try, except, et finally</title>
      <link>https://www.wikiod.com/fr/delphi/utilisation-de-try-except-et-finally/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/utilisation-de-try-except-et-finally/</guid>
      <description>Syntaxe # Try-except : try [statements] except [[[on E:ExceptionType do statement]] [else statement] | [statements] end;
Try-finally: try [statements] finally [statements] end;
Retour sans exception d&amp;rsquo;un nouvel objet # Lorsqu&amp;rsquo;une fonction * renvoie * un objet (par opposition à * utiliser * celui qui est transmis par l&amp;rsquo;appelant), faites attention qu&amp;rsquo;une exception ne provoque pas de fuite de l&amp;rsquo;objet.
function MakeStrings: TStrings; begin // Create a new object before entering the try-block.</description>
    </item>
    
    <item>
      <title>Exécution d&#39;un thread tout en gardant l&#39;interface graphique réactive</title>
      <link>https://www.wikiod.com/fr/delphi/execution-dun-thread-tout-en-gardant-linterface-graphique-reactive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/execution-dun-thread-tout-en-gardant-linterface-graphique-reactive/</guid>
      <description>Interface graphique réactive utilisant des threads pour le travail en arrière-plan et PostMessage pour rendre compte des threads # Garder une interface graphique réactive lors de l&amp;rsquo;exécution d&amp;rsquo;un long processus nécessite soit des &amp;ldquo;rappels&amp;rdquo; très élaborés pour permettre à l&amp;rsquo;interface graphique de traiter sa file d&amp;rsquo;attente de messages, soit l&amp;rsquo;utilisation de threads (d&amp;rsquo;arrière-plan) (de travail).
Lancer n&amp;rsquo;importe quel nombre de threads pour faire du travail n&amp;rsquo;est généralement pas un problème. Le plaisir commence lorsque vous souhaitez que l&amp;rsquo;interface graphique affiche les résultats intermédiaires et finaux ou rende compte de la progression.</description>
    </item>
    
    <item>
      <title>Cordes</title>
      <link>https://www.wikiod.com/fr/delphi/cordes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/cordes/</guid>
      <description>Types de chaînes # Delphi propose les types de chaîne suivants (par ordre de popularité) :
Taper Longueur maximale Taille minimale Descriptif chaîne 2 Go 16 octets Une chaîne gérée. Un alias pour AnsiString jusqu&amp;rsquo;à Delphi 2007 et un alias pour UnicodeString à partir de Delphi 2009. UnicodeString 2 Go 16 octets Une chaîne gérée au format UTF-16. AnsiString 2 Go 16 octets Une chaîne gérée au format ANSI pré-Unicode. Depuis Delphi 2009, il porte un indicateur de page de code explicite.</description>
    </item>
    
    <item>
      <title>Mesure des intervalles de temps</title>
      <link>https://www.wikiod.com/fr/delphi/mesure-des-intervalles-de-temps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/mesure-des-intervalles-de-temps/</guid>
      <description>Utilisation de l&amp;rsquo;API Windows GetTickCount # La fonction &amp;ldquo;GetTickCount&amp;rdquo; de l&amp;rsquo;API Windows renvoie le nombre de millisecondes écoulées depuis le démarrage du système (ordinateur). L&amp;rsquo;exemple le plus simple est le suivant :
var Start, Stop, ElapsedMilliseconds: cardinal; begin Start := GetTickCount; // do something that requires measurement Stop := GetTickCount; ElapsedMillseconds := Stop - Start; end; Notez que GetTickCount renvoie DWORD 32 bits, donc il s&amp;rsquo;enroule tous les 49,7 jours. Pour éviter le wrapper, vous pouvez soit utiliser GetTickCount64 (disponible depuis Windows Vista) ou des routines spéciales pour calculer la différence de tick :</description>
    </item>
    
    <item>
      <title>Génériques</title>
      <link>https://www.wikiod.com/fr/delphi/generiques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/generiques/</guid>
      <description>Trier un tableau dynamique via TArray.Sort générique # uses System.Generics.Collections, { TArray } System.Generics.Defaults; { TComparer&amp;lt;T&amp;gt; } var StringArray: TArray&amp;lt;string&amp;gt;; { Also works with &amp;quot;array of string&amp;quot; } ... { Sorts the array case insensitive } TArray.Sort&amp;lt;string&amp;gt;(StringArray, TComparer&amp;lt;string&amp;gt;.Construct( function (const A, B: string): Integer begin Result := string.CompareText(A, B); end )); Utilisation simple de TList # var List: TList&amp;lt;Integer&amp;gt;; ... List := TList&amp;lt;Integer&amp;gt;.Create; { Create List } try List.Add(100); { Add Items } List.</description>
    </item>
    
    <item>
      <title>Pour les boucles</title>
      <link>https://www.wikiod.com/fr/delphi/pour-les-boucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/pour-les-boucles/</guid>
      <description>Syntaxe # for OrdinalVariable := LowerOrdinalValue to UpperOrdinalValue do begin {loop-body} end ;
for OrdinalVariable := UpperOrdinalValue jusqu&amp;rsquo;à LowerOrdinalValue do begin {loop-body} end ;
pour EnumerableVariable in Collection do begin {loop-body} end ;
La syntaxe de la boucle for de Delphi ne fournit rien pour modifier le nombre de pas de 1 à toute autre valeur.
Lors d&amp;rsquo;une boucle avec des valeurs ordinales variables, par ex. variables locales de type Integer, les valeurs supérieures et inférieures ne seront déterminées qu&amp;rsquo;une seule fois.</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>https://www.wikiod.com/fr/delphi/interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/interfaces/</guid>
      <description>Les interfaces sont utilisées pour décrire les informations nécessaires et la sortie attendue des méthodes et des classes, sans fournir d&amp;rsquo;informations sur l&amp;rsquo;implémentation explicite.
Les classes peuvent implémenter des interfaces, et les interfaces peuvent hériter les unes des autres. Si une classe implémente une interface, cela signifie que toutes les fonctions et procédures exposées par l&amp;rsquo;interface existent dans la classe.
Un aspect particulier des interfaces dans Delphi est que les instances d&amp;rsquo;interfaces ont une gestion de la durée de vie basée sur le comptage des références.</description>
    </item>
    
    <item>
      <title>Récupération des données TDataSet mises à jour dans un thread d&#39;arrière-plan</title>
      <link>https://www.wikiod.com/fr/delphi/recuperation-des-donnees-tdataset-mises-a-jour-dans-un-thread-darriere-plan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/recuperation-des-donnees-tdataset-mises-a-jour-dans-un-thread-darriere-plan/</guid>
      <description>Cet exemple FireDAC, et les autres que je prévois de soumettre, éviteront l&amp;rsquo;utilisation d&amp;rsquo;appels natifs pour ouvrir de manière asynchrone l&amp;rsquo;ensemble de données.
Exemple FireDAC # L&amp;rsquo;exemple de code ci-dessous montre une façon de récupérer des enregistrements à partir d&amp;rsquo;un serveur MSSql dans un thread d&amp;rsquo;arrière-plan à l&amp;rsquo;aide de FireDAC. Testé pour Delphi 10 Seattle
Comme écrit:
Le thread récupère les données en utilisant ses propres TFDConnection et TFDQuery et les transfère les données au FDQuery du formulaire dans un appel à Sychronize().</description>
    </item>
    
    <item>
      <title>Exécution d&#39;autres programmes</title>
      <link>https://www.wikiod.com/fr/delphi/execution-dautres-programmes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/delphi/execution-dautres-programmes/</guid>
      <description>CréerProcessus # La fonction suivante encapsule le code permettant d&amp;rsquo;utiliser l&amp;rsquo;API Windows &amp;ldquo;CreateProcess&amp;rdquo; pour lancer d&amp;rsquo;autres programmes.
Il est configurable et peut attendre la fin du processus d&amp;rsquo;appel ou revenir immédiatement.
Paramètres:
FileName - chemin complet vers l&amp;rsquo;exécutable
Params - paramètres de ligne de commande ou utilisez une chaîne vide
Folder - dossier de travail pour le programme appelé - si un chemin vide sera extrait de FileName
WaitUntilTerminated - si vrai, la fonction attendra que le processus termine son exécution</description>
    </item>
    
  </channel>
</rss>
