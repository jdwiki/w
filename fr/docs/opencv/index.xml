<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel opencv on </title>
    <link>https://www.wikiod.com/fr/docs/opencv/</link>
    <description>Recent content in Tutoriel opencv on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/opencv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec opencv</title>
      <link>https://www.wikiod.com/fr/opencv/premiers-pas-avec-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/premiers-pas-avec-opencv/</guid>
      <description>Charger et afficher une image avec OpenCV # Avec cet exemple, nous verrons comment charger une image couleur à partir du disque et l&amp;rsquo;afficher à l&amp;rsquo;aide des fonctions intégrées d&amp;rsquo;OpenCV. Nous pouvons utiliser les liaisons C/C++, Python ou Java pour y parvenir.
En C++ :
#include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace cv; int main(int argc, char** argv) { // We&#39;ll start by loading an image from the drive Mat image = imread(&amp;quot;image.</description>
    </item>
    
    <item>
      <title>Contraste et luminosité en C&#43;&#43;</title>
      <link>https://www.wikiod.com/fr/opencv/contraste-et-luminosite-en-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/contraste-et-luminosite-en-c-/</guid>
      <description>Syntaxe # void cv::Mat::convertTo(OutputArray m, int rtype,double alpha = 1,double beta = 0)const Paramètres # Paramètre Détails m matrice de sortie ; s&amp;rsquo;il n&amp;rsquo;a pas une taille ou un type correct avant l&amp;rsquo;opération, il est réalloué rtype le type de matrice de sortie souhaité ou, plutôt, la profondeur puisque le nombre de canaux est le même que celui de l&amp;rsquo;entrée ; si rtype est négatif, la matrice de sortie aura le même type que l&amp;rsquo;entrée Alpha facteur d&amp;rsquo;échelle facultatif.</description>
    </item>
    
    <item>
      <title>Accès aux pixels</title>
      <link>https://www.wikiod.com/fr/opencv/acces-aux-pixels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/acces-aux-pixels/</guid>
      <description>Soyez attentif au type de cv::Mat auquel vous avez affaire. Par exemple, si vous avez un cv::Mat de type CV_8UC3, mais que vous y accédez avec image.at&amp;lt;uchar&amp;gt;(r,c) aucune erreur ne se produira, mais votre programme aura un comportement inattendu.
Accès efficace aux pixels à l&amp;rsquo;aide du pointeur cv::Mat::ptr # Si l&amp;rsquo;efficacité est importante, un moyen rapide d&amp;rsquo;itérer sur les pixels d&amp;rsquo;un objet cv::Mat consiste à utiliser sa méthode ptr&amp;lt;T&amp;gt;(int r) pour obtenir un pointeur vers le début de la ligne r (0 indice basé sur).</description>
    </item>
    
    <item>
      <title>Détection des contours</title>
      <link>https://www.wikiod.com/fr/opencv/detection-des-contours/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/detection-des-contours/</guid>
      <description>Syntaxe # bords = cv2.[Canny][1](image, threshold1, threshold2[, edge[, openingSize[, L2gradient]]]) void [Canny] [1] (image InputArray, bords OutputArray, double seuil1, double seuil2, int ouvertureSize=3, bool L2gradient=false [1] : http://docs.opencv.org/2.4.13/modules/imgproc/doc/feature_detection.html#canny
Paramètres # Paramètre Détails image Image d&amp;rsquo;entrée bords Image de sortie threshold1 Premier seuil pour la procédure d&amp;rsquo;hystérésis threshold2 Deuxième seuil pour la procédure d&amp;rsquo;hystérésis apertureSize Taille d&amp;rsquo;ouverture pour l&amp;rsquo;opérateur Sobel L2gradient Drapeau indiquant si un algorithme plus précis pour le gradient d&amp;rsquo;image doit être utilisé Algorithme Canny # L&amp;rsquo;algorithme Canny est un détecteur de bord plus récent conçu comme un problème de traitement du signal.</description>
    </item>
    
    <item>
      <title>Traitement d&#39;image</title>
      <link>https://www.wikiod.com/fr/opencv/traitement-dimage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/traitement-dimage/</guid>
      <description>Syntaxe # Syntaxe de flou gaussien C++ : void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT ) Paramètres # Paramètres du flou gaussien Détails src Image d&amp;rsquo;entrée, l&amp;rsquo;image peut avoir n&amp;rsquo;importe quel nombre de canaux, qui sont traités indépendamment, mais la profondeur doit être CV_8U, CV_16U, CV_16S, CV_32F ou CV_64F. heure d&amp;rsquo;été Image de sortie de la même taille et du même type que src ktaille Taille du noyau gaussien.</description>
    </item>
    
    <item>
      <title>Dessiner des formes (ligne, cercle, ..., etc.) en C&#43;&#43;</title>
      <link>https://www.wikiod.com/fr/opencv/dessiner-des-formes-ligne-cercle--etc-en-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/dessiner-des-formes-ligne-cercle--etc-en-c-/</guid>
      <description>Dans OpenCV, on peut dessiner de nombreuses formes telles que des points, des lignes, des cercles, &amp;hellip;, etc. Il existe une option pour remplir une forme. Le code suivant est explicite et montre comment les formes sont dessinées.
Échantillon de formes de dessin # #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; // drawing shapes #include &amp;lt;iostream&amp;gt; int main( int argc, char** argv ) { // First create a black image. cv::Mat image(500,500, CV_8UC3, cv::Scalar(0,0,0)); // Check if the image is created successfully.</description>
    </item>
    
    <item>
      <title>Créer une vidéo</title>
      <link>https://www.wikiod.com/fr/opencv/creer-une-video/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/creer-une-video/</guid>
      <description>Chaque fois que vous travaillez avec des flux vidéo, vous souhaiterez peut-être éventuellement enregistrer le résultat de votre traitement d&amp;rsquo;image sous la forme d&amp;rsquo;un nouveau fichier vidéo. Pour les sorties vidéo simples, vous pouvez utiliser la classe VideoWriter intégrée à OpenCV, conçue à cet effet. Il est utile de se pencher sur certains concepts avant de les utiliser. Ces concepts sont codec c&amp;rsquo;est-à-dire décodeur et FourCC (code à quatre caractères).</description>
    </item>
    
    <item>
      <title>Classificateurs en cascade</title>
      <link>https://www.wikiod.com/fr/opencv/classificateurs-en-cascade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/classificateurs-en-cascade/</guid>
      <description>Utilisation des classificateurs en cascade pour détecter le visage # #Python
##Code
import numpy as np import cv2 #loading haarcascade classifiers for face and eye #You can find these cascade classifiers here #https://github.com/opencv/opencv/tree/master/data/haarcascades #or where you download opencv inside data/haarcascades face_cascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_default.xml&#39;) eye_cascade = cv2.CascadeClassifier(&#39;haarcascade_eye.xml&#39;) #loading the image img = cv2.imread(&#39;civil_war.jpg&#39;) #converting the image to gray scale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #detecting face in the grayscale image faces = face_cascade.</description>
    </item>
    
    <item>
      <title>Afficher l&#39;image OpenCV</title>
      <link>https://www.wikiod.com/fr/opencv/afficher-limage-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/afficher-limage-opencv/</guid>
      <description>Lecture et affichage de base d&amp;rsquo;une image # import cv2 image_path= #put your image path here #use imread() function to read image data to variable img. img = cv2.imread(image_path) #display image data in a new window with title &#39;I am an image display window&#39; cv2.imshow(&#39;I am an image display window&#39;,img) #wait until user hits any key on keyboard cv2.waitKey(0) #close any windows opened by opencv cv2.destroyAllWindows() Pour contrôler la taille de la fenêtre d&amp;rsquo;affichage à l&amp;rsquo;écran, ajoutez les commandes suivantes avant la commande cv2.</description>
    </item>
    
    <item>
      <title>Utilisation de classificateurs en cascade en Java</title>
      <link>https://www.wikiod.com/fr/opencv/utilisation-de-classificateurs-en-cascade-en-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/opencv/utilisation-de-classificateurs-en-cascade-en-java/</guid>
      <description>Syntaxe # CascadeClassifier cascade = new CascadeClassifier(&amp;ldquo;cascade.xml&amp;rdquo;); // Crée un classificateur en cascade à partir de cascade.xml Image Mat = Imgcodecs.imread(&amp;ldquo;image.png&amp;rdquo;); // Convertit image.png en un objet Mat (Matrix) Détections MatOfRect = new MatOfRect(); // Crée un fichier MatOfRect (Matrix of Rectangles) vide, utilisé comme sortie pour nos classes de détection détections.toArray(); // Renvoie un tableau d&amp;rsquo;objets Rect qui peuvent être itérés Imgproc.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.</description>
    </item>
    
  </channel>
</rss>
