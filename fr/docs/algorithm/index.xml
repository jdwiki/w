<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithme Tutoriel on </title>
    <link>https://www.wikiod.com/fr/docs/algorithm/</link>
    <description>Recent content in Algorithme Tutoriel on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec l&#39;algorithme</title>
      <link>https://www.wikiod.com/fr/algorithm/debuter-avec-lalgorithme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/debuter-avec-lalgorithme/</guid>
      <description>Un exemple de problème algorithmique # Un problème algorithmique est spécifié en décrivant l&amp;rsquo;ensemble complet des instances sur lesquelles il doit fonctionner et de sa sortie après s&amp;rsquo;être exécuté sur l&amp;rsquo;une de ces instances. Cette distinction, entre un problème et une instance de problème, est fondamentale. Le problème algorithmique connu sous le nom de tri est défini comme suit : [Skiena:2008:ADM:1410219]
Problème : Trier Entrée : Une séquence de n touches, a_1, a_2, .</description>
    </item>
    
    <item>
      <title>Complexité de l&#39;algorithme</title>
      <link>https://www.wikiod.com/fr/algorithm/complexite-de-lalgorithme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/complexite-de-lalgorithme/</guid>
      <description>Tous les algorithmes sont une liste d&amp;rsquo;étapes pour résoudre un problème. Chaque étape dépend d&amp;rsquo;un ensemble d&amp;rsquo;étapes précédentes ou du début de l&amp;rsquo;algorithme. Un petit problème pourrait ressembler à ceci :
[![entrez la description de l&amp;rsquo;image ici][1]][1]
Cette structure est appelée graphe acyclique orienté, ou DAG en abrégé. Les liens entre chaque nœud du graphe représentent des dépendances dans l&amp;rsquo;ordre des opérations, et il n&amp;rsquo;y a pas de cycles dans le graphe.</description>
    </item>
    
    <item>
      <title>Notation Big-O</title>
      <link>https://www.wikiod.com/fr/algorithm/notation-big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/notation-big-o/</guid>
      <description>Définition
La notation Big-O est en son cœur une notation mathématique, utilisée pour comparer le taux de convergence des fonctions. Soient n -&amp;gt; f(n) et n -&amp;gt; g(n) des fonctions définies sur les nombres naturels. Alors on dit que f = O(g) si et seulement si f(n)/g(n) est borné quand n tend vers l&amp;rsquo;infini. Autrement dit, f = O(g) si et seulement s&amp;rsquo;il existe une constante A, telle que pour tout n, f(n)/g(n) &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>Graphique</title>
      <link>https://www.wikiod.com/fr/algorithm/graphique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/graphique/</guid>
      <description>Un graphique est une collection de points et de lignes reliant certains sous-ensembles (éventuellement vides) d&amp;rsquo;entre eux. Les points d&amp;rsquo;un graphe sont appelés sommets du graphe, &amp;ldquo;nœuds&amp;rdquo; ou simplement &amp;ldquo;points&amp;rdquo;. De même, les lignes reliant les sommets d&amp;rsquo;un graphe sont appelées arêtes de graphe, &amp;ldquo;arcs&amp;rdquo; ou &amp;ldquo;lignes&amp;rdquo;.
Un graphe G peut être défini comme une paire (V,E), où V est un ensemble de sommets, et E est un ensemble d&amp;rsquo;arêtes entre les sommets E ⊆ {(u,v) | u, v ∈ V}.</description>
    </item>
    
    <item>
      <title>Arbres de recherche binaires</title>
      <link>https://www.wikiod.com/fr/algorithm/arbres-de-recherche-binaires/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/arbres-de-recherche-binaires/</guid>
      <description>L&amp;rsquo;arbre binaire est un arbre dont chaque nœud a au maximum deux enfants. L&amp;rsquo;arbre de recherche binaire (BST) est un arbre binaire dont les éléments sont positionnés dans un ordre spécial. Dans chaque BST, toutes les valeurs (c&amp;rsquo;est-à-dire la clé) du sous-arbre de gauche sont inférieures aux valeurs du sous-arbre de droite.
Arbre de recherche binaire - Insertion (Python) # Il s&amp;rsquo;agit d&amp;rsquo;une implémentation simple de l&amp;rsquo;insertion d&amp;rsquo;arbre de recherche binaire à l&amp;rsquo;aide de Python.</description>
    </item>
    
    <item>
      <title>Algorithme de Dijkstra</title>
      <link>https://www.wikiod.com/fr/algorithm/algorithme-de-dijkstra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/algorithme-de-dijkstra/</guid>
      <description>Algorithme du plus court chemin de Dijkstra # Avant de continuer, il est recommandé d&amp;rsquo;avoir une brève idée de la matrice d&amp;rsquo;adjacence et du BFS
L&amp;rsquo;algorithme de Dijkstra est connu sous le nom d&amp;rsquo;algorithme de chemin le plus court à source unique. Il est utilisé pour trouver les chemins les plus courts entre les nœuds d&amp;rsquo;un graphe, qui peuvent représenter, par exemple, des réseaux routiers. Il a été conçu par Edsger W.</description>
    </item>
    
    <item>
      <title>Tri par fusion</title>
      <link>https://www.wikiod.com/fr/algorithm/tri-par-fusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/tri-par-fusion/</guid>
      <description>Fusionner les bases du tri # Merge Sort est un algorithme de division pour mieux régner. Il divise la liste d&amp;rsquo;entrée de longueur n en deux successivement jusqu&amp;rsquo;à ce qu&amp;rsquo;il y ait n listes de taille 1. Ensuite, les paires de listes sont fusionnées, le premier élément le plus petit parmi la paire de listes étant ajouté à chaque étape. Par fusions successives et par comparaison des premiers éléments, la liste triée est construite.</description>
    </item>
    
    <item>
      <title>Déformation temporelle dynamique</title>
      <link>https://www.wikiod.com/fr/algorithm/deformation-temporelle-dynamique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/deformation-temporelle-dynamique/</guid>
      <description>Introduction à la déformation temporelle dynamique # Dynamic Time Warping(DTW) est un algorithme permettant de mesurer la similarité entre deux séquences temporelles dont la vitesse peut varier. Par exemple, des similitudes dans la marche pourraient être détectées à l&amp;rsquo;aide de DTW, même si une personne marchait plus vite que l&amp;rsquo;autre, ou s&amp;rsquo;il y avait des accélérations et des décélérations au cours d&amp;rsquo;une observation. Il peut être utilisé pour faire correspondre un exemple de commande vocale avec d&amp;rsquo;autres commandes, même si la personne parle plus vite ou plus lentement que l&amp;rsquo;échantillon de voix préenregistré.</description>
    </item>
    
    <item>
      <title>Algorithme de Bellman-Ford</title>
      <link>https://www.wikiod.com/fr/algorithm/algorithme-de-bellman-ford/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/algorithme-de-bellman-ford/</guid>
      <description>Étant donné un graphe orienté G, nous voulons souvent trouver la distance la plus courte entre un nœud donné A et le reste des nœuds du graphe. L&amp;rsquo;algorithme Dijkstra est l&amp;rsquo;algorithme le plus connu pour trouver le chemin le plus court, mais il ne fonctionne que si les poids des arêtes du graphe donné ne sont pas négatifs. Bellman-Ford vise cependant à trouver le chemin le plus court à partir d&amp;rsquo;un nœud donné (s&amp;rsquo;il existe) même si certains des poids sont négatifs.</description>
    </item>
    
    <item>
      <title>Recherche de sous-chaîne</title>
      <link>https://www.wikiod.com/fr/algorithm/recherche-de-sous-chaine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/algorithm/recherche-de-sous-chaine/</guid>
      <description>Introduction à l&amp;rsquo;algorithme de Knuth-Morris-Pratt (KMP) # Supposons que nous ayons un texte et un motif. Nous devons déterminer si le motif existe dans le texte ou non. Par exemple:
+-------+---+---+---+---+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | +-------+---+---+---+---+---+---+---+---+ | Text | a | b | c | b | c | g | l | x | +-------+---+---+---+---+---+---+---+---+ +---------+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | +---------+---+---+---+---+ | Pattern | b | c | g | l | +---------+---+---+---+---+ Ce motif existe dans le texte.</description>
    </item>
    
  </channel>
</rss>
