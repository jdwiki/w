<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel Fortran on </title>
    <link>https://www.wikiod.com/fr/docs/fortran/</link>
    <description>Recent content in Tutoriel Fortran on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/fortran/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Premiers pas avec Fortran</title>
      <link>https://www.wikiod.com/fr/fortran/premiers-pas-avec-fortran/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/premiers-pas-avec-fortran/</guid>
      <description>Bonjour le monde # Tout programme Fortran doit inclure end comme dernière instruction. Par conséquent, le programme Fortran le plus simple ressemble à ceci :
end Voici quelques exemples de programmes &amp;ldquo;hello, world&amp;rdquo;:
print *, &amp;quot;Hello, world&amp;quot; end Avec l&amp;rsquo;instruction &amp;lsquo;write&amp;rsquo; :
write(*,*) &amp;quot;Hello, world&amp;quot; end Pour plus de clarté, il est maintenant courant d&amp;rsquo;utiliser l&amp;rsquo;instruction program pour démarrer un programme et lui donner un nom. L&amp;rsquo;instruction end peut alors faire référence à ce nom pour indiquer clairement à quoi il se réfère, et laisser le compilateur vérifier l&amp;rsquo;exactitude du code.</description>
    </item>
    
    <item>
      <title>Tableaux</title>
      <link>https://www.wikiod.com/fr/fortran/tableaux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/tableaux/</guid>
      <description>Constructeurs de tableaux # Une valeur de tableau de rang 1 peut être créée à l&amp;rsquo;aide d&amp;rsquo;un constructeur de tableau, avec la syntaxe
(/ ... /) [ ... ] La forme [...] a été introduite dans Fortran 2003 et est généralement considérée comme plus claire à lire, en particulier dans les expressions complexes. Ce formulaire est utilisé exclusivement dans cet exemple.
Les valeurs figurant dans un constructeur de tableau peuvent être des valeurs scalaires, des valeurs de tableau ou des boucles implicites.</description>
    </item>
    
    <item>
      <title>Types de données</title>
      <link>https://www.wikiod.com/fr/fortran/types-de-donnees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/types-de-donnees/</guid>
      <description>Précision des nombres à virgule flottante # Les nombres à virgule flottante de type &amp;ldquo;réel&amp;rdquo; ne peuvent pas avoir de valeur réelle. Ils peuvent représenter des nombres réels jusqu&amp;rsquo;à un certain nombre de chiffres décimaux.
FORTRAN 77 garantissait deux types à virgule flottante et des normes plus récentes garantissent au moins deux types réels. Les variables réelles peuvent être déclarées comme
real x double precision y x ici est un réel de type par défaut et y est un réel de type avec une plus grande précision décimale que x.</description>
    </item>
    
    <item>
      <title>Programmation orientée objet</title>
      <link>https://www.wikiod.com/fr/fortran/programmation-orientee-objet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/programmation-orientee-objet/</guid>
      <description>Définition de type dérivé # Fortran 2003 a introduit la prise en charge de la programmation orientée objet. Cette fonctionnalité permet de tirer parti des techniques de programmation modernes. Les types dérivés sont définis sous la forme suivante :
TYPE [[, attr-list] :: ] name [(name-list)] [def-stmts] [PRIVATE statement or SEQUENCE statement]. . . [component-definition]. . . [procedure-part] END TYPE [name] où,
attr-list - une liste de spécificateurs d&amp;rsquo;attributs name - le nom du type de données dérivé name-list - une liste de noms de paramètres de type séparés par des virgules def-stmts - une ou plusieurs déclarations INTEGER des paramètres de type nommés dans la liste de noms component-definition - une ou plusieurs instructions de déclaration de type ou instructions de pointeur de procédure définissant le composant de type dérivé procedure-part - une instruction CONTAINS, éventuellement suivie d&amp;rsquo;une instruction PRIVATE, et une ou plusieurs instructions de liaison de procédure Exemple:</description>
    </item>
    
    <item>
      <title>Alternatives modernes aux caractéristiques historiques</title>
      <link>https://www.wikiod.com/fr/fortran/alternatives-modernes-aux-caracteristiques-historiques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/alternatives-modernes-aux-caracteristiques-historiques/</guid>
      <description>Arithmétique if instruction # L&amp;rsquo;instruction arithmétique if permet d&amp;rsquo;utiliser trois branches en fonction du résultat d&amp;rsquo;une expression arithmétique
if (arith_expr) label1, label2, label3 Cette instruction &amp;ldquo;if&amp;rdquo; transfère le flux de contrôle à l&amp;rsquo;une des étiquettes d&amp;rsquo;un code. Si le résultat de arith_expr est négatif, label1 est impliqué, si le résultat est zéro label2 est utilisé, et si le résultat est positif, le dernier label3 est appliqué. L&amp;rsquo;arithmétique &amp;ldquo;if&amp;rdquo; nécessite les trois étiquettes mais permet la réutilisation des étiquettes.</description>
    </item>
    
    <item>
      <title>Unités de programme et disposition des fichiers</title>
      <link>https://www.wikiod.com/fr/fortran/unites-de-programme-et-disposition-des-fichiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/unites-de-programme-et-disposition-des-fichiers/</guid>
      <description>Sous-programmes internes # Une unité de programme qui n&amp;rsquo;est pas un sous-programme interne peut contenir d&amp;rsquo;autres unités de programme, appelées sous-programmes internes.
program prog implicit none contains function f() end function f subroutine g() end subroutine g end program Un tel sous-programme interne présente un certain nombre de fonctionnalités :
il existe une association d&amp;rsquo;hôtes entre les entités du sous-programme et le programme externe les règles de typage implicites sont héritées (implicit none est en vigueur dans f ci-dessus) les sous-programmes internes ont une interface explicite disponible dans l&amp;rsquo;hôte Les sous-programmes de module et les sous-programmes externes peuvent avoir des sous-programmes internes, tels que</description>
    </item>
    
    <item>
      <title>Procédures - Fonctions et sous-programmes</title>
      <link>https://www.wikiod.com/fr/fortran/procedures---fonctions-et-sous-programmes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/procedures---fonctions-et-sous-programmes/</guid>
      <description>Les fonctions et les sous-programmes, en conjonction avec les modules, sont les outils pour décomposer un programme en unités. Cela rend le programme plus lisible et gérable. Chacune de ces unités peut être considérée comme faisant partie du code qui, idéalement, pourrait être compilée et testée de manière isolée. Le ou les programmes principaux peuvent appeler (ou invoquer) ces sous-programmes (fonctions ou sous-programmes) pour accomplir une tâche.
Les fonctions et les sous-programmes sont différents dans le sens suivant :</description>
    </item>
    
    <item>
      <title>Utilisation des modules</title>
      <link>https://www.wikiod.com/fr/fortran/utilisation-des-modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/utilisation-des-modules/</guid>
      <description>Syntaxe des modules # Le module est une collection de déclarations de type, de déclarations de données et de procédures. La syntaxe de base est :
module module_name use other_module_being_used ! The use of implicit none here will set it for the scope of the module. ! Therefore, it is not required (although considered good practice) to repeat ! it in the contained subprograms. implicit none ! Parameters declaration real, parameter, public :: pi = 3.</description>
    </item>
    
    <item>
      <title>Interfaces explicites et implicites</title>
      <link>https://www.wikiod.com/fr/fortran/interfaces-explicites-et-implicites/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/interfaces-explicites-et-implicites/</guid>
      <description>Sous-programmes externes et interfaces implicites # Un sous-programme est dit externe lorsqu&amp;rsquo;il n&amp;rsquo;est pas contenu dans le programme principal, ni dans un module ou un autre sous-programme. En particulier, il peut être défini au moyen d&amp;rsquo;un langage de programmation autre que Fortran.
Lorsqu&amp;rsquo;un sous-programme externe est appelé, le compilateur ne peut pas accéder à son code, donc toutes les informations autorisées pour le compilateur sont implicitement contenues dans l&amp;rsquo;instruction d&amp;rsquo;appel du programme appelant et dans les propriétés de type des arguments réels, pas les arguments factices ( dont la déclaration est inconnue du compilateur).</description>
    </item>
    
    <item>
      <title>Contrôle d&#39;exécution</title>
      <link>https://www.wikiod.com/fr/fortran/controle-dexecution/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/fortran/controle-dexecution/</guid>
      <description>Si construction # La construction if (appelée instruction IF de bloc dans FORTRAN 77) est commune à de nombreux langages de programmation. Il exécute conditionnellement un bloc de code lorsqu&amp;rsquo;une expression logique est évaluée à true.
[name:] IF (expr) THEN block [ELSE IF (expr) THEN [name] block] [ELSE [name] block] END IF [name] où,
name - le nom de la construction if (optionnel) expr - une expression logique scalaire entre parenthèses bloc - une séquence de zéro ou plusieurs instructions ou constructions Un nom de construction au début d&amp;rsquo;une instruction if then doit avoir la même valeur que le nom de construction à l&amp;rsquo;instruction end if, et il doit être unique pour l&amp;rsquo;unité de portée actuelle.</description>
    </item>
    
  </channel>
</rss>
