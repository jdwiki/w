<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel sur les principes solides on </title>
    <link>https://www.wikiod.com/fr/docs/solid-principles/</link>
    <description>Recent content in Tutoriel sur les principes solides on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/solid-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Commencer avec des principes solides</title>
      <link>https://www.wikiod.com/fr/solid-principles/commencer-avec-des-principes-solides/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/solid-principles/commencer-avec-des-principes-solides/</guid>
      <description>Principe de substitution de Liskov # Pourquoi utiliser LSP
Scénario : Supposons que nous ayons 3 bases de données (clients hypothécaires, clients de comptes courants et clients de comptes d&amp;rsquo;épargne) qui fournissent des données client et nous avons besoin des détails du client pour le nom de famille du client donné. Maintenant, nous pouvons obtenir plus d&amp;rsquo;un détail client à partir de ces 3 bases de données par rapport au nom de famille donné.</description>
    </item>
    
    <item>
      <title>Principe Ouvert Fermé (OCP)</title>
      <link>https://www.wikiod.com/fr/solid-principles/principe-ouvert-ferme-ocp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/solid-principles/principe-ouvert-ferme-ocp/</guid>
      <description>Les entités logicielles (classe, modules, fonctions, etc.) doivent être ouvertes pour extension mais fermées pour modification.
Ouvert Fermé Principe C# # Ici, nous essayons d&amp;rsquo;expliquer OCP en utilisant codebase. Nous allons d&amp;rsquo;abord montrer un scénario qui viole l&amp;rsquo;OCP, puis nous supprimerons cette violation.
Calcul de surface (code de violation OCP) :
public class Rectangle{ public double Width {get; set;} public double Height {get; set;} } public class Circle{ public double Radious {get; set;} } public double getArea (object[] shapes){ double totalArea = 0; foreach(var shape in shapes){ if(shape is Rectangle){ Rectangle rectangle = (Rectangle)shape; totalArea += rectangle.</description>
    </item>
    
    <item>
      <title>Principe d&#39;inversion de dépendance (DIP)</title>
      <link>https://www.wikiod.com/fr/solid-principles/principe-dinversion-de-dependance-dip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/solid-principles/principe-dinversion-de-dependance-dip/</guid>
      <description>Le principe dit essentiellement que Class devrait dépendre d&amp;rsquo;abstractions (par exemple, interface, classes abstraites), et non de détails spécifiques (implémentations). Cela signifie que vous devez laisser l&amp;rsquo;appelant créer les dépendances au lieu de laisser la classe elle-même créer les dépendances.
Principe d&amp;rsquo;inversion de dépendance C# # [![entrez la description de l&amp;rsquo;image ici][1]][1]
[1] : https://i.stack.imgur.com/NWXzv.png
Pour comprendre * le principe d&amp;rsquo;inversion de dépendance (DIP) *, nous devons clarifier le concept de * inversion de contrôle (IOC) * et * injection de dépendance (DI) *.</description>
    </item>
    
    <item>
      <title>Principe de responsabilité unique (SRP)</title>
      <link>https://www.wikiod.com/fr/solid-principles/principe-de-responsabilite-unique-srp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/solid-principles/principe-de-responsabilite-unique-srp/</guid>
      <description>Il ne devrait jamais y avoir plus d&amp;rsquo;une raison pour modifier quoi que ce soit dans les entités logicielles (classe, fonction, fichier, etc.). Une classe, une fonction, un fichier, etc. ne devrait avoir qu&amp;rsquo;une seule raison de changer.
Ce n&amp;rsquo;est pas parce que vous le pouvez que vous devriez le faire.
Principe de responsabilité unique C# # Passons d&amp;rsquo;abord en revue le problème. Jetez un oeil sur le code ci-dessous:</description>
    </item>
    
    <item>
      <title>Principe de ségrégation d&#39;interface (ISP)</title>
      <link>https://www.wikiod.com/fr/solid-principles/principe-de-segregation-dinterface-isp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/solid-principles/principe-de-segregation-dinterface-isp/</guid>
      <description>Le principe stipule qu&amp;rsquo;aucun client ne doit être contraint de dépendre de méthodes qu&amp;rsquo;il n&amp;rsquo;utilise pas. Un client ne devrait jamais être forcé d&amp;rsquo;implémenter une interface qu&amp;rsquo;il n&amp;rsquo;utilise pas ou un client ne devrait pas être forcé de dépendre de méthodes qu&amp;rsquo;il n&amp;rsquo;utilise pas.
Principe de séparation des interfaces C# # Ici, nous donnons un exemple de violation ISP, puis refactorisons cette violation. Sans parler de choses inutiles, sautons dans le code.</description>
    </item>
    
  </channel>
</rss>
