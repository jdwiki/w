<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutoriel OCaml on </title>
    <link>https://www.wikiod.com/fr/docs/ocaml/</link>
    <description>Recent content in Tutoriel OCaml on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/fr/docs/ocaml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Débuter avec OCaml</title>
      <link>https://www.wikiod.com/fr/ocaml/debuter-avec-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/debuter-avec-ocaml/</guid>
      <description>Installation ou configuration # Installer OPAM # [OPAM][1] est un gestionnaire de paquets pour OCaml. Il construit et gère facilement les versions du compilateur et les bibliothèques OCaml.
Le moyen le plus simple d&amp;rsquo;installer OPAM sur votre système d&amp;rsquo;exploitation consiste à utiliser un gestionnaire de packages pour votre système. par exemple apt-get, yum ou homebrew.
## Instructions d&amp;rsquo;installation de Mac OSX
Mettez à jour les formules [homebrew][2] et installez OPAM.</description>
    </item>
    
    <item>
      <title>Correspondance de modèle</title>
      <link>https://www.wikiod.com/fr/ocaml/correspondance-de-modele/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/correspondance-de-modele/</guid>
      <description>Fonction factorielle utilisant la correspondance de modèle # let rec factorial n = match n with | 0 | 1 -&amp;gt; 1 | n -&amp;gt; n * (factorial (n - 1)) Cette fonction correspond à la fois aux valeurs 0 et 1 et les mappe au cas de base de notre définition récursive. Ensuite, tous les autres nombres correspondent à l&amp;rsquo;appel récursif de cette fonction.
Évaluation des expressions booléennes # Nous définissons le type d&amp;rsquo;expressions booléennes dont les atomes sont identifiés par des chaînes comme</description>
    </item>
    
    <item>
      <title>Écrivez votre premier script OCaml</title>
      <link>https://www.wikiod.com/fr/ocaml/ecrivez-votre-premier-script-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/ecrivez-votre-premier-script-ocaml/</guid>
      <description>Bonjour le monde # Cet exemple suppose que vous avez [installé OCaml][1].
Compilation du code OCaml # Créez un nouveau fichier nommé hello.ml, avec le contenu suivant :
print_string &amp;quot;Hello world!\n&amp;quot; ocamlc est le compilateur OCaml. Pour compiler et exécuter ce script, exécutez
$ ocamlc -o hello hello.ml puis exécutez le binaire résultant
$ ./hello Hello world! Exécution du code OCaml # Vous pouvez également exécuter ce script sans le compiler dans un binaire.</description>
    </item>
    
    <item>
      <title>OcamlbuildComment</title>
      <link>https://www.wikiod.com/fr/ocaml/ocamlbuildcomment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/ocamlbuildcomment/</guid>
      <description>Exemple de base sans dépendance externe # Si votre projet n&amp;rsquo;a pas de dépendance externe et a foo.ml comme point d&amp;rsquo;entrée principal, vous pouvez compiler une version bytecode avec
ocamlbuild foo.byte Pour obtenir un exécutable natif, exécutez
ocamlbuild foo.native Projet dépendant de bibliothèques externes # Si votre projet dépend des bibliothèques externes, vous devez d&amp;rsquo;abord les installer avec opam. En supposant que vos dépendances sont foo et bar et que le point d&amp;rsquo;entrée principal de votre projet est foobar.</description>
    </item>
    
    <item>
      <title>Fonctions d&#39;ordre supérieur</title>
      <link>https://www.wikiod.com/fr/ocaml/fonctions-dordre-superieur/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/fonctions-dordre-superieur/</guid>
      <description>Syntaxe # val (|&amp;gt;) : &#39;a -&amp;gt; (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;b val (@@) : (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a -&amp;gt; &#39;b Algorithmes génériques # Les fonctions d&amp;rsquo;ordre supérieur peuvent être utilisées pour implémenter des algorithmes génériques, abandonnant la responsabilité de fournir les derniers détails à l&amp;rsquo;utilisateur. Par exemple, List.sort attend une fonction de comparaison, qui permet d&amp;rsquo;implémenter différentes manières de trier. Ici, nous implémentons un tri des chaînes insensible à la casse :</description>
    </item>
    
    <item>
      <title>Traitement de la liste</title>
      <link>https://www.wikiod.com/fr/ocaml/traitement-de-la-liste/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/traitement-de-la-liste/</guid>
      <description>Liste.Carte # List.map a la signature (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a list -&amp;gt; &#39;b list qui en anglais est une fonction qui prend une fonction (nous l&amp;rsquo;appellerons la fonction de mappage) à partir d&amp;rsquo;un type (à savoir &#39;a) à un autre type (à savoir &#39;b) et une liste du premier type. La fonction renvoie une liste du deuxième type où chaque élément est le résultat de l&amp;rsquo;appel de la fonction de mappage sur un élément de la première liste.</description>
    </item>
    
    <item>
      <title>Les fonctions</title>
      <link>https://www.wikiod.com/fr/ocaml/les-fonctions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/les-fonctions/</guid>
      <description>Fonctions anonymes # Les fonctions étant des valeurs ordinaires, il existe une syntaxe pratique pour créer des fonctions sans nom :
List.map (fun x -&amp;gt; x * x) [1; 2; 3; 4] (* - : int list = [1; 4; 9; 16] *) C&amp;rsquo;est pratique, car sinon nous devrions d&amp;rsquo;abord nommer la fonction (voir [let][1]) pour pouvoir l&amp;rsquo;utiliser :
let square x = x * x (* val square : int -&amp;gt; int = &amp;lt;fun&amp;gt; *) List.</description>
    </item>
    
    <item>
      <title>Canalisations, fichiers et flux</title>
      <link>https://www.wikiod.com/fr/ocaml/canalisations-fichiers-et-flux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/canalisations-fichiers-et-flux/</guid>
      <description>Lire à partir de l&amp;rsquo;entrée standard et imprimer sur la sortie standard # Nous préparons un fichier appelé reverser.ml avec le contenu suivant :
let acc = ref [] in try while true do acc := read_line () :: !acc; done with End_of_file -&amp;gt; print_string (String.concat &amp;quot;\n&amp;quot; !acc) Nous compilons ensuite notre programme à l&amp;rsquo;aide de la commande suivante :
$ ocamlc -o reverser.byte reverser.ml Nous le testons en redirigeant les données vers notre nouvel exécutable :</description>
    </item>
    
    <item>
      <title>Pièges courants</title>
      <link>https://www.wikiod.com/fr/ocaml/pieges-courants/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/pieges-courants/</guid>
      <description>Utiliser le mauvais opérateur # En OCaml, il existe différents opérateurs arithmétiques pour les flottants et les entiers. De plus, ces opérateurs ne peuvent être utilisés que sur 2 flottants ou 2 entiers. Voici des expressions invalides en OCaml
1.0 + 2.0 1 + 2.0 1 +. 2 1 +. 2.0 L&amp;rsquo;expression correcte pour chacun de ces respectivement sont
1. +. 2. float_of_int 1 +. 2. 1 + 2 float_of_int 1 +.</description>
    </item>
    
    <item>
      <title>Champs d&#39;enregistrement modifiables</title>
      <link>https://www.wikiod.com/fr/ocaml/champs-denregistrement-modifiables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fr/ocaml/champs-denregistrement-modifiables/</guid>
      <description>Comme la plupart des valeurs OCaml, les enregistrements sont immuables par défaut. Cependant, comme OCaml gère également la programmation impérative, il fournit un moyen de rendre les champs individuels mutables. Les champs mutables peuvent être modifiés sur place par affectation, plutôt que d&amp;rsquo;avoir à recourir aux techniques fonctionnelles habituelles, telles que la mise à jour fonctionnelle.
Tout en introduisant des effets secondaires, les champs modifiables peuvent entraîner une amélioration des performances lorsqu&amp;rsquo;ils sont utilisés correctement.</description>
    </item>
    
  </channel>
</rss>
