<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de idioma Elm on </title>
    <link>https://www.wikiod.com/pt/docs/elm/</link>
    <description>Recent content in Tutorial de idioma Elm on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/elm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução à linguagem Elm</title>
      <link>https://www.wikiod.com/pt/elm/introducao-a-linguagem-elm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/introducao-a-linguagem-elm/</guid>
      <description>Instalação # Para iniciar o desenvolvimento com Elm, você precisa instalar um conjunto de ferramentas chamado elm-platform.
Inclui: elm-make, elm-reator, elm-repl e elm-package.
Todas essas ferramentas estão disponíveis através do CLI, ou seja, você pode usá-las a partir do seu terminal.
Escolha um dos seguintes métodos para instalar o Elm:
Usando o instalador # Baixe o instalador do site oficial e siga o assistente de instalação.
Usando npm # Você pode usar o Node Package Manager para instalar a plataforma Elm.</description>
    </item>
    
    <item>
      <title>Portas (interoperabilidade JS)</title>
      <link>https://www.wikiod.com/pt/elm/portas-interoperabilidade-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/portas-interoperabilidade-js/</guid>
      <description>Sintaxe # Elm (recebendo): port functionName : (valor -&amp;gt; msg) -&amp;gt; Sub msg JS (enviando): app.ports.functionName.send(value) Elm (enviando): port functionName : args -&amp;gt; Cmd msg JS (recebendo): app.ports.functionName.subscribe(function(args) { &amp;hellip; }); Consulte http://guide.elm-lang.org/interop/javascript.html do The Elm Guide para ajudar a entender esses exemplos.
Extrovertido # As portas de saída são usadas como Comandos, que você retorna da sua função update.
Lado do olmo # Defina a porta de saída:
port output : () -&amp;gt; Cmd msg Neste exemplo, enviamos uma Tupla vazia, apenas para acionar uma assinatura no lado do JavaScript.</description>
    </item>
    
    <item>
      <title>A arquitetura do olmo</title>
      <link>https://www.wikiod.com/pt/elm/a-arquitetura-do-olmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/a-arquitetura-do-olmo/</guid>
      <description>A maneira recomendada de estruturar seus aplicativos é chamada de &amp;lsquo;Arquitetura Elm&amp;rsquo;.
O programa mais simples consiste em um registro model armazenando todos os dados que podem ser atualizados, um tipo de união Msg que define como seu programa atualiza esses dados, uma função update que pega o modelo e uma Msg e retorna um novo modelo e uma função view que recebe um modelo e retorna o HTML que sua página exibirá.</description>
    </item>
    
    <item>
      <title>Listas e Iteração</title>
      <link>https://www.wikiod.com/pt/elm/listas-e-iteracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/listas-e-iteracao/</guid>
      <description>A Lista (lista vinculada) brilha no acesso sequencial:
acessando o primeiro elemento prefixando-se à frente da lista excluindo da frente da lista Por outro lado, não é ideal para acesso aleatório (ou seja, obter o enésimo elemento) e travessia na ordem inversa, e você pode ter mais sorte (e desempenho) com a estrutura de dados Array.
Criando uma lista por intervalo # Antes de 0.18.0, você pode criar intervalos como este:</description>
    </item>
    
    <item>
      <title>Depuração</title>
      <link>https://www.wikiod.com/pt/elm/depuracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/depuracao/</guid>
      <description>Sintaxe # Debug.log &amp;ldquo;tag&amp;rdquo; anyValue O Debug.log recebe dois parâmetros, um String para marcar a saída de depuração no console (para que você saiba de onde está vindo/a que corresponde a mensagem) e um valor de qualquer tipo. Debug.log executa o efeito colateral de registrar a tag e o valor no console JavaScript e, em seguida, retorna o valor. A implementação em JS pode ser algo como:
function log (tag, value){ console.</description>
    </item>
    
    <item>
      <title>Tipos, Variáveis ​​de Tipo e Construtores de Tipo</title>
      <link>https://www.wikiod.com/pt/elm/tipos-variaveis-de-tipo-e-construtores-de-tipo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/tipos-variaveis-de-tipo-e-construtores-de-tipo/</guid>
      <description>Por favor, brinque com esses conceitos para realmente dominá-los! O elm-repl (veja a [Introdução ao REPL] 1) é provavelmente um bom lugar para brincar com o código acima. Você também pode jogar com elm-repl online.
Melhorando a segurança de tipos usando novos tipos # Os tipos de alias reduzem o clichê e aumentam a legibilidade, mas não são mais seguros do que o próprio tipo de alias. Considere o seguinte:</description>
    </item>
    
    <item>
      <title>Funções e Aplicação Parcial</title>
      <link>https://www.wikiod.com/pt/elm/funcoes-e-aplicacao-parcial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/funcoes-e-aplicacao-parcial/</guid>
      <description>Sintaxe # &amp;ndash; definir uma função sem argumentos parece o mesmo que simplesmente definir um valor idioma = &amp;ldquo;Olmo&amp;rdquo; &amp;ndash; chamando uma função sem argumentos informando seu nome Língua &amp;ndash; os parâmetros são separados por espaços e seguem o nome da função adicione x y = x + y &amp;ndash; chama uma função da mesma forma adicionar 5 2 &amp;ndash; aplica parcialmente uma função fornecendo apenas alguns de seus parâmetros incrementar = adicionar 1 &amp;ndash; use o operador |&amp;gt; para passar a expressão da esquerda para a função da direita dez = 9 |&amp;gt; incremento &amp;ndash; o &amp;lt;| operador passa a expressão à direita para a função à esquerda incrementar &amp;lt;| adicionar 5 4 &amp;ndash; encadeia/compõe duas funções junto com o operador &amp;raquo; para trásYell = String.</description>
    </item>
    
    <item>
      <title>Json.Decode</title>
      <link>https://www.wikiod.com/pt/elm/jsondecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/jsondecode/</guid>
      <description>Json.Decode expõe duas funções para decodificar uma carga útil, a primeira é decodeValue que tenta decodificar um Json.Encode.Value, a segunda é decodeString que tenta decodificar uma string JSON. Ambas as funções aceitam 2 parâmetros, um decodificador e uma string Json.Encode.Value ou Json.
Pré-decodifique um campo e decodifique o resto dependendo desse valor decodificado # Os exemplos a seguir podem ser testados em https://ellie-app.com/m9vmQ8NcMc/0.
import Html exposing (..) import Json.Decode payload = &amp;quot;&amp;quot;&amp;quot; [ { &amp;quot;bark&amp;quot;: true, &amp;quot;tag&amp;quot;: &amp;quot;dog&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Zap&amp;quot;, &amp;quot;playful&amp;quot;: true } , { &amp;quot;whiskers&amp;quot;: true, &amp;quot;tag&amp;quot; : &amp;quot;cat&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Felix&amp;quot; } , {&amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;, &amp;quot;tag&amp;quot;: &amp;quot;tomato&amp;quot;} ] &amp;quot;&amp;quot;&amp;quot; -- OUR MODELS type alias Dog = { bark: Bool , name: String , playful: Bool } type alias Cat = { whiskers: Bool , name: String } -- OUR DIFFERENT ANIMALS type Animal = DogAnimal Dog | CatAnimal Cat | NoAnimal main = Json.</description>
    </item>
    
    <item>
      <title>Coletando Tuplas de Dados, Registros e Dicionários</title>
      <link>https://www.wikiod.com/pt/elm/coletando-tuplas-de-dados-registros-e-dicionarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/coletando-tuplas-de-dados-registros-e-dicionarios/</guid>
      <description>Dicionários # Os dicionários são implementados em uma biblioteca central Dict.
Um dicionário mapeando chaves exclusivas para valores. As chaves podem ser qualquer tipo comparável. Isso inclui Int, Float, Time, Char, String e tuplas ou listas de tipos comparáveis.
As operações de inserção, remoção e consulta levam tempo O(log n).
Diferentemente das Tuplas e Registros, os Dicionários podem alterar sua estrutura, ou seja, é possível adicionar e remover chaves.
É possível atualizar um valor por uma chave.</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/elm/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elm/correspondencia-de-padroes/</guid>
      <description>Argumento desconstruído de tipo único # type ProjectIdType = ProjectId String getProject : ProjectIdType -&amp;gt; Cmd Msg getProject (ProjectId id) = Http.get &amp;lt;| &amp;quot;/projects/&amp;quot; ++ id Argumentos da função # type Dog = Dog String dogName1 dog = case dog of Dog name -&amp;gt; name dogName2 (Dog name) -&amp;gt; name dogName1 e dogName2 são equivalentes. Observe que isso funciona apenas para ADTs que possuem um único construtor.
type alias Pet = { name: String , weight: Float } render : Pet -&amp;gt; String render ({name, weight} as pet) = (findPetEmoji pet) ++ &amp;quot; &amp;quot; ++ name ++ &amp;quot; weighs &amp;quot; ++ (toString weight) findPetEmoji : Pet -&amp;gt; String findPetEmoji pet = Debug.</description>
    </item>
    
  </channel>
</rss>
