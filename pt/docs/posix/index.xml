<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial POSIX on </title>
    <link>https://www.wikiod.com/pt/docs/posix/</link>
    <description>Recent content in Tutorial POSIX on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/posix/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao POSIX</title>
      <link>https://www.wikiod.com/pt/posix/introducao-ao-posix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/introducao-ao-posix/</guid>
      <description>O que é POSIX? # POSIX significa &amp;ldquo;Portable Operating System Interface&amp;rdquo; e define um conjunto de padrões para fornecer compatibilidade entre diferentes plataformas de computação. A versão atual do padrão é IEEE 1003.1 2016 e pode ser acessada a partir do OpenGroup especificação POSIX. As versões anteriores incluem POSIX 2004 e POSIX 1997. A edição POSIX 2016 é essencialmente POSIX 2008 mais errata (também houve uma versão POSIX 2013).
O POSIX define várias interfaces de ferramentas, comandos e APIs para sistemas operacionais do tipo UNIX e outros.</description>
    </item>
    
    <item>
      <title>Temporizadores</title>
      <link>https://www.wikiod.com/pt/posix/temporizadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/temporizadores/</guid>
      <description>Temporizador POSIX com notificação SIGEV_THREAD # Este exemplo demonstra o uso do temporizador POSIX com o relógio CLOCK_REALTIME e o método de notificação SIGEV_THREAD.
#include &amp;lt;stdio.h&amp;gt; /* for puts() */ #include &amp;lt;string.h&amp;gt; /* for memset() */ #include &amp;lt;unistd.h&amp;gt; /* for sleep() */ #include &amp;lt;stdlib.h&amp;gt; /* for EXIT_SUCCESS */ #include &amp;lt;signal.h&amp;gt; /* for `struct sigevent` and SIGEV_THREAD */ #include &amp;lt;time.h&amp;gt; /* for timer_create(), `struct itimerspec`, * timer_t and CLOCK_REALTIME */ void thread_handler(union sigval sv) { char *s = sv.</description>
    </item>
    
    <item>
      <title>tomadas</title>
      <link>https://www.wikiod.com/pt/posix/tomadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/tomadas/</guid>
      <description>Servidor de eco simultâneo TCP # Neste exemplo, criaremos um servidor de eco simples que escutará na porta especificada e será capaz de lidar com novas conexões:
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;time.h&amp;gt; /** Connection handler - this will be executed in the new process, after forking, and it will read all the data from the socket, while available and to echo it on the local terminal.</description>
    </item>
    
    <item>
      <title>Sinais</title>
      <link>https://www.wikiod.com/pt/posix/sinais/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/sinais/</guid>
      <description>Sintaxe # alarme não assinado (segundos não assinados); int kill(pid_t pid, int sig); Parâmetros # Função, Parâmetro(s), Valor de Retorno Descrição alarme() nome da função segundos não assinados Segundos para disparar um alarme ou 0 para cancelar qualquer alarme pendente &amp;gt;= 0 0 se nenhum outro alarme estava pendente, senão o número de segundos que o alarme pendente ainda estava aberto. Esta função não falhará. - - kill() nome da função pid_t pid .</description>
    </item>
    
    <item>
      <title>Tópicos</title>
      <link>https://www.wikiod.com/pt/posix/topicos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/topicos/</guid>
      <description>Uso simples de mutex # A biblioteca de threads POSIX fornece implementação da primitiva mutex, usada para exclusão mútua. Mutex é criado usando pthread_mutex_init, e destruído usando pthread_mutex_destroy. A obtenção de um mutex pode ser feita usando pthread_mutex_lock ou pthread_mutex_trylock, (dependendo se o tempo limite for desejado) e a liberação de um mutex é feita através de pthread_mutex_unlock.
Segue um exemplo simples usando um mutex para serializar o acesso à seção crítica.</description>
    </item>
    
    <item>
      <title>Processos</title>
      <link>https://www.wikiod.com/pt/posix/processos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/processos/</guid>
      <description>Sintaxe # pid_t getpid(void); pid_t getppid(void); pid_t forquilha(void); pid_t waitpid(pid_t pid, int *wstatus, int opções); int execv(const char *path, char *const argv[]); Parâmetros # Função, Parâmetro(s), Valor de Retorno Descrição fork() nome da função nenhum s/d Retorna PID, 0 ou -1 O processo de chamada recebe o PID do processo recém-criado ou -1 em caso de falha. O filho (o processo recém-criado) recebe 0. Em caso de falha, configure errno para EAGAIN ou ENOMEM - - execv() nome da função const char *caminho String contendo o nome do executável (pode incluir o caminho) char *const argv[] Matriz de ponteiro de string como argumentos Retorna -1 em caso de falha Em caso de sucesso, esta função não retorna.</description>
    </item>
    
    <item>
      <title>Sistema de arquivo</title>
      <link>https://www.wikiod.com/pt/posix/sistema-de-arquivo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/sistema-de-arquivo/</guid>
      <description>Remover arquivos recursivamente (nftw, não thread-safe) # #define _XOPEN_SOURCE 500 #include &amp;lt;stdlib.h&amp;gt; /* for exit() */ #include &amp;lt;stdio.h&amp;gt; /* for remove() */ #include &amp;lt;ftw.h&amp;gt; /* for nftw() */ int unlink_cb( const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) { return remove(fpath); } int rm_rf(const char *path) { return nftw(path, unlink_cb, 64 /* number of simultaneously opened fds, up to OPEN_MAX */, FTW_DEPTH | FTW_PHYS); } Sinalizador FTW_PHYS significa não seguir links simbólicos</description>
    </item>
    
    <item>
      <title>Tubos</title>
      <link>https://www.wikiod.com/pt/posix/tubos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/tubos/</guid>
      <description>Pipes são um mecanismo para comunicação unidirecional entre processos ou entre threads dentro do escopo de uma única máquina. Logicamente, um pipe consiste em dois terminais conectados, um no qual os dados podem ser gravados e outro a partir do qual esses dados podem ser lidos posteriormente, com um buffer de dados entre os quais as gravações e leituras não precisam ser síncronas. Os tubos devem ser diferenciados dos pipelines de casca, que são uma aplicação de tubos.</description>
    </item>
    
    <item>
      <title>Bloqueios de arquivo</title>
      <link>https://www.wikiod.com/pt/posix/bloqueios-de-arquivo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/bloqueios-de-arquivo/</guid>
      <description>Sintaxe # int fcntl(int fd, int cmd, struct bando*); int lockf(int fd, int cmd, off_t len); Bloqueios de registro POSIX (fcntl) # Este exemplo demonstra o uso de bloqueios de registro POSIX (também conhecidos como bloqueios associados ao processo), fornecidos pela função fcntl (padrão base POSIX).
Notas:
Bloqueios exclusivos e compartilhados são suportados. Pode ser aplicado a um intervalo de bytes, expandindo-se opcionalmente automaticamente quando os dados forem anexados no futuro (controlado por struct band).</description>
    </item>
    
    <item>
      <title>Multiplexação de entradasaída</title>
      <link>https://www.wikiod.com/pt/posix/multiplexacao-de-entradasaida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/posix/multiplexacao-de-entradasaida/</guid>
      <description>O IO pode ser bloqueante/não bloqueante e síncrono/assíncrono. A API POSIX fornece API de bloqueio síncrono (por exemplo, chamadas clássicas de leitura, gravação, envio, recv), API síncrona sem bloqueio (mesmas funções, descritores de arquivo abertos com o sinalizador O_NONBLOCK e chamadas de multiplexação IO) e API assíncrona (funções começando com aio_).
A API síncrona geralmente é usada com o estilo &amp;ldquo;um thread/processo por fd&amp;rdquo;. Isso é terrível para os recursos. A API sem bloqueio permite operar com um conjunto de fds em um thread.</description>
    </item>
    
  </channel>
</rss>
