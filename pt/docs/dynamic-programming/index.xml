<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de programação dinâmica on </title>
    <link>https://www.wikiod.com/pt/docs/dynamic-programming/</link>
    <description>Recent content in Tutorial de programação dinâmica on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução à programação dinâmica</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/introducao-a-programacao-dinamica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/introducao-a-programacao-dinamica/</guid>
      <description>Introdução à programação dinâmica # Programação dinâmica resolve problemas combinando as soluções para subproblemas. Pode ser análogo ao método de dividir e conquistar, onde o problema é particionado em subproblemas disjuntos, os subproblemas são resolvidos recursivamente e depois combinados para encontrar a solução do problema original. Em contraste, a programação dinâmica se aplica quando os subproblemas se sobrepõem - ou seja, quando os subproblemas compartilham subsubproblemas. Nesse contexto, um algoritmo de divisão e conquista faz mais trabalho do que o necessário, resolvendo repetidamente os subsubproblemas comuns.</description>
    </item>
    
    <item>
      <title>Problema de troca de moedas</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/problema-de-troca-de-moedas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/problema-de-troca-de-moedas/</guid>
      <description>Número de maneiras de obter o total # Dadas moedas de diferentes denominações e um total, de quantas maneiras podemos combinar essas moedas para obter o total? Digamos que temos coins = {1, 2, 3} e um total = 5, podemos obter o total de 5 maneiras:
1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 2 3 O problema está intimamente relacionado ao problema da mochila.</description>
    </item>
    
    <item>
      <title>Resolvendo problemas de gráfico usando programação dinâmica</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/resolvendo-problemas-de-grafico-usando-programacao-dinamica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/resolvendo-problemas-de-grafico-usando-programacao-dinamica/</guid>
      <description>Algoritmo Floyd-Warshall # Cobertura Mínima de Vértices # Cobertura mínima de vértices é um problema clássico de grafos. Digamos que em uma cidade temos algumas estradas conectando alguns pontos. Vamos representar as estradas usando arestas e os pontos usando nós. Vamos pegar dois gráficos de exemplo:
Queremos colocar vigias em alguns pontos. Um vigia pode vigiar todas as estradas conectadas ao ponto. O problema é: qual é o número mínimo de vigias necessários para cobrir todas as estradas?</description>
    </item>
    
    <item>
      <title>Seleção de atividade ponderada</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/selecao-de-atividade-ponderada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/selecao-de-atividade-ponderada/</guid>
      <description>Algoritmo de agendamento de trabalho ponderado # O Algoritmo de Agendamento de Trabalho Ponderado também pode ser indicado como Algoritmo de Seleção de Atividade Ponderada.
O problema é que, dado certos trabalhos com hora de início e hora de término, e um lucro que você obtém quando termina o trabalho, qual é o lucro máximo que você pode obter, considerando que dois trabalhos não podem ser executados em paralelo?
Este parece Seleção de Atividade usando Algoritmo Ganancioso, mas há uma reviravolta adicional.</description>
    </item>
    
    <item>
      <title>Problema da mochila</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/problema-da-mochila/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/problema-da-mochila/</guid>
      <description>O problema da mochila ou problema da mochila é um problema em otimização combinatória. Dado um conjunto de itens, cada um com um peso e um valor, determine o número de cada item a ser incluído em uma coleção de modo que o peso total seja menor ou igual a um determinado limite e o valor total seja o maior possível. Seu nome deriva do problema enfrentado por alguém que é limitado por uma mochila de tamanho fixo e deve enchê-la com os itens mais valiosos.</description>
    </item>
    
    <item>
      <title>Algoritmos Relacionados à Subsequência</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/algoritmos-relacionados-a-subsequencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/algoritmos-relacionados-a-subsequencia/</guid>
      <description>Subsequência crescente mais longa # A tarefa é encontrar o comprimento da subsequência mais longa em uma determinada matriz de inteiros, de modo que todos os elementos da subsequência sejam classificados em ordem crescente. Por exemplo, o comprimento da subsequência crescente mais longa (LIS) para {15, 27, 14, 38, 26, 55, 46, 65, 85} é 6 e a subsequência crescente mais longa é * *{15, 27, 38, 55, 65, 85}**. Novamente para {3, 4, -1, 0, 6, 2, 3} o comprimento do LIS é 4 e a subsequência é {-1, 0, 2, 3}.</description>
    </item>
    
    <item>
      <title>Distorção Dinâmica do Tempo</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/distorcao-dinamica-do-tempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/distorcao-dinamica-do-tempo/</guid>
      <description>Introdução à distorção dinâmica do tempo # Dynamic Time Warping(DTW) é um algoritmo para medir a semelhança entre duas sequências temporais que podem variar em velocidade. Por exemplo, semelhanças na caminhada podem ser detectadas usando DTW, mesmo se uma pessoa estiver andando mais rápido que a outra, ou se houver acelerações e desacelerações durante o curso de uma observação. Ele pode ser usado para combinar um comando de voz de amostra com outro comando, mesmo se a pessoa falar mais rápido ou mais devagar do que a voz de amostra pré-gravada.</description>
    </item>
    
    <item>
      <title>Multiplicação da Cadeia de Matrizes</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/multiplicacao-da-cadeia-de-matrizes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/multiplicacao-da-cadeia-de-matrizes/</guid>
      <description>Solução recursiva # Multiplicação da cadeia de matrizes é um problema de otimização que pode ser resolvido usando programação dinâmica. Dada uma sequência de matrizes, o objetivo é encontrar a maneira mais eficiente de multiplicar essas matrizes. O problema não é realmente realizar as multiplicações, mas apenas decidir a sequência das multiplicações de matrizes envolvidas.
Digamos que temos duas matrizes A1 e A2 de dimensão m * n e p * q .</description>
    </item>
    
    <item>
      <title>Corte de haste</title>
      <link>https://www.wikiod.com/pt/dynamic-programming/corte-de-haste/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dynamic-programming/corte-de-haste/</guid>
      <description>Cortando a haste para obter o lucro máximo # Dada uma haste de comprimento n polegadas e uma matriz de comprimento m de preços que contém preços de todas as peças de tamanho menor que n. Temos que encontrar o valor máximo que se pode obter cortando a vara e vendendo as peças. Por exemplo, se o comprimento da haste for 8 e os valores das diferentes peças forem fornecidos da seguinte forma, o valor máximo obtido será 22.</description>
    </item>
    
  </channel>
</rss>
