<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de linguagem de prólogo on </title>
    <link>https://www.wikiod.com/pt/docs/prolog/</link>
    <description>Recent content in Tutorial de linguagem de prólogo on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/prolog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Prolog Language</title>
      <link>https://www.wikiod.com/pt/prolog/introducao-ao-prolog-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/introducao-ao-prolog-language/</guid>
      <description>Programação de banco de dados # Prolog categoriza tudo em:
Atoms - Qualquer sequência de caracteres que não comece com letras maiúsculas. Por exemplo - a, b, ok Números - Não há sintaxe especial para números, nenhuma declaração é necessária. Por exemplo, 1, 22, 35,8 Variáveis - Uma string que começa com um caractere maiúsculo ou sublinhado (_). Por exemplo, X, Y, Abc, AA Termos Complexos - São feitos a partir de um functor e uma sequência de argumentos.</description>
    </item>
    
    <item>
      <title>Estruturas de controle</title>
      <link>https://www.wikiod.com/pt/prolog/estruturas-de-controle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/estruturas-de-controle/</guid>
      <description>Disjunção (OR lógico), implícito vs. explícito # Prolog tenta cláusulas alternativas para um predicado na ordem de aparecimento:
likes(alice, music). likes(bob, hiking). // Either alice likes music, or bob likes hiking will succeed. O operador de disjunção (OR) ; pode ser usado para expressar isso em uma regra:
likes(P,Q) :- ( P = alice , Q = music ) ; ( P = bob , Q = hiking ). Os parênteses são importantes aqui para maior clareza.</description>
    </item>
    
    <item>
      <title>Estruturas de dados</title>
      <link>https://www.wikiod.com/pt/prolog/estruturas-de-dados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/estruturas-de-dados/</guid>
      <description>Listas de associações # Em todos os sistemas Prolog sérios, listas de associação estão disponíveis para permitir acesso mais rápido que linear a uma coleção de elementos. Essas listas de associações geralmente são baseadas em árvores balanceadas, como AVL árvores. Existe uma biblioteca de domínio público chamada library(assoc) que acompanha muitos sistemas Prolog e fornece operações O(log(N)) para inserir, buscar e alterar elementos em uma coleção.
Listas # Listas são um tipo especial de termo composto.</description>
    </item>
    
    <item>
      <title>Monotonicidade</title>
      <link>https://www.wikiod.com/pt/prolog/monotonicidade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/monotonicidade/</guid>
      <description>Alternativas monotônicas para construções não monotônicas # Aqui estão alguns exemplos de como usar predicados monotônicos em vez de construções impuras e não monotônicas em seus programas:
dif/2 deve ser usado ao invés de construções não monotônicas como (\=)/2 restrições aritméticas (CLP(FD), CLP(Q) e outros) devem ser usadas em vez de predicados aritméticos moderados !/0 quase sempre leva a programas não monotônicos e deve ser evitado inteiramente. erros de instanciação podem surgir em situações em que você não pode tomar uma decisão acertada neste momento.</description>
    </item>
    
    <item>
      <title>Árvores de derivação</title>
      <link>https://www.wikiod.com/pt/prolog/arvores-de-derivacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/arvores-de-derivacao/</guid>
      <description>Árvore de provas # A árvore de prova (também árvore de busca ou árvore de derivação) é uma árvore que mostra a execução de um programa Prolog. Esta árvore ajuda a visualizar o processo de retrocesso cronológico presente no Prolog. A raiz da árvore representa a consulta inicial e as ramificações são criadas quando ocorrem pontos de escolha. Cada nó na árvore representa, portanto, um objetivo. As ramificações só se tornam folhas quando verdadeiro/falso foi comprovado para o(s) objetivo(s) necessário(s) e a pesquisa no Prolog é realizada de forma da esquerda para a direita em profundidade.</description>
    </item>
    
    <item>
      <title>Raciocínio sobre dados</title>
      <link>https://www.wikiod.com/pt/prolog/raciocinio-sobre-dados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/raciocinio-sobre-dados/</guid>
      <description>Uma nova seção chamada Estruturas de dados ganhou vida, onde são fornecidas explicações de certas estruturas e alguns exemplos simples de criação. Para manter seu conteúdo conciso e organizado, ele não deve conter nenhuma documentação sobre manipulação de dados.
Portanto, esta seção foi renomeada para &amp;ldquo;Raciocínio sobre dados&amp;rdquo; com o objetivo de generalizar o raciocínio sobre dados em Prolog. Isso pode incluir tópicos que variam de &amp;lsquo;inferência de cima para baixo&amp;rsquo; a &amp;lsquo;percurso de listas&amp;rsquo;, bem como muitos outros.</description>
    </item>
    
    <item>
      <title>Programação Lógica de Restrições</title>
      <link>https://www.wikiod.com/pt/prolog/programacao-logica-de-restricoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/programacao-logica-de-restricoes/</guid>
      <description>CLP(FD) # Restrições CLP(FD) (Domínios Finitos) implementam aritmética sobre inteiros. Eles estão disponíveis em todas as implementações sérias do Prolog.
Existem dois principais casos de uso de restrições CLP(FD):
Aritmética inteira declarativa Resolver problemas combinatórios como planejamento, agendamento e alocação de tarefas. Exemplos:
?- X #= 1+2. X = 3. ?- 3 #= Y+2. Y = 1. Observe que se is/2 fosse usado na segunda consulta, ocorreria um erro de instanciação:</description>
    </item>
    
    <item>
      <title>Programação de ordem superior</title>
      <link>https://www.wikiod.com/pt/prolog/programacao-de-ordem-superior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/programacao-de-ordem-superior/</guid>
      <description>chamada/N predicados # A família de predicados call/N pode chamar objetivos Prolog arbitrários em tempo de execução:
?- G=true, call(G). true. ?- G=(true,false), call(G). false. lista de mapas/[2,3] # maplist/2 e maplist/3 são predicados de ordem superior, que permitem que a definição de um predicado seja levantada sobre um único elemento para listas de tais elementos. Esses predicados podem ser definidos usando call/2 e call/3 como blocos de construção e são fornecidos com muitos sistemas Prolog.</description>
    </item>
    
    <item>
      <title>Pureza Lógica</title>
      <link>https://www.wikiod.com/pt/prolog/pureza-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/pureza-logica/</guid>
      <description>dif/2 # O predicado dif/2 é um predicado puro: pode ser usado em todas as direções e com todos os padrões de instanciação, sempre significando que seus dois argumentos são diferentes.
Unificação # Unificação é uma relação pura. Ele não produz efeitos colaterais e pode ser usado em todas as direções, com um ou ambos os argumentos totalmente ou apenas parcialmente instanciados.
No Prolog, a unificação pode acontecer
explicitamente, usando predicados embutidos como (=)/2 ou unify_with_occurs_check/2 implicitamente, quando a unificação é usada para selecionar uma cláusula adequada.</description>
    </item>
    
    <item>
      <title>Usando Prolog Moderno</title>
      <link>https://www.wikiod.com/pt/prolog/usando-prolog-moderno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/prolog/usando-prolog-moderno/</guid>
      <description>CLP(FD) para aritmética inteira # Tradicionalmente, o Prolog realizava operações aritméticas usando os operadores is e =:=. No entanto, vários Prologs atuais oferecem CLP(FD) (Constraint Logic Programming over Finite Domains) como uma alternativa mais limpa para aritmética inteira. O CLP(FD) é baseado no armazenamento das restrições que se aplicam a um valor inteiro e na combinação delas na memória.
CLP(FD) é uma extensão na maioria dos Prologs que o suportam, então deve ser carregado explicitamente.</description>
    </item>
    
  </channel>
</rss>
