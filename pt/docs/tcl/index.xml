<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial tcl on </title>
    <link>https://www.wikiod.com/pt/docs/tcl/</link>
    <description>Recent content in Tutorial tcl on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/tcl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com tcl</title>
      <link>https://www.wikiod.com/pt/tcl/comecando-com-tcl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/comecando-com-tcl/</guid>
      <description>Instalação # Instalando o Tcl 8.6.4 no Windows:
A maneira mais fácil de obter o Tcl em uma máquina Windows é instalar o ActiveTcl distribution from ActiveState.
Navegue até www.activestate.com e siga os links para download the Free Community Edition of ActiveTcl for Windows (choose 32/64 bit version appropriately).
Execute o instalador que resultará em uma nova instalação do ActiveTcl usually in the C:\Tcl directory.
Abra um prompt de comando para testar a instalação, digite &amp;ldquo;tclsh&amp;rdquo; que should open an interactive tcl console.</description>
    </item>
    
    <item>
      <title>Expressões</title>
      <link>https://www.wikiod.com/pt/tcl/expressoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/expressoes/</guid>
      <description>Outro benefício de usar strings de expressão entre colchetes é que o compilador de bytes geralmente pode gerar código mais eficiente (5 - 10x mais rápido) a partir deles.
Os problemas com expressões sem chaves # É uma boa prática fornecer argumentos de string de expressão como strings entre colchetes. O título &amp;ldquo;Dupla Substituição&amp;rdquo; descreve as razões importantes por trás do mesmo.
O comando expr avalia uma string de expressão baseada em operador para calcular um valor.</description>
    </item>
    
    <item>
      <title>Argumentos do procedimento</title>
      <link>https://www.wikiod.com/pt/tcl/argumentos-do-procedimento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/argumentos-do-procedimento/</guid>
      <description>Referências: proc Expansão do argumento (seção 5)
Um procedimento que não aceita argumentos # proc myproc {} { puts &amp;quot;hi&amp;quot; } myproc # =&amp;gt; hi Uma lista de argumentos vazia (o segundo argumento após o nome do procedimento, &amp;ldquo;myproc&amp;rdquo;) significa que o procedimento não aceitará argumentos.
Um procedimento que aceita um número variável de argumentos # ### Definition proc myproc {alpha {beta {}} {gamma green}} { puts [list $alpha $beta $gamma] } ### Use myproc A # =&amp;gt; A {} green myproc A B # =&amp;gt; A B green myproc A B C # =&amp;gt; A B C Este procedimento aceita um, dois ou três argumentos: aqueles parâmetros cujos nomes são o primeiro item em uma lista de dois itens são opcionais.</description>
    </item>
    
    <item>
      <title>Dicionários</title>
      <link>https://www.wikiod.com/pt/tcl/dicionarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/dicionarios/</guid>
      <description>Dicionários em Tcl são values que mantêm um mapeamento de valores arbitrários para outros valores arbitrários. Eles foram introduzidos no Tcl 8.5, embora existam versões limitadas para (o agora não suportado) Tcl 8.4. Os dicionários são sintaticamente iguais às listas com números pares de elementos; o primeiro par de elementos é a primeira chave e valor do dicionário, o segundo par é a segunda tupla.
Desta forma:
fox &amp;quot;quick brown&amp;quot; dogs &amp;quot;lazy&amp;quot; é um dicionário válido.</description>
    </item>
    
    <item>
      <title>Variáveis</title>
      <link>https://www.wikiod.com/pt/tcl/variaveis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/variaveis/</guid>
      <description>Sintaxe # set varName ?valor? &amp;ndash; unset ?-nocomplain? , ?varName varName varName?
coloca $varName
coloca [set varName]
variável varName
global varName ?varName varName?
Parâmetros entre ?&amp;hellip;? como ?varName? representam argumentos opcionais para um comando Tcl.
Documentação: global, upvar
Atribuindo valores a variáveis # O comando set é usado para atribuir valores em Tcl. Quando é chamado com dois argumentos da seguinte maneira,
% set tempVar &amp;quot;This is a string.&amp;quot; This is a string.</description>
    </item>
    
    <item>
      <title>Expressões regulares</title>
      <link>https://www.wikiod.com/pt/tcl/expressoes-regulares/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/expressoes-regulares/</guid>
      <description>Sintaxe # regexp ?interruptores? exp string ?matchVar? ?subMatchVar subMatchVar &amp;hellip;? regsub ?interruptores? exp string subSpec ?varName? Este tópico não se destina a discutir as expressões regulares em si. Existem muitos recursos na internet explicando expressões regulares e ferramentas para ajudar a construir expressões regulares.
Este tópico tentará cobrir as opções e métodos comuns de uso de expressões regulares em Tcl e algumas das diferenças entre Tcl e outros mecanismos de expressão regular.</description>
    </item>
    
    <item>
      <title>Construções de linguagem Tcl</title>
      <link>https://www.wikiod.com/pt/tcl/construcoes-de-linguagem-tcl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/construcoes-de-linguagem-tcl/</guid>
      <description>Sintaxe # # Este é um comentário válido # Este é um { comentário } válido Colocando comentários # Comentários em Tcl são mais bem pensados ​​como outro comando. Um comentário consiste em um # seguido por qualquer número de caracteres até a próxima nova linha. Um comentário pode aparecer onde quer que um comando possa ser colocado.
# this is a valid comment proc hello { } { # the next comment needs the ; before it to indicate a new command is # being started.</description>
    </item>
    
    <item>
      <title>Nomes de caminhos e nomes de arquivos</title>
      <link>https://www.wikiod.com/pt/tcl/nomes-de-caminhos-e-nomes-de-arquivos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/nomes-de-caminhos-e-nomes-de-arquivos/</guid>
      <description>Sintaxe # nome do arquivo caminho do arquivo cauda do arquivo caminho do arquivo nome raiz do arquivo caminho do arquivo extensão do arquivo caminho do arquivo junção de arquivo caminho1 caminho2 &amp;hellip; normalizar arquivo caminho nome nativo do arquivo caminho Trabalhando com nomes de caminhos e nomes de arquivos # % set mypath /home/tcluser/sources/tcl/myproject/test.tcl /home/tcluser/sources/tcl/myproject/test.tcl % set dir [file dirname $mypath] /home/tcluser/sources/tcl/myproject % set filename [file tail $mypath] test.tcl % set basefilename [file rootname $filename] test % set extension [file extension $filename] .</description>
    </item>
    
    <item>
      <title>Estruturas de controle</title>
      <link>https://www.wikiod.com/pt/tcl/estruturas-de-controle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/tcl/estruturas-de-controle/</guid>
      <description>Sintaxe # se expr1 ?então? body1 elseif expr2 ?então? corpo2 &amp;hellip; ?mais? ?corpoN? para iniciar o teste do próximo corpo enquanto corpo de teste foreach varlist1 lista1 ?varlist2 lista2 &amp;hellip;? corpo Documentação: break, for, foreach, if, switch, uplevel, while
se / enquanto / para # se expr1 ?então? corpo1 elseif expr2 ?então? corpo2 &amp;hellip; ?mais? ?corpoN?
exprN é uma expressão que resulta em um valor booleano. bodyN é uma lista de comandos.</description>
    </item>
    
  </channel>
</rss>
