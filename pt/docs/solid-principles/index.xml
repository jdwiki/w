<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de princípios sólidos on </title>
    <link>https://www.wikiod.com/pt/docs/solid-principles/</link>
    <description>Recent content in Tutorial de princípios sólidos on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/solid-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com princípios sólidos</title>
      <link>https://www.wikiod.com/pt/solid-principles/comecando-com-principios-solidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/solid-principles/comecando-com-principios-solidos/</guid>
      <description>Princípio da Substituição de Liskov # Por que usar LSP
Cenário: Suponha que temos 3 bancos de dados (Clientes hipotecários, Clientes de contas correntes e Clientes de contas de poupança) que fornecem dados de clientes e precisamos de detalhes do cliente para o sobrenome do cliente. Agora podemos obter mais de 1 detalhe do cliente desses 3 bancos de dados em relação ao sobrenome.
Implementação
CAMADA DE MODELO DE NEGÓCIO:</description>
    </item>
    
    <item>
      <title>Princípio Aberto Fechado (OCP)</title>
      <link>https://www.wikiod.com/pt/solid-principles/principio-aberto-fechado-ocp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/solid-principles/principio-aberto-fechado-ocp/</guid>
      <description>Entidades de software (classe, módulos, funções etc) devem ser abertas para extensão, mas fechadas para modificação.
Princípio Fechado Aberto C# # Aqui, tentamos explicar o OCP usando a base de código. Primeiro, mostraremos um cenário que viola o OCP e, em seguida, removeremos essa violação.
Cálculo de área (Código de violação do OCP):
public class Rectangle{ public double Width {get; set;} public double Height {get; set;} } public class Circle{ public double Radious {get; set;} } public double getArea (object[] shapes){ double totalArea = 0; foreach(var shape in shapes){ if(shape is Rectangle){ Rectangle rectangle = (Rectangle)shape; totalArea += rectangle.</description>
    </item>
    
    <item>
      <title>Princípio de Inversão de Dependência (DIP)</title>
      <link>https://www.wikiod.com/pt/solid-principles/principio-de-inversao-de-dependencia-dip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/solid-principles/principio-de-inversao-de-dependencia-dip/</guid>
      <description>O princípio basicamente diz que Class deve depender de abstrações (por exemplo, interface, classes abstratas), não de detalhes específicos (implementações). Isso significa que você deve deixar o chamador criar as dependências em vez de deixar a própria classe criar as dependências.
Princípio de inversão de dependência C# # Para entender o Princípio de Inversão de Dependência (DIP), precisamos esclarecer o conceito sobre Inversão de Controle (IOC) e Injeção de Dependência (DI).</description>
    </item>
    
    <item>
      <title>Princípio de Responsabilidade Única (SRP)</title>
      <link>https://www.wikiod.com/pt/solid-principles/principio-de-responsabilidade-unica-srp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/solid-principles/principio-de-responsabilidade-unica-srp/</guid>
      <description>Nunca deve haver mais de um motivo para alterar qualquer coisa nas entidades de software (classe, função, arquivo etc). Uma classe, função, arquivo etc deve ter apenas um motivo para mudar.
Só porque você pode, não significa que você deve.
Princípio de Responsabilidade Única C# # Vamos primeiro ao problema. Dê uma olhada no código abaixo:
public class BankAccount { public BankAccount() {} public string AccountNumber { get; set; } public decimal AccountBalance { get; set; } public decimal CalculateInterest() { // Code to calculate Interest } } Aqui, a classe BankAccount contém as propriedades da conta e também calcula os juros da conta.</description>
    </item>
    
    <item>
      <title>Princípio de Segregação de Interface (ISP)</title>
      <link>https://www.wikiod.com/pt/solid-principles/principio-de-segregacao-de-interface-isp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/solid-principles/principio-de-segregacao-de-interface-isp/</guid>
      <description>O princípio afirma que nenhum cliente deve ser forçado a depender de métodos que não utiliza. Um cliente nunca deve ser forçado a implementar uma interface que não usa ou o cliente não deve ser forçado a depender de métodos que não usa.
Princípio de Segregação de Interface C# # Aqui damos um exemplo de violação de ISP e, em seguida, refatoramos essa violação. Sem falar coisas desnecessárias, vamos pular para o código.</description>
    </item>
    
  </channel>
</rss>
