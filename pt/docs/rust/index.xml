<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de ferrugem on </title>
    <link>https://www.wikiod.com/pt/docs/rust/</link>
    <description>Recent content in Tutorial de ferrugem on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com Rust</title>
      <link>https://www.wikiod.com/pt/rust/comecando-com-rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/comecando-com-rust/</guid>
      <description>Uso avançado de println! # println! (e seu irmão, [print!](https://doc.rust-lang. org/std/macro.print!.html)) fornece um mecanismo conveniente para produzir e imprimir texto que contém dados dinâmicos, semelhante à família de funções printf encontrada em muitas outras linguagens. Seu primeiro argumento é uma string de formato, que determina como os outros argumentos devem ser impressos como texto. A string de formato pode conter espaços reservados (incluídos em {}) para especificar que uma substituição deve ocorrer:</description>
    </item>
    
    <item>
      <title>Serde</title>
      <link>https://www.wikiod.com/pt/rust/serde/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/serde/</guid>
      <description>Serde é uma estrutura popular de serialização e desserialização para Rust, usada para converter dados serializados (por exemplo, JSON e XML) em estruturas Rust e vice-versa.
O Serde suporta vários formatos, incluindo: JSON, YAML, TOML, BSON, Pickle e XML.
Estrutura ↔ JSON # #main.rs
extern crate serde; extern crate serde_json; // Import this crate to derive the Serialize and Deserialize traits. #[macro_use] extern crate serde_derive; #[derive(Serialize, Deserialize, Debug)] struct Point { x: i32, y: i32, } fn main() { let point = Point { x: 1, y: 2 }; // Convert the Point to a packed JSON string.</description>
    </item>
    
    <item>
      <title>Características</title>
      <link>https://www.wikiod.com/pt/rust/caracteristicas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/caracteristicas/</guid>
      <description>Traits são uma forma de descrever um &amp;lsquo;contrato&amp;rsquo; que um &amp;lsquo;struct&amp;rsquo; deve implementar. Traits normalmente definem assinaturas de método, mas também podem fornecer implementações baseadas em outros métodos do trait, desde que os limites de traço permitam isso.
Para aqueles familiarizados com programação orientada a objetos, as características podem ser consideradas interfaces com algumas diferenças sutis.
Sintaxe # trait Trait { fn method(&amp;hellip;) -&amp;gt; ReturnType; &amp;hellip; }
trait Trait: Bound { fn method(&amp;hellip;) -&amp;gt; ReturnType; &amp;hellip; }</description>
    </item>
    
    <item>
      <title>rotações</title>
      <link>https://www.wikiod.com/pt/rust/rotacoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/rotacoes/</guid>
      <description>Sintaxe # loop { block } // loop infinito
while condição { bloco }
while let padrão = expr { bloco }
for pattern in expr { block } // expr deve implementar IntoIterator
continue // pula para o final do corpo do loop, iniciando uma nova iteração se necessário
break // interrompe o loop
&amp;lsquo;rótulo: loop { bloco }
&amp;lsquo;rótulo: while condição { bloco }
&amp;lsquo;label: while let pattern = expr { block }</description>
    </item>
    
    <item>
      <title>Guia de estilo de ferrugem</title>
      <link>https://www.wikiod.com/pt/rust/guia-de-estilo-de-ferrugem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/guia-de-estilo-de-ferrugem/</guid>
      <description>Embora não haja um guia oficial de estilo Rust, os exemplos a seguir mostram as convenções adotadas pela maioria dos projetos Rust. Seguir essas convenções alinhará o estilo do seu projeto com o da biblioteca padrão, tornando mais fácil para as pessoas verem a lógica em seu código.
As diretrizes oficiais de estilo Rust estavam disponíveis no repositório rust-lang/rust no GitHub, mas eles foram removidos recentemente, com migração pendente para o repositório rust-lang-nursery/fmt-rfcs.</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/rust/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/correspondencia-de-padroes/</guid>
      <description>Sintaxe # _ // padrão curinga, corresponde a qualquer coisa¹ ident // padrão de vinculação, corresponde a qualquer coisa e vincula-o a ident¹ ident @ pat // igual acima, mas permite combinar ainda mais o que está vinculado ref ident // padrão de vinculação, corresponde a qualquer coisa e vincula-o a uma referência ident¹ ref mut ident // padrão de vinculação, corresponde a qualquer coisa e vincula-o a uma referência mutável ident¹ &amp;amp;pat // corresponde a uma referência (pat, portanto, não é uma referência, mas o árbitro)¹ &amp;amp;mut pat // igual acima com uma referência mutável¹ CONST // corresponde a uma constante nomeada Struct { field1, field2 } // corresponde e desconstrói um valor de estrutura, veja abaixo a nota sobre campos¹ EnumVariant // corresponde a uma variante de enumeração EnumVariant(pat1, pat2) // corresponde a uma variante de enumeração e os parâmetros correspondentes EnumVariant(pat1, pat2, .</description>
    </item>
    
    <item>
      <title>Tempos de vida</title>
      <link>https://www.wikiod.com/pt/rust/tempos-de-vida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/tempos-de-vida/</guid>
      <description>Sintaxe # função fn&amp;lt;&amp;lsquo;a&amp;gt;(x: &amp;amp;&amp;lsquo;a Tipo)
struct Struct&amp;lt;&amp;lsquo;a&amp;gt; { x: &amp;amp;&amp;lsquo;a Tipo }
enum Enum&amp;lt;&amp;lsquo;a&amp;gt; { Variant(&amp;amp;&amp;lsquo;a Type) }
impl&amp;lt;&amp;lsquo;a&amp;gt; Struct&amp;lt;&amp;lsquo;a&amp;gt; { fn x&amp;lt;&amp;lsquo;a&amp;gt;(&amp;amp;self) -&amp;gt; &amp;amp;&amp;lsquo;a Type { self.x } }
impl&amp;lt;&amp;lsquo;a&amp;gt; Característica&amp;lt;&amp;lsquo;a&amp;gt; para Tipo
impl&amp;lt;&amp;lsquo;a&amp;gt; Característica para Tipo&amp;lt;&amp;lsquo;a&amp;gt;
fn function&amp;lt;F&amp;gt;(f: F) onde for&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Type)
struct Struct&amp;lt;F&amp;gt; onde for&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Type) { x: F }
enum Enum&amp;lt;F&amp;gt; onde for&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Type) { Variant(F) }
impl&amp;lt;F&amp;gt; Struct&amp;lt;F&amp;gt; onde for&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Type) { fn x(&amp;amp;self) -&amp;gt; &amp;amp;F { &amp;amp;self.</description>
    </item>
    
    <item>
      <title>ES de arquivo</title>
      <link>https://www.wikiod.com/pt/rust/es-de-arquivo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/es-de-arquivo/</guid>
      <description>Ler um arquivo como um todo como uma String # use std::fs::File; use std::io::Read; fn main() { let filename = &amp;quot;src/main.rs&amp;quot;; // Open the file in read-only mode. match File::open(filename) { // The file is open (no error). Ok(mut file) =&amp;gt; { let mut content = String::new(); // Read all the file content into a variable (ignoring the result of the operation). file.read_to_string(&amp;amp;mut content).unwrap(); println!(&amp;quot;{}&amp;quot;, content); // The file is automatically closed when is goes out of scope.</description>
    </item>
    
    <item>
      <title>Paralelismo</title>
      <link>https://www.wikiod.com/pt/rust/paralelismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/paralelismo/</guid>
      <description>O paralelismo é bem suportado pela biblioteca padrão do Rust através de várias classes, como o módulo std::thread, canais e atomics. Esta seção irá guiá-lo através do uso desses tipos.
Comunicação entre threads com canais # Os canais podem ser usados ​​para enviar dados de um thread para outro. Abaixo está um exemplo de um sistema produtor-consumidor simples, onde o thread principal produz os valores 0, 1, &amp;hellip;, 9, e o thread gerado os imprime:</description>
    </item>
    
    <item>
      <title>Cordas</title>
      <link>https://www.wikiod.com/pt/rust/cordas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rust/cordas/</guid>
      <description>Ao contrário de muitas outras linguagens, Rust tem dois tipos de string principais: String (um tipo de string alocado por heap) e &amp;amp;str (uma string emprestada, que não usa memória extra). Saber a diferença e quando usar cada um é vital para entender como o Rust funciona.
Manipulação básica de strings # fn main() { // Statically allocated string slice let hello = &amp;quot;Hello world&amp;quot;; // This is equivalent to the previous one let hello_again: &amp;amp;&#39;static str = &amp;quot;Hello world&amp;quot;; // An empty String let mut string = String::new(); // An empty String with a pre-allocated initial buffer let mut capacity = String::with_capacity(10); // Add a string slice to a String string.</description>
    </item>
    
  </channel>
</rss>
