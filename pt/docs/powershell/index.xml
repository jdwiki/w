<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial do PowerShell on </title>
    <link>https://www.wikiod.com/pt/docs/powershell/</link>
    <description>Recent content in Tutorial do PowerShell on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/powershell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao PowerShell</title>
      <link>https://www.wikiod.com/pt/powershell/introducao-ao-powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/introducao-ao-powershell/</guid>
      <description>Permitir que scripts armazenados em sua máquina sejam executados sem assinatura # Por motivos de segurança, o PowerShell é configurado por padrão para permitir apenas a execução de scripts assinados. A execução do comando a seguir permitirá que você execute scripts não assinados (você deve executar o PowerShell como administrador para fazer isso).
Set-ExecutionPolicy RemoteSigned Outra maneira de executar scripts do PowerShell é usar Bypass como ExecutionPolicy:
powershell.exe -ExecutionPolicy Bypass -File &amp;quot;c:\MyScript.</description>
    </item>
    
    <item>
      <title>Declaração de troca</title>
      <link>https://www.wikiod.com/pt/powershell/declaracao-de-troca/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/declaracao-de-troca/</guid>
      <description>Uma instrução switch permite que uma variável seja testada quanto à igualdade em relação a uma lista de valores. Cada valor é chamado de case, e a variável que está sendo ativada é verificada para cada switch case. Ele permite que você escreva um script que pode escolher entre uma série de opções, mas sem exigir que você escreva uma longa série de instruções if.
Este tópico está documentando a instrução switch usada para ramificar o fluxo do script.</description>
    </item>
    
    <item>
      <title>CodificaçãoDecodificação de URL</title>
      <link>https://www.wikiod.com/pt/powershell/codificacaodecodificacao-de-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/codificacaodecodificacao-de-url/</guid>
      <description>A expressão regular usada nos exemplos de Decode URL foi extraída de RFC 2396, Apêndice B: Analisando uma referência de URI com uma expressão regular; para a posteridade, aqui está uma citação:
A linha a seguir é a expressão regular para quebrar um URI referência em seus componentes.
^(([^:/?#]+):)?(//([^/?#]))?([^?#])(?([^#]))? (#(.))? 12 3 4 5 6 7 8 9
Os números na segunda linha acima são apenas para facilitar a leitura; eles indicam os pontos de referência para cada subexpressão (ou seja, cada parênteses emparelhados).</description>
    </item>
    
    <item>
      <title>rotações</title>
      <link>https://www.wikiod.com/pt/powershell/rotacoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/rotacoes/</guid>
      <description>Um loop é uma sequência de instruções que é repetida continuamente até que uma determinada condição seja alcançada. Ser capaz de fazer seu programa executar repetidamente um bloco de código é uma das tarefas mais básicas, porém úteis, na programação. Um loop permite que você escreva uma instrução muito simples para produzir um resultado significativamente maior simplesmente por repetição. Se a condição foi alcançada, a próxima instrução &amp;ldquo;cai&amp;rdquo; para a próxima instrução sequencial ou desvia para fora do loop.</description>
    </item>
    
    <item>
      <title>Trabalhando com arquivos XML</title>
      <link>https://www.wikiod.com/pt/powershell/trabalhando-com-arquivos-xml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/trabalhando-com-arquivos-xml/</guid>
      <description>Acessando um arquivo XML # &amp;lt;!-- file.xml --&amp;gt; &amp;lt;people&amp;gt; &amp;lt;person id=&amp;quot;101&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Jon Lajoie&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;22&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;person id=&amp;quot;102&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Lord Gaben&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;65&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;person id=&amp;quot;103&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Gordon Freeman&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;29&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;/people&amp;gt; Carregando um arquivo XML
Para carregar um arquivo XML, você pode usar qualquer um destes:
# First Method $xdoc = New-Object System.Xml.XmlDocument $file = Resolve-Path(&amp;quot;.\file.xml&amp;quot;) $xdoc.load($file) # Second Method [xml] $xdoc = Get-Content &amp;quot;.\file.xml&amp;quot; # Third Method $xdoc = [xml] (Get-Content &amp;quot;.\file.xml&amp;quot;) Acessando XML como Objetos</description>
    </item>
    
    <item>
      <title>Usando ShouldProcess</title>
      <link>https://www.wikiod.com/pt/powershell/usando-shouldprocess/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/usando-shouldprocess/</guid>
      <description>Sintaxe # $PSCmdlet.ShouldProcess(&amp;ldquo;Target&amp;rdquo;) $PSCmdlet.ShouldProcess(&amp;ldquo;Destino&amp;rdquo;, &amp;ldquo;Ação&amp;rdquo;) Parâmetros # Parâmetro Detalhes Alvo O recurso que está sendo alterado. Ação A operação que está sendo realizada. O padrão é o nome do cmdlet. $PSCmdlet.ShouldProcess() também escreverá automaticamente uma mensagem na saída detalhada.
PS&amp;gt; Invoke-MyCmdlet -Verbose VERBOSE: Performing the operation &amp;quot;Invoke-MyCmdlet&amp;quot; on target &amp;quot;Target of action&amp;quot; Exemplo de uso completo # Outros exemplos não poderiam me explicar claramente como acionar a lógica condicional.
Este exemplo também mostra que os comandos subjacentes também escutarão o sinalizador -Confirmar!</description>
    </item>
    
    <item>
      <title>Funções do PowerShell</title>
      <link>https://www.wikiod.com/pt/powershell/funcoes-do-powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/funcoes-do-powershell/</guid>
      <description>Uma função é basicamente um bloco de código nomeado. Quando você chama o nome da função, o bloco de script dentro dessa função é executado. É uma lista de instruções do PowerShell que tem um nome que você atribui. Ao executar uma função, você digita o nome da função. É um método para economizar tempo ao lidar com tarefas repetitivas. O PowerShell formata em três partes: a palavra-chave &amp;lsquo;Function&amp;rsquo;, seguida por um Name, finalmente, a carga que contém o bloco de script, que é delimitado por colchetes de estilo curly/parênteses.</description>
    </item>
    
    <item>
      <title>Comunicação TCP com PowerShell</title>
      <link>https://www.wikiod.com/pt/powershell/comunicacao-tcp-com-powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/comunicacao-tcp-com-powershell/</guid>
      <description>Ouvinte TCP # Function Receive-TCPMessage { Param ( [Parameter(Mandatory=$true, Position=0)] [ValidateNotNullOrEmpty()] [int] $Port ) Process { Try { # Set up endpoint and start listening $endpoint = new-object System.Net.IPEndPoint([ipaddress]::any,$port) $listener = new-object System.Net.Sockets.TcpListener $EndPoint $listener.start() # Wait for an incoming connection $data = $listener.AcceptTcpClient() # Stream setup $stream = $data.GetStream() $bytes = New-Object System.Byte[] 1024 # Read data from stream and write it to host while (($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){ $EncodedText = New-Object System.</description>
    </item>
    
    <item>
      <title>Manipulação de segredos e credenciais</title>
      <link>https://www.wikiod.com/pt/powershell/manipulacao-de-segredos-e-credenciais/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/manipulacao-de-segredos-e-credenciais/</guid>
      <description>No Powershell, para evitar armazenar a senha em texto claro, usamos diferentes métodos de criptografia e a armazenamos como string segura. Quando você não estiver especificando uma chave ou chave de segurança, isso funcionará apenas para o mesmo usuário no mesmo computador que poderá descriptografar a string criptografada se você não estiver usando Chaves/SecureKeys. Qualquer processo executado na mesma conta de usuário poderá descriptografar essa string criptografada na mesma máquina.</description>
    </item>
    
    <item>
      <title>Linha de comando do PowerShell.exe</title>
      <link>https://www.wikiod.com/pt/powershell/linha-de-comando-do-powershellexe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/powershell/linha-de-comando-do-powershellexe/</guid>
      <description>Parâmetros # Parâmetro Descrição -Ajuda | -? | /? Mostra a ajuda -Arquivo &amp;lt;FilePath&amp;gt; [&amp;lt;Args&amp;gt;] Caminho para o arquivo de script que deve ser executado e argumentos (opcional) -Comando { - | &amp;lt;script-block&amp;gt; [-args &amp;lt;arg-array&amp;gt;] | &amp;lt;string&amp;gt; [&amp;lt;CommandParameters&amp;gt;] } Comandos a serem executados seguidos de argumentos -EncodedCommand &amp;lt;Base64EncodedCommand&amp;gt; Comandos codificados em Base64 -ExecutionPolicy &amp;lt;ExecutionPolicy&amp;gt; Define a política de execução apenas para este processo -InputFormat { Texto | XML} Define o formato de entrada para os dados enviados ao processo.</description>
    </item>
    
  </channel>
</rss>
