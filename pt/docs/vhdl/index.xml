<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial vhdl on </title>
    <link>https://www.wikiod.com/pt/docs/vhdl/</link>
    <description>Recent content in Tutorial vhdl on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/vhdl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao vhdl</title>
      <link>https://www.wikiod.com/pt/vhdl/introducao-ao-vhdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/introducao-ao-vhdl/</guid>
      <description>Sinais vs. variáveis, uma breve visão geral da semântica de simulação de VHDL # Este exemplo trata de um dos aspectos mais fundamentais da linguagem VHDL: a semântica da simulação. Destina-se a iniciantes em VHDL e apresenta uma visão simplificada onde muitos detalhes foram omitidos (processos adiados, Interface Procedimental VHDL, variáveis ​​compartilhadas&amp;hellip;) Os leitores interessados ​​na verdadeira semântica completa devem consultar o Manual de Referência da Linguagem (LRM).
Sinais e variáveis # A maioria das linguagens de programação imperativas clássicas usa variáveis.</description>
    </item>
    
    <item>
      <title>Design de hardware digital usando VHDL em poucas palavras</title>
      <link>https://www.wikiod.com/pt/vhdl/design-de-hardware-digital-usando-vhdl-em-poucas-palavras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/design-de-hardware-digital-usando-vhdl-em-poucas-palavras/</guid>
      <description>Neste tópico propomos um método simples para projetar corretamente circuitos digitais simples com VHDL. O método é baseado em diagramas de blocos gráficos e um princípio fácil de lembrar:
Pense em hardware primeiro, codifique VHDL em seguida
Destina-se a iniciantes em design de hardware digital usando VHDL, com uma compreensão limitada da semântica de síntese da linguagem.
O design de hardware digital usando VHDL é simples, mesmo para iniciantes, mas há algumas coisas importantes a serem conhecidas e um pequeno conjunto de regras a serem obedecidas.</description>
    </item>
    
    <item>
      <title>Tipos protegidos</title>
      <link>https://www.wikiod.com/pt/vhdl/tipos-protegidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/tipos-protegidos/</guid>
      <description>Antes do VHDL 1993, dois processos simultâneos podiam se comunicar apenas com sinais. Graças à semântica de simulação da linguagem que atualiza os sinais apenas entre as etapas da simulação, o resultado de uma simulação era determinístico: não dependia da ordem escolhida pelo escalonador de simulação para executar os processos.
[Na verdade, isso não é 100% verdade. Os processos também podem se comunicar usando entrada/saída de arquivo. Mas se um designer estava comprometendo o determinismo usando arquivos, não poderia ser realmente um erro.</description>
    </item>
    
    <item>
      <title>Espere</title>
      <link>https://www.wikiod.com/pt/vhdl/espere/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/espere/</guid>
      <description>Sintaxe # aguarde [no SIGNAL1[, SIGNAL2[&amp;hellip;]]] [até CONDITION] [por TIMEOUT]; esperar; &amp;ndash; Eterna espera espera em s1, s2; &amp;ndash; Espera até que os sinais s1 ou s2 (ou ambos) mudem espere até s1 = 15; &amp;ndash; Espera até que o sinal s1 mude e seu novo valor seja 15 espere até s1 = 15 por 10 ns; &amp;ndash; Espera até que o sinal s1 mude e seu novo valor seja 15 por no máximo 10 ns Aguarde até a condição # É possível omitir as cláusulas on &amp;lt;sensitivity_list&amp;gt; e for &amp;lt;timeout&amp;gt;, como em:</description>
    </item>
    
    <item>
      <title>Funções de resolução, tipos não resolvidos e resolvidos</title>
      <link>https://www.wikiod.com/pt/vhdl/funcoes-de-resolucao-tipos-nao-resolvidos-e-resolvidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/funcoes-de-resolucao-tipos-nao-resolvidos-e-resolvidos/</guid>
      <description>Os tipos de VHDL podem ser não resolvidos ou resolvidos. O tipo bit declarado pelo pacote std.standard, por exemplo, não é resolvido enquanto o tipo std_logic declarado pelo pacote ieee.std_logic_1164 é resolvido.
Um sinal de tipo não resolvido não pode ser acionado (atribuído) por mais de um processo VHDL, enquanto um sinal de tipo resolvido pode.
O uso de tipos resolvidos deve ser reservado para situações onde a intenção é realmente modelar um fio de hardware (ou conjunto de fios) acionado por mais de um circuito de hardware.</description>
    </item>
    
    <item>
      <title>D-Flip-Flops (DFF) e travas</title>
      <link>https://www.wikiod.com/pt/vhdl/d-flip-flops-dff-e-travas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/d-flip-flops-dff-e-travas/</guid>
      <description>D-Flip-Flops (DFF) e travas são elementos de memória. Um DFF amostra sua entrada em uma ou outra borda de seu clock (não em ambas) enquanto uma trava é transparente em um nível de sua habilitação e memorizada no outro. A figura a seguir ilustra a diferença:
A modelagem de DFFs ou travas em VHDL é fácil, mas existem alguns aspectos importantes que devem ser levados em consideração:
As diferenças entre os modelos VHDL de DFFs e travas.</description>
    </item>
    
    <item>
      <title>Análise de tempo estático - o que significa quando um projeto falha no tempo?</title>
      <link>https://www.wikiod.com/pt/vhdl/analise-de-tempo-estatico---o-que-significa-quando-um-projeto-falha-no-tempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/analise-de-tempo-estatico---o-que-significa-quando-um-projeto-falha-no-tempo/</guid>
      <description>O que é tempo? # O conceito de temporização está mais relacionado à física dos flip-flops do que ao VHDL, mas é um conceito importante que qualquer designer que use VHDL para criar hardware deve conhecer.
Ao projetar um hardware digital, normalmente criamos uma lógica síncrona. Isso significa que nossos dados viajam de flip-flop para flip-flop, possivelmente com alguma lógica combinatória entre eles. O diagrama mais básico de lógica síncrona que incorpora uma função combinatória é mostrado abaixo:</description>
    </item>
    
    <item>
      <title>Comentários</title>
      <link>https://www.wikiod.com/pt/vhdl/comentarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/comentarios/</guid>
      <description>Qualquer linguagem de programação decente suporta comentários. Em VHDL, eles são especialmente importantes porque entender um código VHDL, mesmo moderadamente sofisticado, é frequentemente desafiador.
Comentários de linha única # Um comentário de linha única começa com dois hífens (--) e se estende até o final da linha. Exemplo :
-- This process models the state register process(clock, aresetn) begin if aresetn = &#39;0&#39; then -- Active low, asynchronous reset state &amp;lt;= IDLE; elsif rising_edge(clock) then -- Synchronized on the rising edge of the clock state &amp;lt;= next_state; end if; end process; Comentários delimitados # A partir do VHDL 2008, um comentário também pode se estender por várias linhas.</description>
    </item>
    
    <item>
      <title>Recordações</title>
      <link>https://www.wikiod.com/pt/vhdl/recordacoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/recordacoes/</guid>
      <description>Isso abrange memórias de porta única e de porta dupla.
Sintaxe # Tipo de memória para largura e profundidade constantes.
type MEMORY_TYPE is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0); Tipo de memória para profundidade variável e largura constante.
type MEMORY_TYPE is array (natural range &amp;lt;&amp;gt;) of std_logic_vector(WIDTH-1 downto 0); Registro de deslocamento # Um registrador de deslocamento de comprimento genérico. Com entrada serial e saída serial.
library ieee; use ieee.</description>
    </item>
    
    <item>
      <title>Literais</title>
      <link>https://www.wikiod.com/pt/vhdl/literais/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/vhdl/literais/</guid>
      <description>Isso tem como especificar constantes, chamadas literais em VHDL
Literais numéricos # 16#A8# -- hex 2#100# -- binary 2#1000_1001_1111_0000 -- long number, adding (optional) _ (one or more) for readability 1234 -- decimal Literal enumerado # type state_t is (START, READING, WRITING); -- user-defined enumerated type </description>
    </item>
    
  </channel>
</rss>
