<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial cobol on </title>
    <link>https://www.wikiod.com/pt/docs/cobol/</link>
    <description>Recent content in tutorial cobol on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/cobol/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao cobol</title>
      <link>https://www.wikiod.com/pt/cobol/introducao-ao-cobol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/introducao-ao-cobol/</guid>
      <description>Olá Mundo # HELLO * HISTORIC EXAMPLE OF HELLO WORLD IN COBOL IDENTIFICATION DIVISION. PROGRAM-ID. HELLO. PROCEDURE DIVISION. DISPLAY &amp;quot;HELLO, WORLD&amp;quot;. STOP RUN. Os dias de layout de cartão perfurado e entradas apenas em maiúsculas estão muito atrás. No entanto, a maioria das implementações COBOL ainda lida com o mesmo layout de código. Mesmo as implementações atuais seguem o mesmo (muitas vezes até em maiúsculas) compiladas e em produção.
Uma implementação moderna bem formatada pode se parecer com:</description>
    </item>
    
    <item>
      <title>Declaração de CHAMADA</title>
      <link>https://www.wikiod.com/pt/cobol/declaracao-de-chamada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/declaracao-de-chamada/</guid>
      <description>A instrução COBOL CALL fornece acesso a rotinas de biblioteca compiladas.
Instrução CALL # O COBOL pode usar a ligação estática para a instrução a seguir. O GnuCOBOL usa ligação dinâmica por padrão para todos os símbolos externos conhecidos em tempo de compilação, mesmo quando o símbolo é literal:
CALL &amp;quot;subprogram&amp;quot; USING a b c *&amp;gt; run a (possibly static linked) sub program *&amp;gt; passing three fields CALL some-prog USING a b c *&amp;gt; some-prog is a PIC X item and can be changed *&amp;gt; at run-time to do a dynamic lookup Essa instrução força a resolução de edição do link em tempo de compilação.</description>
    </item>
    
    <item>
      <title>Instalação do GnuCOBOL com GNULinux</title>
      <link>https://www.wikiod.com/pt/cobol/instalacao-do-gnucobol-com-gnulinux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/instalacao-do-gnucobol-com-gnulinux/</guid>
      <description>Instalação GNU/Linux # Para a maioria das distribuições GNU/Linux, uma versão do GnuCOBOL está disponível nos repositórios. GnuCOBOL era originalmente OpenCOBOL, renomeado quando o projeto se tornou um projeto GNU oficial. Muitos repositórios ainda estão usando open-cobol como o nome do pacote (desde agosto de 2016).
Para Fedora e outros gerenciadores de pacotes baseados em RPM
sudo yum install open-cobol Para pacotes baseados em Debian, Ubuntu e APT
sudo apt install open-cobol Esta é geralmente a versão 1.</description>
    </item>
    
    <item>
      <title>instrução ALTER</title>
      <link>https://www.wikiod.com/pt/cobol/instrucao-alter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/instrucao-alter/</guid>
      <description>A muito amada declaração ALTER. Altera o destino de um parágrafo GO TO.
Não faz mais parte do padrão COBOL, ainda suportado por muitos compiladores por motivos de compatibilidade com versões anteriores. (O diagrama de sintaxe está esmaecido para mostrar que não é mais COBOL padrão).
Um exemplo artificial usando ALTER # identification division. program-id. altering. date-written. 2015-10-28/06:36-0400. remarks. Demonstrate ALTER. procedure division. main section. *&amp;gt; And now for some altering.</description>
    </item>
    
    <item>
      <title>ACEITAR declaração</title>
      <link>https://www.wikiod.com/pt/cobol/aceitar-declaracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/aceitar-declaracao/</guid>
      <description>A instrução COBOL ACCEPT é usada para recuperar dados do sistema.
ACEITAR declaração # ACCEPT variable. ACCEPT variable FROM CONSOLE. ACCEPT variable FROM ENVIRONMENT &amp;quot;path&amp;quot;. ACCEPT variable FROM COMMAND-LINE. ACCEPT variable FROM ARGUMENT-NUMBER ACCEPT variable FROM ARGUMENT-VALUE ACCEPT variable AT 0101. ACCEPT screen-variable. ACCEPT today FROM DATE. ACCEPT today FROM DATE YYYYMMDD. ACCEPT thetime FROM TIME. ACCEPT theday FROM DAY. ACCEPT theday FROM DAY YYYYDDD. ACCEPT weekday FROM DAY-OF-WEEK. ACCEPT thekey FROM ESCAPE KEY.</description>
    </item>
    
    <item>
      <title>Declaração de SAÍDA</title>
      <link>https://www.wikiod.com/pt/cobol/declaracao-de-saida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/declaracao-de-saida/</guid>
      <description>A instrução COBOL EXIT é um verbo de controle de fluxo de terminação.
EXIT vem com alguns sabores:
&amp;ldquo;EXIT&amp;rdquo; simples é um ponto final comum para uma série de procedimentos. EXIT PARAGRAPH, EXIT SECTION fornece um meio de sair de um procedimento estruturado sem executar nenhuma das instruções subsequentes. EXIT FUNCTION, EXIT METHOD, EXIT PROGRAM marca o fim lógico de um módulo de código. EXIT PERFORM sai de um loop de execução inline.</description>
    </item>
    
    <item>
      <title>INICIAR declaração</title>
      <link>https://www.wikiod.com/pt/cobol/iniciar-declaracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/iniciar-declaracao/</guid>
      <description>A instrução START fornece uma maneira de posicionar uma leitura em um arquivo para recuperação sequencial subsequente (por chave).
A chave relacional pode incluir (mas não se limita a):
A CHAVE É MAIOR QUE
A CHAVE É &amp;gt;
A CHAVE É MENOR QUE
A CHAVE É &amp;lt;
CHAVE É IGUAL A
CHAVE É =
CHAVE NÃO É MAIOR QUE
A CHAVE NÃO É &amp;gt;
CHAVE NÃO É MENOR QUE
A CHAVE NÃO É &amp;lt;</description>
    </item>
    
    <item>
      <title>ESCREVER declaração</title>
      <link>https://www.wikiod.com/pt/cobol/escrever-declaracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/escrever-declaracao/</guid>
      <description>A instrução WRITE libera registros lógicos para um recurso de armazenamento output ou input-output e para o posicionamento lógico de linhas dentro de uma página lógica.
ESCREVA sequencial
ESCREVA aleatoriamente
ESCREVA exemplos # WRITE record-buff WRITE indexed-record WITH LOCK ON INVALID KEY DISPLAY &amp;quot;Key exists, REWRITING...&amp;quot; END-DISPLAY PERFORM rewrite-key END-WRITE IF indexed-file-status NOT EQUAL ZERO THEN DISPLAY &amp;quot;Write problem: &amp;quot; indexed-file-status UPON SYSERR END-DISPLAY PERFORM evasive-manoeuvres END-IF WRITE record-name-1 AFTER ADVANCING PAGE WRITE record-name-1 FROM header-record-1 AFTER ADVANCING 2 LINES AT END-OF-PAGE PERFORM write-page-header PERFORM write-last-detail-reminder END-WRITE </description>
    </item>
    
    <item>
      <title>CONTINUAR declaração</title>
      <link>https://www.wikiod.com/pt/cobol/continuar-declaracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/continuar-declaracao/</guid>
      <description>A instrução CONTINUE faz com que o fluxo de controle continue na próxima instrução. Não é bem um não operacional, pois pode influenciar o fluxo de controle quando estiver dentro de sequências de instruções compostas, em particular IF/THEN/ELSE.
Um prático? exemplo é durante o desenvolvimento inicial e construção com e sem ajudas de depuração.
CALL &amp;quot;CBL_OC_DUMP&amp;quot; USING structure ON EXCEPTION CONTINUE END-CALL Esse código, embora caro, permitirá despejos de memória formatados quando o módulo CBL_OC_DUMP estiver vinculado ao executável, mas falhará inofensivamente quando não estiver.</description>
    </item>
    
    <item>
      <title>Funções intrínsecas</title>
      <link>https://www.wikiod.com/pt/cobol/funcoes-intrinsecas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/cobol/funcoes-intrinsecas/</guid>
      <description>As funções intrínsecas são incluídas no padrão COBOL como um conjunto de funções que retornam valores de um algoritmo específico, com zero ou mais argumentos. Essas funções intrínsecas são fornecidas como um recurso do compilador e do sistema de tempo de execução. Os itens de retorno são campos COBOL temporários e podem ser dados de caracteres, campos de bits ou valores numéricos.
Os exemplos incluem funções trigonométricas, rotinas de data e hora, conversões de tipo de dados, desvio padrão e outros algoritmos de suporte.</description>
    </item>
    
  </channel>
</rss>
