<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Julia Tutorial de Idiomas on </title>
    <link>https://www.wikiod.com/pt/docs/julia-lang/</link>
    <description>Recent content in Julia Tutorial de Idiomas on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/julia-lang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Julia Language</title>
      <link>https://www.wikiod.com/pt/julia-lang/introducao-ao-julia-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/introducao-ao-julia-language/</guid>
      <description>Olá Mundo! # println(&amp;quot;Hello, World!&amp;quot;) Para executar o Julia, primeiro obtenha o intérprete na [página de download] do site (http://julialang.org/downloads/). A versão estável atual é v0.5.0, e esta versão é recomendada para a maioria dos usuários. Certos desenvolvedores de pacotes ou usuários avançados podem optar por usar a compilação noturna, que é muito menos estável.
Quando você tiver o interpretador, escreva seu programa em um arquivo chamado hello.jl. Ele pode então ser executado a partir de um terminal do sistema como:</description>
    </item>
    
    <item>
      <title>para loops</title>
      <link>https://www.wikiod.com/pt/julia-lang/para-loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/para-loops/</guid>
      <description>Sintaxe # para i em iter; &amp;hellip;; fim enquanto cond; &amp;hellip;; fim parar Prosseguir @parallel (op) para i em iter; &amp;hellip;; fim @parallel para i em iter; &amp;hellip;; fim rótulo @goto rótulo @label Sempre que tornar o código mais curto e fácil de ler, considere usar funções de ordem superior, como map ou filter, em vez de loops.
Encontre o menor fator primo # Em algumas situações, pode-se querer retornar de uma função antes de terminar um loop inteiro.</description>
    </item>
    
    <item>
      <title>Fechamentos</title>
      <link>https://www.wikiod.com/pt/julia-lang/fechamentos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/fechamentos/</guid>
      <description>Sintaxe # x -&amp;gt; [corpo] (x, y) -&amp;gt; [corpo] (xs&amp;hellip;) -&amp;gt; [corpo] Em versões mais antigas do Julia, encerramentos e funções anônimas tinham uma penalidade de desempenho de tempo de execução. Esta penalidade foi eliminada em 0,5.
Introdução aos Fechamentos # Funções são uma parte importante da programação de Julia. Eles podem ser definidos diretamente dentro dos módulos, caso em que as funções são chamadas de top-level. Mas as funções também podem ser definidas dentro de outras funções.</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/pt/julia-lang/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/json/</guid>
      <description>Sintaxe # usando JSON JSON.parse(str) JSON.json(obj) JSON.print(io, obj, recuo) Como nem os objetos Julia Dict nem JSON são inerentemente ordenados, é melhor não confiar na ordem dos pares de valores-chave em um objeto JSON.
Instalando JSON.jl # JSON é um formato popular de intercâmbio de dados. A biblioteca JSON mais popular para Julia é JSON.jl. Para instalar este pacote, use o gerenciador de pacotes:
julia&amp;gt; Pkg.add(&amp;quot;JSON&amp;quot;) O próximo passo é testar se o pacote está funcionando em sua máquina:</description>
    </item>
    
    <item>
      <title>Entrada</title>
      <link>https://www.wikiod.com/pt/julia-lang/entrada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/entrada/</guid>
      <description>Sintaxe # Leia a linha() linha de leitura() readstring(STDIN) chomp(str) open(f, arquivo) delineado (io) readstring(arquivo) leia (arquivo) readcsv(arquivo) readdlm(arquivo) Parâmetros # Parâmetro Detalhes chomp(str) Remova até uma nova linha à direita de uma string. str A string da qual remover uma nova linha à direita. Observe que strings são imutáveis ​​por convenção. Esta função retorna uma nova string. open(f, arquivo) Abra um arquivo, chame a função e feche o arquivo depois.</description>
    </item>
    
    <item>
      <title>Condicionais</title>
      <link>https://www.wikiod.com/pt/julia-lang/condicionais/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/condicionais/</guid>
      <description>Sintaxe # se cond; corpo; fim se cond; corpo; senão; corpo; fim se cond; corpo; outra condição; corpo; senão; fim se cond; corpo; outra condição; corpo; fim -cond? iftrue : iffalse cond &amp;amp;&amp;amp; se verdadeiro condição || se for falso ifelse(cond, iftrue, iffalse) Todos os operadores e funções condicionais envolvem o uso de condições booleanas (true ou false). Em Julia, o tipo de booleanos é Bool. Ao contrário de algumas outras linguagens, outros tipos de números (como 1 ou 0), strings, arrays e assim por diante _não podem ser usados ​​diretamente em condicionais.</description>
    </item>
    
    <item>
      <title>Metaprogramação</title>
      <link>https://www.wikiod.com/pt/julia-lang/metaprogramacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/metaprogramacao/</guid>
      <description>Sintaxe # nome da macro(ex) &amp;hellip; fim citação&amp;hellip; fim :(&amp;hellip;) $ x Meta.quot(x) QuoteNode(x) esc(x) Os recursos de metaprogramação de Julia são fortemente inspirados por linguagens semelhantes a Lisp e parecerão familiares para aqueles com algum conhecimento de Lisp. A metaprogramação é muito poderosa. Quando usado corretamente, pode levar a um código mais conciso e legível.
O quote ... end é uma sintaxe de quase aspas. Em vez de as expressões serem avaliadas, elas são simplesmente analisadas.</description>
    </item>
    
    <item>
      <title>Processamento paralelo</title>
      <link>https://www.wikiod.com/pt/julia-lang/processamento-paralelo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/processamento-paralelo/</guid>
      <description>@async e @sync # De acordo com a documentação em ?@async, &amp;ldquo;@async envolve uma expressão em uma tarefa.&amp;rdquo; O que isso significa é que, para o que estiver dentro de seu escopo, Julia iniciará essa tarefa em execução, mas prosseguirá para o que vier a seguir no script sem esperar que a tarefa seja concluída. Assim, por exemplo, sem a macro, você obterá:
julia&amp;gt; @time sleep(2) 2.005766 seconds (13 allocations: 624 bytes) Mas com a macro, você obtém:</description>
    </item>
    
    <item>
      <title>Tuplas</title>
      <link>https://www.wikiod.com/pt/julia-lang/tuplas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/tuplas/</guid>
      <description>Sintaxe # uma, a, b a, b = x () (uma,) (a, b) (a, b&amp;hellip;) Tupla {T, U, V} NTuplo{N, T} Tupla{T, U, Vararg{V}} As tuplas têm um desempenho de tempo de execução muito melhor do que arrays por dois motivos: seus tipos são mais precisos e sua imutabilidade permite que sejam alocados na pilha em vez do heap. No entanto, essa tipagem mais precisa vem com mais sobrecarga de tempo de compilação e mais dificuldade em alcançar [estabilidade de tipo] 2.</description>
    </item>
    
    <item>
      <title>Teste de unidade</title>
      <link>https://www.wikiod.com/pt/julia-lang/teste-de-unidade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/julia-lang/teste-de-unidade/</guid>
      <description>Sintaxe # @test [expr] @test_throws [Exceção] [expr] @testset &amp;ldquo;[nome]&amp;rdquo; começar; [testes]; fim Pkg.test([pacote]) A documentação da biblioteca padrão para Base.Test cobre material adicional além do mostrado nestes exemplos.
Testando um pacote # Para executar os testes de unidade de um pacote, use a função Pkg.test. Para um pacote chamado MyPackage, o comando seria
julia&amp;gt; Pkg.test(&amp;quot;MyPackage&amp;quot;) Uma saída esperada seria semelhante a
INFO: Computing test dependencies for MyPackage... INFO: Installing BaseTestNext v0.</description>
    </item>
    
  </channel>
</rss>
