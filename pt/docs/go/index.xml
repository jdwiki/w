<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ir tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/go/</link>
    <description>Recent content in Ir tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Go</title>
      <link>https://www.wikiod.com/pt/go/introducao-ao-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/introducao-ao-go/</guid>
      <description>Olá Mundo! # Coloque o seguinte código em um nome de arquivo hello.go:
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello, 世界&amp;quot;) } Playground
Quando Go é instalado corretamente este programa pode ser compilado e executado assim:
go run hello.go Resultado: # Hello, 世界 Quando estiver satisfeito com o código, ele pode ser compilado em um executável executando:
go build hello.go Isso criará um arquivo executável apropriado para seu sistema operacional no diretório atual, que você poderá executar com o seguinte comando:</description>
    </item>
    
    <item>
      <title>Compilação cruzada</title>
      <link>https://www.wikiod.com/pt/go/compilacao-cruzada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/compilacao-cruzada/</guid>
      <description>O compilador Go pode produzir binários para muitas plataformas, ou seja, processadores e sistemas. Ao contrário da maioria dos outros compiladores, não há requisitos específicos para compilação cruzada, é tão fácil de usar quanto a compilação regular.
Sintaxe # GOOS=linux GOARCH=amd64 go build Combinações de destino de arquitetura e sistema operacional compatíveis (source)
$GOOS $GOARCH andróide braço darwin 386 darwin amd64 darwin braço darwin arm64 libélula amd64 freebsd 386 freebsd amd64 freebsd braço linux 386 linux amd64 linux braço linux arm64 linux ppc64 linux ppc64le linux mips64 linux mips64le netbsd 386 netbsd amd64 netbsd braço openbsd 386 openbsd amd64 openbsd braço plano9 386 plano9 amd64 solaris amd64 janelas 386 janelas amd64 Compilação cruzada simples com go build # No diretório do seu projeto, execute o comando go build e especifique o sistema operacional e a arquitetura alvo com as variáveis ​​de ambiente GOOS e GOARCH:</description>
    </item>
    
    <item>
      <title>Mapas</title>
      <link>https://www.wikiod.com/pt/go/mapas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/mapas/</guid>
      <description>Os mapas são tipos de dados usados ​​para armazenar pares de valores-chave não ordenados, de modo que pesquisar o valor associado a uma determinada chave é muito eficiente. As chaves são únicas. A estrutura de dados subjacente cresce conforme necessário para acomodar novos elementos, de modo que o programador não precisa se preocupar com o gerenciamento de memória. Eles são semelhantes ao que outras linguagens chamam de tabelas de hash, dicionários ou matrizes associativas.</description>
    </item>
    
    <item>
      <title>Cliente HTTP</title>
      <link>https://www.wikiod.com/pt/go/cliente-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/cliente-http/</guid>
      <description>Sintaxe # resp, err := http.Get(url) // Faz uma solicitação HTTP GET com o cliente HTTP padrão. Um erro não nulo é retornado se a solicitação falhar. resp, err := http.Post(url, bodyType, body) // Faz uma solicitação HTTP POST com o cliente HTTP padrão. Um erro não nulo é retornado se a solicitação falhar. resp, err := http.PostForm(url, values) // Faz uma solicitação POST de formulário HTTP com o cliente HTTP padrão.</description>
    </item>
    
    <item>
      <title>Simultaneidade</title>
      <link>https://www.wikiod.com/pt/go/simultaneidade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/simultaneidade/</guid>
      <description>Em Go, a simultaneidade é alcançada através do uso de goroutines, e a comunicação entre goroutines geralmente é feita com canais. No entanto, outros meios de sincronização, como mutexes e grupos de espera, estão disponíveis e devem ser usados ​​sempre que forem mais convenientes que os canais.
Sintaxe # go doWork() // executa a função doWork como uma goroutine ch := make(chan int) // declara um novo canal do tipo int ch &amp;lt;- 1 // enviando em um canal value = &amp;lt;-ch // recebendo de um canal Goroutines em Go são semelhantes a threads em outros idiomas em termos de uso.</description>
    </item>
    
    <item>
      <title>Servidor HTTP</title>
      <link>https://www.wikiod.com/pt/go/servidor-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/servidor-http/</guid>
      <description>http.ServeMux fornece um multiplexador que chama manipuladores para solicitações HTTP.
As alternativas ao multiplexador de biblioteca padrão incluem:
Gorilla Mux
Olá Mundo # A maneira típica de começar a escrever servidores web em golang é usar o módulo net/http da biblioteca padrão.
Há também um tutorial para isso aqui.
O código a seguir também o usa. Aqui está a implementação de servidor HTTP mais simples possível. Ele responde &amp;quot;Hello World&amp;quot; a qualquer solicitação HTTP.</description>
    </item>
    
    <item>
      <title>Estruturas</title>
      <link>https://www.wikiod.com/pt/go/estruturas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/estruturas/</guid>
      <description>Estruturas são conjuntos de várias variáveis ​​empacotadas juntas. O próprio struct é apenas um package contendo variáveis ​​e tornando-as facilmente acessíveis.
Ao contrário de C, as estruturas de Go podem ter métodos anexados a elas. Também lhes permite implementar interfaces. Isso torna as estruturas de Go semelhantes a objetos, mas elas estão (provavelmente intencionalmente) perdendo alguns recursos importantes conhecidos em linguagens orientadas a objetos, como herança.
Métodos # Os métodos struct são muito semelhantes às funções:</description>
    </item>
    
    <item>
      <title>Iota</title>
      <link>https://www.wikiod.com/pt/go/iota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/iota/</guid>
      <description>Iota fornece uma maneira de declarar constantes numéricas a partir de um valor inicial que cresce monotonicamente. Iota pode ser usado para declarar bitmasks que são frequentemente usados ​​em programação de sistema e rede e outras listas de constantes com valores relacionados.
O identificador iota é usado para atribuir valores a listas de constantes. Quando iota é usado em uma lista, ele começa com um valor zero e é incrementado em um para cada valor na lista de constantes e é redefinido em cada palavra-chave const.</description>
    </item>
    
    <item>
      <title>Vendo</title>
      <link>https://www.wikiod.com/pt/go/vendo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/vendo/</guid>
      <description>A venda é um método de garantir que todos os pacotes de terceiros que você usa em seu projeto Go sejam consistentes para todos que desenvolvem para seu aplicativo.
Quando seu pacote Go importa outro pacote, o compilador normalmente verifica $GOPATH/src/ para o caminho do projeto importado. No entanto, se o seu pacote contiver uma pasta chamada vendor, o compilador verificará essa pasta primeiro. Isso significa que você pode importar pacotes de outras partes dentro de seu próprio repositório de código, sem precisar modificar o código deles.</description>
    </item>
    
    <item>
      <title>Manipulação de erros</title>
      <link>https://www.wikiod.com/pt/go/manipulacao-de-erros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/go/manipulacao-de-erros/</guid>
      <description>Em Go, situações inesperadas são tratadas usando erros, não exceções. Essa abordagem é mais semelhante à de C, usando errno, do que à de Java ou outras linguagens orientadas a objetos, com seus blocos try/catch. No entanto, um erro não é um número inteiro, mas uma interface.
Uma função que pode falhar normalmente retorna um erro como seu último valor de retorno. Se esse erro não for nil, algo deu errado, e o chamador da função deve agir de acordo.</description>
    </item>
    
  </channel>
</rss>
