<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Django on </title>
    <link>https://www.wikiod.com/pt/docs/django/</link>
    <description>Recent content in Tutorial de Django on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com o Django</title>
      <link>https://www.wikiod.com/pt/django/comecando-com-o-django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/comecando-com-o-django/</guid>
      <description>Iniciando um projeto # Django é um framework de desenvolvimento web baseado em Python. O Django 1.11 (a versão estável mais recente) requer a instalação do Python 2.7, 3.4, 3.5 ou 3.6. Supondo que o pip esteja disponível, a instalação é tão simples quanto executar o seguinte comando. Tenha em mente que omitir a versão mostrada abaixo instalará a versão mais recente do django:
$ pip install django Para instalar uma versão específica do django, vamos supor que a versão seja django 1.</description>
    </item>
    
    <item>
      <title>Comandos de gerenciamento</title>
      <link>https://www.wikiod.com/pt/django/comandos-de-gerenciamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/comandos-de-gerenciamento/</guid>
      <description>Comandos de gerenciamento são scripts poderosos e flexíveis que podem executar ações em seu projeto Django ou no banco de dados subjacente. Além de vários comandos padrão, é possível escrever o seu próprio!
Comparado aos scripts Python regulares, o uso da estrutura de comando de gerenciamento significa que algum trabalho de configuração tedioso é feito automaticamente para você nos bastidores.
Os comandos de gerenciamento podem ser chamados de:
django-admin &amp;lt;comando&amp;gt; [opções] python -m django &amp;lt;comando&amp;gt; [opções] python manage.</description>
    </item>
    
    <item>
      <title>Modelos</title>
      <link>https://www.wikiod.com/pt/django/modelos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/modelos/</guid>
      <description>No caso básico, um modelo é uma classe Python que mapeia para uma única tabela de banco de dados. Os atributos da classe mapeiam para colunas na tabela e uma instância da classe representa uma linha na tabela do banco de dados. Os modelos herdam de django.db.models.Model que fornece uma API rica para adicionar e filtrar resultados do banco de dados.
[Crie seu primeiro modelo](https://www.wikiod.com/pt/django/modelos#Criando seu primeiro modelo)
Adicionando uma representação de string de um modelo # Para criar uma apresentação legível por humanos de um objeto de modelo, você precisa implementar o método Model.</description>
    </item>
    
    <item>
      <title>Middleware</title>
      <link>https://www.wikiod.com/pt/django/middleware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/middleware/</guid>
      <description>Middleware no Django é um framework que permite que o código se conecte ao processamento de resposta/requisição e altere a entrada ou saída do Django.
O middleware precisa ser adicionado à sua lista settings.py MIDDLEWARE_CLASSES antes de ser incluído na execução. A lista padrão que o Django fornece ao criar um novo projeto é a seguinte:
MIDDLEWARE_CLASSES = [ &#39;django.middleware.security.SecurityMiddleware&#39;, &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;django.middleware.common.CommonMiddleware&#39;, &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, &#39;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#39;, &#39;django.contrib.messages.middleware.MessageMiddleware&#39;, &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;, ] Essas são todas as funções que serão executadas em ordem em cada solicitação (uma vez antes de atingir seu código de visualização em views.</description>
    </item>
    
    <item>
      <title>Definições</title>
      <link>https://www.wikiod.com/pt/django/definicoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/definicoes/</guid>
      <description>Escondendo dados secretos usando um arquivo JSON # Ao usar um VCS como Git ou SVN, existem alguns dados secretos que nunca devem ser versionados (seja o repositório público ou privado).
Entre esses dados, você encontra a configuração SECRET_KEY e a senha do banco de dados.
Uma prática comum para ocultar essas configurações do controle de versão é criar um arquivo secrets.json na raiz do seu projeto (obrigado &amp;ldquo;Two Scoops of Django&amp;rdquo; pela ideia):</description>
    </item>
    
    <item>
      <title>roteamento de URL</title>
      <link>https://www.wikiod.com/pt/django/roteamento-de-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/roteamento-de-url/</guid>
      <description>Defina o namespace de URL para um aplicativo reutilizável (Django 1.9+) # Configure o URLconf do seu aplicativo para usar automaticamente um namespace de URL definindo o atributo app_name:
# In &amp;lt;myapp&amp;gt;/urls.py from django.conf.urls import url from .views import overview app_name = &#39;myapp&#39; urlpatterns = [ url(r&#39;^$&#39;, overview, name=&#39;overview&#39;), ] Isto irá definir o application namespace para &#39;myapp&#39; quando estiver incluído no URLconf raiz &amp;gt;. O usuário do seu aplicativo reutilizável não precisa fazer nenhuma configuração além de incluir seus URLs:</description>
    </item>
    
    <item>
      <title>Back-ends de autenticação</title>
      <link>https://www.wikiod.com/pt/django/back-ends-de-autenticacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/back-ends-de-autenticacao/</guid>
      <description>Back-end de autenticação de e-mail # A autenticação padrão do Django funciona nos campos username e password. O back-end de autenticação de e-mail autenticará os usuários com base em email e senha.
from django.contrib.auth import get_user_model class EmailBackend(object): &amp;quot;&amp;quot;&amp;quot; Custom Email Backend to perform authentication via email &amp;quot;&amp;quot;&amp;quot; def authenticate(self, username=None, password=None): user_model = get_user_model() try: user = user_model.objects.get(email=username) if user.check_password(password): # check valid password return user # return user to be authenticated except user_model.</description>
    </item>
    
    <item>
      <title>ArrayField - um campo específico do PostgreSQL</title>
      <link>https://www.wikiod.com/pt/django/arrayfield---um-campo-especifico-do-postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/arrayfield---um-campo-especifico-do-postgresql/</guid>
      <description>Sintaxe # de django.contrib.postgres.fields import ArrayField class ArrayField(base_field, size=Nenhum, **opções) FooModel.objects.filter(array_field_name__contains=[objects, to, check]) FooModel.objects.filter(array_field_name__contained_by=[objects, to, check]) Note que embora o parâmetro size seja passado para o PostgreSQL, o PostgreSQL não irá aplicá-lo.
Ao usar ArrayFields deve-se ter em mente esta palavra de advertência da documentação de arrays Postgresql.
Dica: Arrays não são conjuntos; procurar por elementos de array específicos pode ser um sinal de design incorreto do banco de dados. Considere usar uma tabela separada com um linha para cada item que seria um elemento de array.</description>
    </item>
    
    <item>
      <title>Modelagem</title>
      <link>https://www.wikiod.com/pt/django/modelagem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/modelagem/</guid>
      <description>Impedir que métodos sensíveis sejam chamados em templates # Quando um objeto é exposto ao contexto do modelo, seus métodos sem argumentos estão disponíveis. Isso é útil quando essas funções são &amp;ldquo;getters&amp;rdquo;. Mas pode ser perigoso se esses métodos alterarem alguns dados ou tiverem alguns efeitos colaterais. Mesmo que você provavelmente confie no criador do modelo, ele pode não estar ciente dos efeitos colaterais de uma função ou pensar em chamar o atributo errado por engano.</description>
    </item>
    
    <item>
      <title>Conjuntos de consultas</title>
      <link>https://www.wikiod.com/pt/django/conjuntos-de-consultas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/django/conjuntos-de-consultas/</guid>
      <description>Um Queryset é fundamentalmente uma lista de objetos derivados de um Model, por uma compilação de consultas de banco de dados.
Reduzir o número de consultas no campo ForeignKey (problema n+1) # Problema # Os conjuntos de consultas do Django são avaliados de maneira preguiçosa. Por exemplo:
# models.py: class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): author = models.ForeignKey(Author, related_name=&#39;books&#39;) title = models.CharField(max_length=100) # views.py def myview(request): # Query the database books = Book.</description>
    </item>
    
  </channel>
</rss>
