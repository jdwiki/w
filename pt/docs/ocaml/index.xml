<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial OCaml on </title>
    <link>https://www.wikiod.com/pt/docs/ocaml/</link>
    <description>Recent content in Tutorial OCaml on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/ocaml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao OCaml</title>
      <link>https://www.wikiod.com/pt/ocaml/introducao-ao-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/introducao-ao-ocaml/</guid>
      <description>Instalação ou Configuração # Instalando o OPAM # OPAM é um gerenciador de pacotes para OCaml. Ele constrói e gerencia versões do compilador e bibliotecas OCaml para você facilmente.
A maneira mais fácil de instalar o OPAM em seu sistema operacional é usar um gerenciador de pacotes para seu sistema. por exemplo, apt-get, yum ou homebrew.
Instruções de instalação do Mac OSX # Atualize as fórmulas homebrew e instale o OPAM.</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/ocaml/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/correspondencia-de-padroes/</guid>
      <description>Função fatorial usando correspondência de padrões # let rec factorial n = match n with | 0 | 1 -&amp;gt; 1 | n -&amp;gt; n * (factorial (n - 1)) Essa função corresponde aos valores 0 e 1 e os mapeia para o caso base de nossa definição recursiva. Em seguida, todos os outros números são mapeados para a chamada recursiva dessa função.
Avaliação de expressões booleanas # Definimos o tipo de expressões booleanas cujos átomos são identificados por strings como</description>
    </item>
    
    <item>
      <title>Escreva seu primeiro script OCaml</title>
      <link>https://www.wikiod.com/pt/ocaml/escreva-seu-primeiro-script-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/escreva-seu-primeiro-script-ocaml/</guid>
      <description>Olá Mundo # Este exemplo pressupõe que você instalou o OCaml.
Compilando o código OCaml # Crie um novo arquivo chamado hello.ml, com o seguinte conteúdo:
print_string &amp;quot;Hello world!\n&amp;quot; ocamlc é o compilador OCaml. Para compilar e executar este script, execute
$ ocamlc -o hello hello.ml e, em seguida, execute o binário resultante
$ ./hello Hello world! Executando o código OCaml # Você também pode executar este script sem compilá-lo em um binário.</description>
    </item>
    
    <item>
      <title>Ocamlbuild</title>
      <link>https://www.wikiod.com/pt/ocaml/ocamlbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/ocamlbuild/</guid>
      <description>Exemplo básico sem dependência externa # Se seu projeto não tem dependência externa e tem foo.ml como seu ponto de entrada principal, você pode compilar uma versão de bytecode com
ocamlbuild foo.byte Para obter um executável nativo, execute
ocamlbuild foo.native Projeto dependendo de bibliotecas externas # Se o seu projeto depende das bibliotecas externas, você deve primeiro instalá-las com o opam. Assumindo que suas dependências são foo e bar e o ponto de entrada principal do seu projeto é foobar.</description>
    </item>
    
    <item>
      <title>Funções de ordem superior</title>
      <link>https://www.wikiod.com/pt/ocaml/funcoes-de-ordem-superior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/funcoes-de-ordem-superior/</guid>
      <description>Sintaxe # val (|&amp;gt;) : &#39;a -&amp;gt; (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;b val (@@) : (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a -&amp;gt; &#39;b Algoritmos genéricos # Funções de ordem superior podem ser usadas para implementar algoritmos genéricos, desistindo da responsabilidade de fornecer detalhes finais ao usuário. Por exemplo, List.sort espera uma função de comparação, que permite implementar várias formas de ordenação. Aqui implementamos a classificação de strings que não diferencia maiúsculas de minúsculas:</description>
    </item>
    
    <item>
      <title>Processamento de lista</title>
      <link>https://www.wikiod.com/pt/ocaml/processamento-de-lista/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/processamento-de-lista/</guid>
      <description>Lista.Mapa # List.map tem a assinatura (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a list -&amp;gt; &#39;b list que em inglês é uma função que recebe uma função (chamaremos isso de função de mapeamento) de um tipo (ou seja, &#39;a) para outro tipo (ou seja, &#39;b) e uma lista do primeiro tipo. A função retorna uma lista do segundo tipo onde cada elemento é o resultado da chamada da função de mapeamento em um elemento da primeira lista.</description>
    </item>
    
    <item>
      <title>Funções</title>
      <link>https://www.wikiod.com/pt/ocaml/funcoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/funcoes/</guid>
      <description>Funções anônimas # Como as funções são valores comuns, existe uma sintaxe conveniente para criar funções sem nomes:
List.map (fun x -&amp;gt; x * x) [1; 2; 3; 4] (* - : int list = [1; 4; 9; 16] *) Isso é útil, pois, caso contrário, teríamos que nomear a função primeiro (consulte [let][1]) para poder usá-la:
let square x = x * x (* val square : int -&amp;gt; int = &amp;lt;fun&amp;gt; *) List.</description>
    </item>
    
    <item>
      <title>Pipes, arquivos e fluxos</title>
      <link>https://www.wikiod.com/pt/ocaml/pipes-arquivos-e-fluxos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/pipes-arquivos-e-fluxos/</guid>
      <description>Leia da entrada padrão e imprima na saída padrão # Preparamos um arquivo chamado reverser.ml com o seguinte conteúdo:
let acc = ref [] in try while true do acc := read_line () :: !acc; done with End_of_file -&amp;gt; print_string (String.concat &amp;quot;\n&amp;quot; !acc) Em seguida, compilamos nosso programa usando o seguinte comando:
$ ocamlc -o reverser.byte reverser.ml Testamos canalizando dados para nosso novo executável:
$ cat data.txt one two three $ .</description>
    </item>
    
    <item>
      <title>Armadilhas comuns</title>
      <link>https://www.wikiod.com/pt/ocaml/armadilhas-comuns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/armadilhas-comuns/</guid>
      <description>Usando o operador errado # Em OCaml, existem diferentes operadores aritméticos para floats e integers. Além disso, esses operadores só podem ser usados ​​em 2 floats ou 2 integers. Aqui estão expressões inválidas no OCaml
1.0 + 2.0 1 + 2.0 1 +. 2 1 +. 2.0 A expressão correta para cada um deles, respectivamente, é
1. +. 2. float_of_int 1 +. 2. 1 + 2 float_of_int 1 +. 2. Não há conversão automática de inteiros para floats ou vice-versa no OCaml.</description>
    </item>
    
    <item>
      <title>Campos de registro mutáveis</title>
      <link>https://www.wikiod.com/pt/ocaml/campos-de-registro-mutaveis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ocaml/campos-de-registro-mutaveis/</guid>
      <description>Como a maioria dos valores OCaml, os registros são imutáveis ​​por padrão. No entanto, como o OCaml também lida com programação imperativa, ele fornece uma maneira de tornar os campos individuais mutáveis. Os campos mutáveis ​​podem ser modificados no local por atribuição, em vez de recorrer a técnicas funcionais usuais, como atualização funcional.
Ao introduzir efeitos colaterais, os campos mutáveis ​​podem resultar em um desempenho aprimorado quando usados ​​corretamente.
Declarando um registro com campos mutáveis # A seguir, weight é declarado como um campo mutável.</description>
    </item>
    
  </channel>
</rss>
