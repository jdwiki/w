<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial unity3d on </title>
    <link>https://www.wikiod.com/pt/docs/unity3d/</link>
    <description>Recent content in Tutorial unity3d on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/unity3d/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com o unity3d</title>
      <link>https://www.wikiod.com/pt/unity3d/comecando-com-o-unity3d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/comecando-com-o-unity3d/</guid>
      <description>Instalação ou configuração # Visão geral # O Unity é executado em Windows e Mac. Há também uma versão alfa do Linux disponível.
Existem 4 planos de pagamento diferentes para o Unity:
Pessoal - Gratuito (veja abaixo) Mais - US$ 35 por mês por assento (veja abaixo) Pro - $125 USD por mês por estação - Após assinar o plano Pro por 24 meses consecutivos, você tem a opção de parar de assinar e manter a versão que possui.</description>
    </item>
    
    <item>
      <title>Usando o controle de origem do Git com Unity</title>
      <link>https://www.wikiod.com/pt/unity3d/usando-o-controle-de-origem-do-git-com-unity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/usando-o-controle-de-origem-do-git-com-unity/</guid>
      <description>Configurando um repositório Git para Unity # Ao inicializar um repositório Git para desenvolvimento em Unity, há algumas coisas que precisam ser feitas.
Unity Ignorar Pastas # Nem tudo deve ser versionado no repositório. Você pode adicionar o modelo abaixo ao seu arquivo .gitignore na raiz do seu repositório. Ou, alternativamente, você pode verificar o código aberto Unity .gitignore no GitHub e, alternativamente, gerar um usando gitignore.io for unity.
# Unity Generated [Tt]emp/ [Ll]ibrary/ [Oo]bj/ # Unity3D Generated File On Crash Reports sysinfo.</description>
    </item>
    
    <item>
      <title>Estendendo o Editor</title>
      <link>https://www.wikiod.com/pt/unity3d/estendendo-o-editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/estendendo-o-editor/</guid>
      <description>Sintaxe # [MenuItem(string itemName)] [MenuItem(string itemName, bool isValidateFunction)] [MenuItem(string itemName, bool isValidateFunction, int priority)] [ContextMenu(nome da string)] [ContextMenuItem(nome da string, função da string)] [DrawGizmo(GizmoType gizmo)] [DrawGizmo(GizmoType gizmo, Type drawGizmoType)] Parâmetros # Parâmetro Detalhes MenuComando MenuCommand é usado para extrair o contexto de um MenuItem MenuCommand.context O objeto que é o destino do comando de menu MenuCommand.userData Um int para passar informações personalizadas para um item de menu Inspetor personalizado # O uso de um inspetor personalizado permite alterar a maneira como um script é desenhado no Inspetor.</description>
    </item>
    
    <item>
      <title>Singletons em Unity</title>
      <link>https://www.wikiod.com/pt/unity3d/singletons-em-unity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/singletons-em-unity/</guid>
      <description>Embora existam escolas de pensamento que apresentam argumentos convincentes por que o uso irrestrito de Singletons é uma má ideia, por exemplo. Singleton em gameprogrammingpatterns.com, há ocasiões em que você pode querer persistir um GameObject no Unity em várias cenas (por exemplo, para música de fundo contínua), garantindo que não mais de uma instância possa existir; um caso de uso perfeito para um Singleton.
Ao adicionar este script a um GameObject, uma vez que ele tenha sido instanciado (por exemplo, incluindo-o em qualquer lugar em uma cena), ele permanecerá ativo nas cenas e apenas uma instância existirá.</description>
    </item>
    
    <item>
      <title>Corrotinas</title>
      <link>https://www.wikiod.com/pt/unity3d/corrotinas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/corrotinas/</guid>
      <description>Sintaxe # public Coroutine StartCoroutine(rotina IEnumerator); public Coroutine StartCoroutine(string methodName, object value = null); public void StopCoroutine(string methodName); public void StopCoroutine(rotina IEnumerator); public void StopAllCoroutines(); Considerações de desempenho # É melhor usar corrotinas com moderação, pois a flexibilidade vem com um custo de desempenho.
Corrotinas em grande número exigem mais da CPU do que os métodos padrão de atualização. Há um problema em algumas versões do Unity onde as corrotinas produzem lixo a cada ciclo de atualização devido ao Unity boxing o valor de retorno MoveNext.</description>
    </item>
    
    <item>
      <title>Otimização</title>
      <link>https://www.wikiod.com/pt/unity3d/otimizacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/otimizacao/</guid>
      <description>Se possível, desative scripts em objetos quando eles não forem necessários. Por exemplo, se você tem um script em um objeto inimigo que procura e dispara contra o jogador, considere desabilitar este script quando o inimigo estiver muito longe, por exemplo, do jogador. Poder de Corrotina # Uso # Se você tiver uma operação de longa duração que depende da API Unity não thread-safe, use Coroutines para dividi-la em vários quadros e manter seu aplicativo responsivo.</description>
    </item>
    
    <item>
      <title>Rede</title>
      <link>https://www.wikiod.com/pt/unity3d/rede/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/rede/</guid>
      <description>Modo sem cabeça no Unity # Se você estiver criando um servidor para implantar no Linux, as configurações de compilação têm uma opção &amp;ldquo;Modo sem comando&amp;rdquo;. Uma compilação de aplicativo com essa opção não exibe nada e não lê a entrada do usuário, que geralmente é o que queremos para um servidor.
Criando um servidor, um cliente e enviando uma mensagem. # A rede Unity fornece a API de alto nível (HLA) para lidar com comunicações de rede abstraídas de implementações de baixo nível.</description>
    </item>
    
    <item>
      <title>Agrupamento de objetos</title>
      <link>https://www.wikiod.com/pt/unity3d/agrupamento-de-objetos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/agrupamento-de-objetos/</guid>
      <description>Conjunto de objetos # Às vezes, quando você faz um jogo, precisa criar e destruir vários objetos do mesmo tipo repetidamente. Você pode simplesmente fazer isso criando um prefab e instanciar/destruir isso sempre que precisar, no entanto, fazer isso é ineficiente e pode deixar seu jogo mais lento.
Uma maneira de contornar esse problema é o agrupamento de objetos. Basicamente o que isso significa é que você tem um pool (com ou sem limite para a quantidade) de objetos que você vai reutilizar sempre que puder para evitar instanciação ou destruição desnecessária.</description>
    </item>
    
    <item>
      <title>Pré-fabricados</title>
      <link>https://www.wikiod.com/pt/unity3d/pre-fabricados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/pre-fabricados/</guid>
      <description>Sintaxe # Public static Object PrefabUtility.InstantiatePrefab(Object target); objeto estático público AssetDatabase.LoadAssetAtPath(string assetPath, Type type); objeto estático público Object.Instantiate(Objeto original); Public static Object Resources.Load(string path); Introdução # Prefabs são um tipo de ativo que permite o armazenamento de um GameObject completo com seus componentes, propriedades, componentes anexados e valores de propriedade serializados. Há muitos cenários em que isso é útil, incluindo:
Duplicando objetos em uma cena Compartilhando um objeto comum em várias cenas Ser capaz de modificar um prefab uma vez e aplicar as alterações em vários objetos/cenas Criando objetos duplicados com pequenas modificações, enquanto os elementos comuns podem ser editados a partir de uma base pré-fabricada Instanciando GameObjects em tempo de execução Existe uma regra prática no Unity que diz que &amp;ldquo;tudo deve ser Prefabs&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>API CullingGroup</title>
      <link>https://www.wikiod.com/pt/unity3d/api-cullinggroup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/unity3d/api-cullinggroup/</guid>
      <description>Como o uso de CullingGroups nem sempre é muito simples, pode ser útil encapsular a maior parte da lógica por trás de uma classe de gerenciador.
Abaixo está um plano de como esse gerente pode operar.
using UnityEngine; using System; public interface ICullingGroupManager { int ReserveSphere(); void ReleaseSphere(int sphereIndex); void SetPosition(int sphereIndex, Vector3 position); void SetRadius(int sphereIndex, float radius); void SetCullingEvent(int sphereIndex, Action&amp;lt;CullingGroupEvent&amp;gt; sphere); } A essência disso é que você reserva uma esfera de seleção do gerenciador que retorna o índice da esfera reservada.</description>
    </item>
    
  </channel>
</rss>
