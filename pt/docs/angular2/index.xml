<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Angular 2 on </title>
    <link>https://www.wikiod.com/pt/docs/angular2/</link>
    <description>Recent content in Tutorial de Angular 2 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/angular2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com Angular 2</title>
      <link>https://www.wikiod.com/pt/angular2/comecando-com-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/comecando-com-angular-2/</guid>
      <description>Instale o angular2 com angular-cli # Este exemplo é uma configuração rápida do Angular 2 e como gerar um projeto de exemplo rápido.
Pré-requisitos: # Node.js v4 ou superior. npm v3 ou superior ou yarn. Abra um terminal e execute os comandos um por um:
npm install -g @angular/cli ou
yarn global add @angular/cli dependendo da sua escolha de gerenciador de pacotes.
O comando anterior instala @angular/cli globalmente, adicionando o executável ng ao PATH.</description>
    </item>
    
    <item>
      <title>Atualização do Angular 2 Forms</title>
      <link>https://www.wikiod.com/pt/angular2/atualizacao-do-angular-2-forms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/atualizacao-do-angular-2-forms/</guid>
      <description>Angular 2 permite acessar a instância ngForm criando uma variável de modelo local. Angular 2 expõe instâncias de diretivas como ngForm especificando a propriedade exportAs dos metadados da diretiva. Agora, a vantagem aqui é que sem muita codificação você pode acessar a instância do ngForm e usá-la para acessar os valores enviados ou para verificar se todos os campos são válidos usando propriedades (válido, enviado, valor etc).
#f = ngForm (creates local template instance &amp;quot;f&amp;quot;) ngForm emite o evento &amp;ldquo;ngSubmit&amp;rdquo; quando é enviado (Verifique a documentação do @Output para obter mais detalhes do emissor do evento)</description>
    </item>
    
    <item>
      <title>Tubos</title>
      <link>https://www.wikiod.com/pt/angular2/tubos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/tubos/</guid>
      <description>O caractere pipe | é usado para aplicar pipes no Angular 2. Os pipes são muito semelhantes aos filtros no AngularJS, pois ambos ajudam a transformar os dados em um formato especificado.
Parâmetros # Função/Parâmetro Explicação @Pipe({nome, puro}) metadados para pipe, deve preceder imediatamente a classe de pipe nome: cadeia o que você vai usar dentro do template puro: booleano o padrão é true, marque isso como false para que seu pipe seja reavaliado com mais frequência transform( valor, args[]?</description>
    </item>
    
    <item>
      <title>Adicione componentes dinamicamente usando ViewContainerRef.createComponent</title>
      <link>https://www.wikiod.com/pt/angular2/adicione-componentes-dinamicamente-usando-viewcontainerrefcreatecomponent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/adicione-componentes-dinamicamente-usando-viewcontainerrefcreatecomponent/</guid>
      <description>Um componente wrapper que adiciona componentes dinâmicos declarativamente # Um componente personalizado que recebe o tipo de um componente como entrada e cria uma instância desse tipo de componente dentro de si. Quando a entrada é atualizada, o componente dinâmico adicionado anteriormente é removido e o novo é adicionado em seu lugar.
@Component({ selector: &#39;dcl-wrapper&#39;, template: `&amp;lt;div #target&amp;gt;&amp;lt;/div&amp;gt;` }) export class DclWrapper { @ViewChild(&#39;target&#39;, { read: ViewContainerRef }) target; @Input() type; cmpRef: ComponentRef; private isViewInitialized: boolean = false; constructor(private resolver: ComponentResolver) {} updateComponent() { if (!</description>
    </item>
    
    <item>
      <title>Zombando de @ngrxStore</title>
      <link>https://www.wikiod.com/pt/angular2/zombando-de-ngrxstore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/zombando-de-ngrxstore/</guid>
      <description>@ngrx/Store está se tornando mais amplamente utilizado em projetos Angular 2. Como tal, a Loja deve ser injetada no construtor de qualquer Componente ou Serviço que deseje usá-la. Teste de unidade Store não é tão fácil quanto testar um serviço simples. Tal como acontece com muitos problemas, há uma infinidade de maneiras de implementar soluções. No entanto, a receita básica é escrever uma classe simulada para a interface do Observer e escrever uma classe simulada para Store.</description>
    </item>
    
    <item>
      <title>Angular RXJS Subjects and Observables com solicitações de API</title>
      <link>https://www.wikiod.com/pt/angular2/angular-rxjs-subjects-and-observables-com-solicitacoes-de-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/angular-rxjs-subjects-and-observables-com-solicitacoes-de-api/</guid>
      <description>Fazer solicitações de API com o serviço Angular 2 Http e RxJS é muito semelhante a trabalhar com promessas no Angular 1.x.
Use a classe Http para fazer solicitações. A classe Http expõe os métodos para emitir solicitações HTTP GET, POST, PUT, DELETE, PATCH, HEAD por meio de métodos correspondentes. Ele também expõe um método genérico request para emitir qualquer tipo de solicitação HTTP.
Todos os métodos da classe Http retornam um Observable&amp;lt;Response&amp;gt;, ao qual você pode aplicar operações RxJS.</description>
    </item>
    
    <item>
      <title>Roteamento (3.0.0&#43;)</title>
      <link>https://www.wikiod.com/pt/angular2/roteamento-300-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/roteamento-300-/</guid>
      <description>Existem mais alguns truques que podemos fazer com o roteador (como restringir o acesso), mas eles podem ser abordados em um tutorial separado.
Se você precisar de uma nova rota, basta modificar app.routes.ts e seguir os seguintes passos:
Importe o Componente Adicione ao array routes. Certifique-se de incluir um novo path e component. Controlando o acesso de ou para uma rota # O roteador Angular padrão permite a navegação de e para qualquer rota incondicionalmente.</description>
    </item>
    
    <item>
      <title>Módulo vazio de bootstrap em angular 2</title>
      <link>https://www.wikiod.com/pt/angular2/modulo-vazio-de-bootstrap-em-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/modulo-vazio-de-bootstrap-em-angular-2/</guid>
      <description>Um módulo vazio # import { NgModule } from &#39;@angular/core&#39;; @NgModule({ declarations: [], // components your module owns. imports: [], // other modules your module needs. providers: [], // providers available to your module. bootstrap: [] // bootstrap this root component. }) export class MyModule {} Este é um módulo vazio que não contém declarações, importações, provedores ou componentes para bootstrap. Use isso como referência.
Módulo raiz do aplicativo # import { NgModule } from &#39;@angular/core&#39;; import { BrowserModule } from &#39;@angular/platform-browser&#39;; import { AppComponent } from &#39;.</description>
    </item>
    
    <item>
      <title>Testando um aplicativo Angular 2</title>
      <link>https://www.wikiod.com/pt/angular2/testando-um-aplicativo-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/testando-um-aplicativo-angular-2/</guid>
      <description>Instalando a estrutura de teste Jasmine # A maneira mais comum de testar aplicativos Angular 2 é com a estrutura de teste Jasmine. Jasmine permite que você teste seu código no navegador.
Instalar # Para começar, tudo que você precisa é do pacote jasmine-core (não jasmine).
npm install jasmine-core --save-dev --save-exact Verificar # Para verificar se o Jasmine está configurado corretamente, crie o arquivo ./src/unit-tests.html com o seguinte conteúdo e abra-o no navegador.</description>
    </item>
    
    <item>
      <title>Detectando eventos de redimensionamento</title>
      <link>https://www.wikiod.com/pt/angular2/detectando-eventos-de-redimensionamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/angular2/detectando-eventos-de-redimensionamento/</guid>
      <description>Um componente ouvindo o evento de redimensionamento da janela. # Suponha que tenhamos um componente que se esconderá em uma certa largura de janela.
import { Component } from &#39;@angular/core&#39;; @Component({ ... template: ` &amp;lt;div&amp;gt; &amp;lt;p [hidden]=&amp;quot;!visible&amp;quot; (window:resize)=&amp;quot;onResize($event)&amp;quot; &amp;gt;Now you see me...&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;now you dont!&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ` ... }) export class MyComponent { visible: boolean = false; breakpoint: number = 768; constructor() { } onResize(event) { const w = event.target.innerWidth; if (w &amp;gt;= this.</description>
    </item>
    
  </channel>
</rss>
