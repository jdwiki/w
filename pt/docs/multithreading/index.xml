<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial multithread on </title>
    <link>https://www.wikiod.com/pt/docs/multithreading/</link>
    <description>Recent content in Tutorial multithread on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/multithreading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao multithreading</title>
      <link>https://www.wikiod.com/pt/multithreading/introducao-ao-multithreading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/multithreading/introducao-ao-multithreading/</guid>
      <description>Impasses # Um deadlock ocorre quando cada membro de algum grupo de dois ou mais threads deve esperar que um dos outros membros faça algo (por exemplo, liberar um bloqueio) antes de prosseguir. Sem intervenção, os threads vão esperar para sempre.
Um exemplo de pseudocódigo de um projeto propenso a deadlock é:
thread_1 { acquire(A) ... acquire(B) ... release(A, B) } thread_2 { acquire(B) ... acquire(A) ... release(A, B) } Um deadlock pode ocorrer quando thread_1 adquiriu A, mas ainda não B, e thread_2 adquiriu B, mas não A.</description>
    </item>
    
    <item>
      <title>Executores</title>
      <link>https://www.wikiod.com/pt/multithreading/executores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/multithreading/executores/</guid>
      <description>Sintaxe # ThreadPoolExecutor
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidade TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidade TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, Manipulador RejectedExecutionHandler)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidade TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)
Executors.callable(PrivilegedAction&amp;lt;?&amp;gt; ação)
Executors.callable(PrivilegedExceptionAction&amp;lt;?&amp;gt; ação)
Executors.callable(tarefa executável)
Executors.callable(tarefa executável, resultado T)
Executors.defaultThreadFactory()
Executors.newCachedThreadPool()
Executors.newCachedThreadPool(ThreadFactory threadFactory)
Executors.newFixedThreadPool(int nThreads)
Executors.newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</description>
    </item>
    
    <item>
      <title>Semáforos e mutexes</title>
      <link>https://www.wikiod.com/pt/multithreading/semaforos-e-mutexes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/multithreading/semaforos-e-mutexes/</guid>
      <description>Semáforos e mutexes são controles de simultaneidade usados ​​para sincronizar o acesso de vários threads a recursos compartilhados.
Semáforo # Aqui está uma explicação brilhante de esta pergunta do Stackoverflow:
Pense nos semáforos como seguranças em uma boate. Há um dedicado número de pessoas permitidas no clube ao mesmo tempo. Se o clube for cheio ninguém pode entrar, mas assim que uma pessoa sai outra pessoa pode entrar.
É simplesmente uma forma de limitar o número de consumidores de um recurso específico.</description>
    </item>
    
  </channel>
</rss>
