<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ada Tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/ada/</link>
    <description>Recent content in ada Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/ada/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com ada</title>
      <link>https://www.wikiod.com/pt/ada/comecando-com-ada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/comecando-com-ada/</guid>
      <description>Versão # A linguagem de programação padrão Ada é definida no Ada Reference Manual. Alterações de versão provisórias e notas de lançamento são discutidas nos documentos de justificativa correspondentes. As implementações normalmente documentam sua conformidade com o padrão na forma de um guia do usuário e/ou manual de referência, por exemplo.
Ada 2012
Ada 2012 Language Reference Manual Rationale for Ada 2012 Ada 2005
Ada 2005 Language Reference Manual [Rationale for Ada 2005][6] Ada 95</description>
    </item>
    
    <item>
      <title>Imagem de atributo</title>
      <link>https://www.wikiod.com/pt/ada/imagem-de-atributo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/imagem-de-atributo/</guid>
      <description>Os atributos de subtipo &#39;Image e &#39;Value receberão, respectivamente, um valor escalar e uma string e retornarão, respectivamente, uma string e um valor escalar. O resultado de &#39;Image pode ser inserido em &#39;Value para obter o valor original. A recíproca também é verdadeira.
O atributo __Scalar_Object__&#39;Image pode ser usado diretamente em objetos (desde Ada 2012-TC-1).
Sintaxe # função Scalar&amp;rsquo;Image (Argumento: Scalar&amp;rsquo;Base) return String; função Discrete&amp;rsquo;Image (Argumento: Discrete&amp;rsquo;Base) return String; função Integer&amp;rsquo;Image (Argumento: Integer&amp;rsquo;Base) return String; função Enumeration&amp;rsquo;Image (Argumento: Enumeration&amp;rsquo;Base) return String; função Real&amp;rsquo;Image (Argumento: Real&amp;rsquo;Base) return String; função Numeric&amp;rsquo;Image (Argumento: Numeric&amp;rsquo;Base) return String; função Scalar&amp;rsquo;Value (Argumento: String) return Scalar&amp;rsquo;Base; função Discrete&amp;rsquo;Value (Argumento: String) return Discrete&amp;rsquo;Base; função Integer&amp;rsquo;Value (Argumento: String) return Integer&amp;rsquo;Base; função Enumeration&amp;rsquo;Value (Argumento: String) return Enumeration&amp;rsquo;Base; função Real&amp;rsquo;Value (Argumento: String) return Real&amp;rsquo;Base; função Scalar_Object&amp;lsquo;Imagem return String; Note que &#39;Image pode gerar resultados definidos pela implementação (RM 3.</description>
    </item>
    
    <item>
      <title>Implementando o padrão produtor-consumidor</title>
      <link>https://www.wikiod.com/pt/ada/implementando-o-padrao-produtor-consumidor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/implementando-o-padrao-produtor-consumidor/</guid>
      <description>Uma demonstração de como o padrão produtor-consumidor é implementado no Ada.
Sintaxe # function Scalar&amp;rsquo;Image (Argumento: Scalar&amp;rsquo;Base) return String; tarefa Task_Name; task Task_Name é o fim das entradas; task body Task_Name é Declarações começam Código final; entrada Entry_Name; aceitar Entry_Name; saída; Todos os exemplos deveriam garantir o término adequado da tarefa.
Padrão produtor-consumidor usando o mecanismo Ada Rendezvous # Uma solução síncrona produtor-consumidor garante que o consumidor leia cada item de dados gravado pelo produtor exatamente uma vez.</description>
    </item>
    
    <item>
      <title>Enumeração</title>
      <link>https://www.wikiod.com/pt/ada/enumeracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/enumeracao/</guid>
      <description>Sintaxe # função Enumeration&amp;rsquo;Image (Argumento: Enumeration&amp;rsquo;Base) return String; função Enumeração&amp;rsquo;Img return String; &amp;ndash; GNAT função Enumeration&amp;rsquo;Val (Argumento: Universal_Integer) return Enumeration&amp;rsquo;Base; função Enumeration&amp;rsquo;Pos (Argumento: Enumeration&amp;rsquo;Base) return Universal_Integer; função Enumeration&amp;rsquo;Enum_Rep (Argumento: Enumeration&amp;rsquo;Base) return Universal_Integer; função Literal&amp;lsquo;Enum_Rep return Universal_Integer; &amp;ndash; GNAT função Literal&amp;lsquo;Address return System.Address; para uso de Enumeração (Literal_1 =&amp;gt; Universal_Integer, Literal_n =&amp;gt; Universal_Integer); (Literal em Enumeration) return Boolean; Iterando literais # Um literal dentro de uma enumeração é um tipo discreto, então podemos usar o atributo Image para descobrir qual literal ele é na forma de texto.</description>
    </item>
    
    <item>
      <title>Arquivos e fluxos de ES</title>
      <link>https://www.wikiod.com/pt/ada/arquivos-e-fluxos-de-es/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/arquivos-e-fluxos-de-es/</guid>
      <description>A biblioteca padrão Ada fornece E/S de arquivos tradicionais de texto ou dados binários, bem como E/S de arquivos transmitidos. Arquivos de dados binários serão sequências de valores de um tipo, enquanto arquivos de fluxo podem ser sequências de valores de tipos possivelmente diferentes.
Para ler e escrever elementos de diferentes tipos de/para arquivos de fluxo, Ada usa subprogramas denotados por atributos de tipos, a saber, &#39;Read, &#39;Write, &#39;Input e &#39;Output.</description>
    </item>
    
    <item>
      <title>Tarefa</title>
      <link>https://www.wikiod.com/pt/ada/tarefa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/tarefa/</guid>
      <description>Sintaxe # tarefa Task_Name; task Task_Name é o fim das entradas; corpo da tarefa Task_Name é Declarações começam Código final; Uma tarefa simples # with Ada.Text_IO; use Ada.Text_IO; procedure Main is task My_Task; task body My_Task is begin Put_Line (&amp;quot;Hello from My_Task&amp;quot;); end; begin Put_Line (&amp;quot;Hello from Main&amp;quot;); end; Resultado # A ordem de Put_Line pode variar.
Hello from My_Task Hello from Main Uma tarefa simples e um loop # with Ada.</description>
    </item>
    
    <item>
      <title>pacote Ada.Text_IO</title>
      <link>https://www.wikiod.com/pt/ada/pacote-adatext_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/pacote-adatext_io/</guid>
      <description>O pacote Ada.Text_IO é usado para colocar texto ou obter texto de arquivos ou console.
Put_Line # Imprime string com uma nova linha.
with Ada.Text_IO; procedure Put_Text is use Ada.Text_IO; S : String := &amp;quot;Hello&amp;quot;; begin Put_Line (&amp;quot;Hello&amp;quot;); Put_Line (Standard_Output, &amp;quot;Hello&amp;quot;); Put_Line (Standard_Error, &amp;quot;Hello error&amp;quot;); Put_Line (S &amp;amp; &amp;quot; World&amp;quot;); end; Resultado # Hello Hello Hello error Hello World </description>
    </item>
    
    <item>
      <title>Pacotes</title>
      <link>https://www.wikiod.com/pt/ada/pacotes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/pacotes/</guid>
      <description>Sintaxe # com Package_Name_To_Include; o pacote New_Package_Name renomeia Package_To_Rename; use Package_Name; o pacote Parent_Name.Child_Name é Pacote fornece:
Encapsulamento de código Compilação separada Ocultar procedimentos, funções, operadores em tipos privados Semelhanças ou análogos em outras línguas:
espaço de nomes C++ pacotes Java Mais sobre Pacotes # No Hello World, você foi apresentado ao pacote Ada.Text_IO, e como usá-lo para realizar operações de E/S em seu programa. Os pacotes podem ser manipulados para fazer muitas coisas diferentes.</description>
    </item>
    
    <item>
      <title>Tipos parametrizados</title>
      <link>https://www.wikiod.com/pt/ada/tipos-parametrizados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/tipos-parametrizados/</guid>
      <description>Todos os tipos compostos, exceto arrays, podem ter discriminantes, que são componentes com propriedades especiais. Os discriminantes podem ser do tipo discreto ou do tipo de acesso. Neste último caso, o tipo de acesso pode ser um tipo de acesso nomeado ou pode ser anônimo. Um discriminante de um tipo de acesso anônimo é chamado de discriminante de acesso por analogia com um parâmetro de acesso.
Tipos de registro discriminados # No caso de um tipo de registro discriminado, alguns dos componentes são conhecidos como discriminantes e os componentes restantes podem depender deles.</description>
    </item>
    
    <item>
      <title>Tipos escalares</title>
      <link>https://www.wikiod.com/pt/ada/tipos-escalares/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/ada/tipos-escalares/</guid>
      <description>Na hierarquia de tipos de Ada, os tipos elementares têm conjuntos de valores logicamente indivisíveis. Entre esses tipos estão os tipos de acesso (tipos de ponteiro) e os tipos escalares. Os tipos escalares podem ser categorizados como enumeração, caractere e numérico. Esses tipos formam o assunto deste tópico. Além dos conjuntos de valores, os tipos possuem conjuntos de operações aplicáveis ​​aos respectivos escalares, como sucessor, ou &amp;quot;+&amp;quot;.
Sintaxe # tipo … é … Parâmetros # Reticências O que … (1) para receber o nome do tipo … (2) para receber as características do tipo usando palavras-chave: delta, digits, range Todas as definições de tipo escalar, exceto enumeração e inteiros modulares, podem incluir uma restrição range.</description>
    </item>
    
  </channel>
</rss>
