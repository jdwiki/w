<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial makefile on </title>
    <link>https://www.wikiod.com/pt/docs/makefile/</link>
    <description>Recent content in tutorial makefile on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/makefile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao makefile</title>
      <link>https://www.wikiod.com/pt/makefile/introducao-ao-makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/makefile/introducao-ao-makefile/</guid>
      <description>Makefile básico # Considere escrever um &amp;ldquo;olá, mundo!&amp;rdquo; programa em c. Digamos que nosso código fonte esteja em um arquivo chamado source.c, agora para rodar nosso programa precisamos compilá-lo, normalmente no Linux (usando gcc) precisaríamos digitar $&amp;gt; gcc source.c -o output onde output é o nome do executável a ser gerado. Para um programa básico, isso funciona bem, mas à medida que os programas se tornam mais complexos, nosso comando de compilação também pode se tornar mais complexo.</description>
    </item>
    
    <item>
      <title>Makefile Avançado</title>
      <link>https://www.wikiod.com/pt/makefile/makefile-avancado/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/makefile/makefile-avancado/</guid>
      <description>Construindo de diferentes pastas de origem para diferentes pastas de destino # Principais características deste Makefile:
Detecção automática de fontes C em pastas especificadas Várias pastas de origem Várias pastas de destino correspondentes para arquivos de objetos e dependências Geração automática de regras para cada pasta de destino Criação de pastas de destino quando elas não existem Gerenciamento de dependências com gcc: Construa apenas o necessário Funciona em sistemas Unix e DOS Escrito para GNU Make Este Makefile pode ser usado para construir um projeto com este tipo de estrutura:</description>
    </item>
    
    <item>
      <title>Variáveis</title>
      <link>https://www.wikiod.com/pt/makefile/variaveis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/makefile/variaveis/</guid>
      <description>Atribuição de variável condicional # O operador ?= é uma extensão que se comporta como =, exceto que a atribuição somente ocorre se a variável ainda não estiver definida.
x = hello x ?= world # $(x) will yield &amp;quot;hello&amp;quot; Variáveis ​​Automáticas # Dentro do contexto de uma regra individual, Make define automaticamente uma série de variáveis ​​especiais. Essas variáveis ​​podem ter um valor diferente para cada regra em um makefile e são projetadas para simplificar a escrita de regras.</description>
    </item>
    
    <item>
      <title>.PHONY destino</title>
      <link>https://www.wikiod.com/pt/makefile/phony-destino/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/makefile/phony-destino/</guid>
      <description>Usando .PHONY para destinos que não são arquivos # Use .PHONY para especificar os destinos que não são arquivos, por exemplo, clean ou mrproper.
Bom exemplo
.PHONY: clean clean: rm *.o temp Mau exemplo
clean: rm *.o temp No bom exemplo o make sabe que clean não é um arquivo, portanto não irá pesquisar se está ou não atualizado e executará a receita.
No exemplo ruim, o make procurará um arquivo chamado clean.</description>
    </item>
    
    <item>
      <title>Regras do padrão GNU</title>
      <link>https://www.wikiod.com/pt/makefile/regras-do-padrao-gnu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/makefile/regras-do-padrao-gnu/</guid>
      <description>Destinos que correspondem a várias regras de padrão # Se um destino corresponder a várias regras de padrão, make usará aquele cujos pré-requisitos existem ou podem ser construídos. Por exemplo:
%.o: %.c $(CC) $(CFLAGS) -c $&amp;lt; -o $@ %.o: %.s $(AS) $(ASFLAGS) $&amp;lt; -o $@ Compilará foo.c para foo.o ou montará foo.s para foo.o, dependendo de qual de foo.c ou foo.s existe.
Se várias regras tiverem pré-requisitos que existam ou possam ser construídos, make usará a regra que corresponde à haste mais curta.</description>
    </item>
    
  </channel>
</rss>
