<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haxe Tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/haxe/</link>
    <description>Recent content in Haxe Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/haxe/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com Haxe</title>
      <link>https://www.wikiod.com/pt/haxe/comecando-com-haxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/comecando-com-haxe/</guid>
      <description>Olá Mundo # Requisitos # Uma versão do kit de ferramentas Haxe deve ser instalada Haxe deve estar presente no caminho do sistema A linha de comando deve ser acessível Código # Navegue até um diretório de projeto desejado e crie um arquivo fonte Test.hx com o seguinte conteúdo:
class Test { static function main() { trace(&amp;quot;Hello world&amp;quot;); } } Os arquivos de origem Haxe são chamados de módulos. Um módulo deve definir um tipo (abstract, class, enum, interface ou typedef) com o mesmo identificador do nome do módulo - neste caso a classe Test.</description>
    </item>
    
    <item>
      <title>Enums</title>
      <link>https://www.wikiod.com/pt/haxe/enums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/enums/</guid>
      <description>Sintaxe # enum identificador { construtores } Capturando valores enum # Os valores passados ​​como argumentos do construtor enum podem ser capturados em variáveis ​​usando pattern matching.
Suponha o seguinte enum:
enum Color { RGB(r : Int, g : Int, b : Int); HSV(h : Int, s : Float, v : Float); } O valor do canal vermelho pode ser capturado da seguinte forma:
var color = Color.RGB(255, 127, 0); var red = switch (color) { // Match the Color.</description>
    </item>
    
    <item>
      <title>rotações</title>
      <link>https://www.wikiod.com/pt/haxe/rotacoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/rotacoes/</guid>
      <description>Sintaxe # for (identificador de variável em coleção iterativa) { expressão } while (condição) { expressão } do { expressão } while (condição); parar; Prosseguir; Por # Loops for iterar em uma coleção iterativa. Uma coleção iterativa é qualquer classe que unifica estruturalmente com os tipos Iterator&amp;lt;T&amp;gt; ou Iterable&amp;lt;T&amp;gt; da biblioteca padrão Haxe.
Um loop for que registra números no intervalo de 0 a 10 (exclusivo) pode ser escrito da seguinte forma:</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/haxe/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/correspondencia-de-padroes/</guid>
      <description>A correspondência de padrões é o processo de ramificação dependendo dos padrões fornecidos. Toda a correspondência de padrões é feita dentro de uma expressão switch, e expressões case individuais representam os padrões.
As regras fundamentais da correspondência de padrões são:
os padrões serão sempre combinados de cima para baixo; o padrão superior que corresponde ao valor de entrada tem sua expressão executada; um padrão _ corresponde a qualquer coisa, então case _: é igual a default:.</description>
    </item>
    
    <item>
      <title>Resumos</title>
      <link>https://www.wikiod.com/pt/haxe/resumos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/resumos/</guid>
      <description>Sintaxe # abstract identifier(underyling type) { &amp;hellip; } identificador abstrato (tipo subjacente) de tipoA de tipoB &amp;hellip; a tipoA a tipoB { &amp;hellip; } Um tipo abstrato é um tipo compile-time que resolve para o tipo subjacente em run-time. Isso significa que o tipo abstrato não existe no código-fonte gerado pelo compilador Haxe. Em seu lugar são colocados o tipo subjacente, ou tipos definidos para conversão implícita.
Os resumos são indicados pela palavra-chave abstract, seguida por um identificador e o tipo subjacente entre parênteses.</description>
    </item>
    
    <item>
      <title>Ramificação</title>
      <link>https://www.wikiod.com/pt/haxe/ramificacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haxe/ramificacao/</guid>
      <description>Sintaxe # if (condição) { &amp;hellip; } if (condição) { &amp;hellip; } else { &amp;hellip; } if (condição) { &amp;hellip; } else if (condição) { &amp;hellip; } else { &amp;hellip; } // Chaves são opcionais para instruções de linha única if (condition) &amp;hellip; else if (condition) &amp;hellip; else &amp;hellip; switch (expressão) { case padrão: &amp;hellip; padrão: &amp;hellip; } doença ? expressão se verdadeira : expressão se falsa; Todas as expressões de ramificação permitem retornar expressões avaliadas.</description>
    </item>
    
  </channel>
</rss>
