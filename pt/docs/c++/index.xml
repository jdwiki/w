<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial C&#43;&#43; on </title>
    <link>https://www.wikiod.com/pt/docs/c&#43;&#43;/</link>
    <description>Recent content in Tutorial C&#43;&#43; on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com C&#43;&#43;</title>
      <link>https://www.wikiod.com/pt/c-/comecando-com-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/comecando-com-c-/</guid>
      <description>Olá Mundo # Este programa imprime Hello World! no fluxo de saída padrão:
#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; } Veja ao vivo no Coliru.
Análise # Vamos examinar cada parte deste código em detalhes:
#include &amp;lt;iostream&amp;gt; é uma diretiva de pré-processador que inclui o conteúdo do arquivo de cabeçalho C++ padrão iostream.
iostream is a standard library header file that contains definitions of the standard input and output streams.</description>
    </item>
    
    <item>
      <title>vetor padrão</title>
      <link>https://www.wikiod.com/pt/c-/vetor-padrao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/vetor-padrao/</guid>
      <description>Um vetor é um array dinâmico com armazenamento manipulado automaticamente. Os elementos em um vetor podem ser acessados ​​tão eficientemente quanto aqueles em uma matriz, com a vantagem de que os vetores podem mudar dinamicamente de tamanho.
Em termos de armazenamento, os dados vetoriais são (geralmente) colocados em memória alocada dinamicamente, exigindo, portanto, uma pequena sobrecarga; por outro lado, C-arrays e std::array usam armazenamento automático em relação ao local declarado e, portanto, não têm nenhuma sobrecarga.</description>
    </item>
    
    <item>
      <title>Retornando vários valores de uma função</title>
      <link>https://www.wikiod.com/pt/c-/retornando-varios-valores-de-uma-funcao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/retornando-varios-valores-de-uma-funcao/</guid>
      <description>Existem muitas situações em que é útil retornar vários valores de uma função: por exemplo, se você deseja inserir um item e retornar o preço e o número em estoque, essa funcionalidade pode ser útil. Há muitas maneiras de fazer isso em C++, e a maioria envolve o STL. No entanto, se você deseja evitar o STL por algum motivo, ainda existem várias maneiras de fazer isso, incluindo structs/classes e arrays.</description>
    </item>
    
    <item>
      <title>A regra de três, cinco e zero</title>
      <link>https://www.wikiod.com/pt/c-/a-regra-de-tres-cinco-e-zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/a-regra-de-tres-cinco-e-zero/</guid>
      <description>Regra do Zero # Podemos combinar os princípios da Regra dos Cinco e RAII para obter uma interface muito mais enxuta: a Regra do Zero: qualquer recurso que precise ser gerenciado deve ser do seu próprio tipo. Esse tipo teria que seguir a Regra dos Cinco, mas todos os usuários desse recurso não precisam escrever qualquer das cinco funções-membro especiais e podem simplesmente &amp;lsquo;padrão&amp;rsquo; todas elas.
Usando a classe Person introduzida no [exemplo da Regra de Três](https://www.</description>
    </item>
    
    <item>
      <title>Lambdas</title>
      <link>https://www.wikiod.com/pt/c-/lambdas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/lambdas/</guid>
      <description>Sintaxe # [default-capture, capture-list] (argument-list) mutável throw-specification attributes -&amp;gt; return-type { lambda-body } // Ordem dos especificadores lambda e atributos. [capture-list] (argument-list) { lambda-body } // Definição lambda comum. [=] (argument-list) { lambda-body } // Captura todas as variáveis ​​locais necessárias por valor. [&amp;amp;] (argument-list) { lambda-body } // Captura todas as variáveis ​​locais necessárias por referência. [capture-list] { lambda-body } // A lista de argumentos e os especificadores podem ser omitidos.</description>
    </item>
    
    <item>
      <title>Ponteiros inteligentes</title>
      <link>https://www.wikiod.com/pt/c-/ponteiros-inteligentes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/ponteiros-inteligentes/</guid>
      <description>Sintaxe # std::shared_ptr&amp;lt;ClassType&amp;gt; nome da variável = std::make_shared&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); std::shared_ptr&amp;lt;ClassType&amp;gt; variableName (new ClassType(arg1, arg2, ...)); std::unique_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_unique&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); // C++14 std::unique_ptr&amp;lt;ClassType&amp;gt; variableName (new ClassType(arg1, arg2, ...)); C++ não é uma linguagem gerenciada por memória. A memória alocada dinamicamente (ou seja, objetos criados com new) será &amp;ldquo;vazada&amp;rdquo; se não for explicitamente desalocada (com delete). É responsabilidade do programador garantir que a memória alocada dinamicamente seja liberada antes de descartar o último ponteiro para aquele objeto.</description>
    </item>
    
    <item>
      <title>stdstring</title>
      <link>https://www.wikiod.com/pt/c-/stdstring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/stdstring/</guid>
      <description>Strings são objetos que representam sequências de caracteres. A classe padrão string fornece uma alternativa simples, segura e versátil ao uso de arrays explícitos de chars ao lidar com texto e outras seqüências de caracteres. A classe C++ string faz parte do namespace std e foi padronizada em 1998.
Sintaxe # // Declaração de string vazia
std::string s;
// Construindo a partir de const char* (c-string)
std::string s(&amp;ldquo;Olá&amp;rdquo;);
std::string s = &amp;ldquo;Olá&amp;rdquo;;</description>
    </item>
    
    <item>
      <title>Modelos</title>
      <link>https://www.wikiod.com/pt/c-/modelos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/modelos/</guid>
      <description>Classes, funções e variáveis ​​(desde C++14) podem ser modeladas. Um modelo é um pedaço de código com alguns parâmetros livres que se tornarão uma classe, função ou variável concreta quando todos os parâmetros forem especificados. Os parâmetros podem ser tipos, valores ou modelos próprios. Um modelo bem conhecido é std::vector, que se torna um tipo de contêiner concreto quando o tipo de elemento é especificado, por exemplo, std::vector&amp;lt;int&amp;gt;.
Sintaxe # template &amp;lt; template-parameter-list &amp;gt; declaration export template &amp;lt; template-parameter-list &amp;gt; declaration /* até C++11 */ modelo &amp;lt;&amp;gt; declaração modelo declaração modelo externo declaração /* desde C++11 */ template &amp;lt; template-parameter-list &amp;gt; class &amp;hellip;(opt) identifier(opt) template &amp;lt; template-parameter-list &amp;gt; class identifier(opt) = id-expression template &amp;lt; template-parameter-list &amp;gt; typename &amp;hellip;(opt) identifier(opt) /* desde C++ 17 */ template &amp;lt; template-parameter-list &amp;gt; typename identifier(opt) = id-expression /* desde C++17 */ expressão pós-fixada .</description>
    </item>
    
    <item>
      <title>Metaprogramação</title>
      <link>https://www.wikiod.com/pt/c-/metaprogramacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/metaprogramacao/</guid>
      <description>Em C++, Metaprogramação refere-se ao uso de macros ou templates para gerar código em tempo de compilação.
Em geral, as macros são desaprovadas nessa função e os modelos são preferidos, embora não sejam tão genéricos.
A metaprogramação de templates frequentemente faz uso de computações em tempo de compilação, seja por meio de templates ou funções constexpr, para atingir seus objetivos de geração de código, porém computações em tempo de compilação não são metaprogramação per se.</description>
    </item>
    
    <item>
      <title>Rosqueamento</title>
      <link>https://www.wikiod.com/pt/c-/rosqueamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/c-/rosqueamento/</guid>
      <description>Sintaxe # fio() thread(thread&amp;amp;&amp;amp; outro) thread explícito (Function&amp;amp;&amp;amp; func, Args&amp;amp;&amp;amp;&amp;hellip; args) Parâmetros # | Parâmetro | Detalhes | | &amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | &amp;lsquo;outro&amp;rsquo; | Assume a propriedade de other, other não possui mais a thread | | função | Função para chamar em um thread separado | | args | Argumentos para func |
Algumas notas:
Dois objetos std::thread nunca podem representar a mesma thread. Um objeto std::thread pode estar em um estado onde não representa nenhuma thread (ou seja, após um movimento, após chamar join, etc.</description>
    </item>
    
  </channel>
</rss>
