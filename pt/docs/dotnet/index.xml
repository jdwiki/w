<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial do .NET Framework on </title>
    <link>https://www.wikiod.com/pt/docs/dotnet/</link>
    <description>Recent content in Tutorial do .NET Framework on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/dotnet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao .NET Framework</title>
      <link>https://www.wikiod.com/pt/dotnet/introducao-ao-net-framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/introducao-ao-net-framework/</guid>
      <description>Olá Mundo em C# # using System; class Program { // The Main() function is the first function to be executed in a program static void Main() { // Write the string &amp;quot;Hello World to the standard out Console.WriteLine(&amp;quot;Hello World&amp;quot;); } } Console.WriteLine tem várias sobrecargas. Neste caso, a string &amp;ldquo;Hello World&amp;rdquo; é o parâmetro, e irá gerar o &amp;ldquo;Hello World&amp;rdquo; para o fluxo de saída padrão durante a execução. Outras sobrecargas podem chamar o .</description>
    </item>
    
    <item>
      <title>LINQ</title>
      <link>https://www.wikiod.com/pt/dotnet/linq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/linq/</guid>
      <description>LINQ (Language Integrated Query) é uma expressão que recupera dados de uma fonte de dados. O LINQ simplifica essa situação oferecendo um modelo consistente para trabalhar com dados em vários tipos de fontes e formatos de dados. Em uma consulta LINQ, você está sempre trabalhando com objetos. Você usa os mesmos padrões básicos de codificação para consultar e transformar dados em documentos XML, bancos de dados SQL, conjuntos de dados ADO.</description>
    </item>
    
    <item>
      <title>Serialização JSON</title>
      <link>https://www.wikiod.com/pt/dotnet/serializacao-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/serializacao-json/</guid>
      <description>JavaScriptSerializer vs Json.NET
A classe JavaScriptSerializer foi introduzida no .NET 3.5 e é usado internamente pela camada de comunicação assíncrona do .NET para aplicativos habilitados para AJAX. Ele pode ser usado para trabalhar com JSON em código gerenciado.
Apesar da existência da classe JavaScriptSerializer, a Microsoft recomenda o uso da [biblioteca Json.NET] (http://www.newtonsoft.com/json) de código aberto para serialização e desserialização. O Json.NET oferece melhor desempenho e uma interface mais amigável para mapear JSON para classes personalizadas (um [objeto JavaScriptConverter personalizado](https://msdn.</description>
    </item>
    
    <item>
      <title>Biblioteca Paralela de Tarefas (TPL)</title>
      <link>https://www.wikiod.com/pt/dotnet/biblioteca-paralela-de-tarefas-tpl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/biblioteca-paralela-de-tarefas-tpl/</guid>
      <description>Finalidade e casos de uso # O objetivo da Biblioteca Paralela de Tarefas é simplificar o processo de escrever e manter código paralelo e multithread.
Alguns casos de uso*:
Mantendo uma interface do usuário responsiva executando o trabalho em segundo plano em uma tarefa separada Distribuir a carga de trabalho Permitir que um aplicativo cliente envie e receba solicitações ao mesmo tempo (rest, TCP/UDP, ect) Ler e/ou gravar vários arquivos de uma só vez *O código deve ser considerado caso a caso para multithreading.</description>
    </item>
    
    <item>
      <title>Exceções</title>
      <link>https://www.wikiod.com/pt/dotnet/excecoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/excecoes/</guid>
      <description>Relacionado:
MSDN: Exceções e Tratamento de Exceções (Guia de Programação C#) MSDN: Tratamento e lançamento de exceções MSDN: CA1031: Não detecte tipos de exceção gerais MSDN: try-catch (referência C#) Capturando e relançando exceções capturadas # Quando você deseja capturar uma exceção e fazer algo, mas não pode continuar a execução do bloco de código atual por causa da exceção, convém relançar a exceção para o próximo manipulador de exceção na pilha de chamadas.</description>
    </item>
    
    <item>
      <title>Análise de data e hora</title>
      <link>https://www.wikiod.com/pt/dotnet/analise-de-data-e-hora/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/analise-de-data-e-hora/</guid>
      <description>ParseExact # var dateString = &amp;quot;2015-11-24&amp;quot;; var date = DateTime.ParseExact(dateString, &amp;quot;yyyy-MM-dd&amp;quot;, null); Console.WriteLine(date); 24/11/2015 12:00:00
Observe que passar CultureInfo.CurrentCulture como o terceiro parâmetro é idêntico a passar null. Ou você pode passar uma cultura específica.
Formatar Strings
A string de entrada pode estar em qualquer formato que corresponda à string de formato
var date = DateTime.ParseExact(&amp;quot;24|201511&amp;quot;, &amp;quot;dd|yyyyMM&amp;quot;, null); Console.WriteLine(date); 24/11/2015 12:00:00
Quaisquer caracteres que não sejam especificadores de formato são tratados como literais</description>
    </item>
    
    <item>
      <title>Dicionários</title>
      <link>https://www.wikiod.com/pt/dotnet/dicionarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/dicionarios/</guid>
      <description>Inicializando um Dicionário com um Inicializador de Coleção # // Translates to `dict.Add(1, &amp;quot;First&amp;quot;)` etc. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { { 1, &amp;quot;First&amp;quot; }, { 2, &amp;quot;Second&amp;quot; }, { 3, &amp;quot;Third&amp;quot; } }; // Translates to `dict[1] = &amp;quot;First&amp;quot;` etc. // Works in C# 6.0. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { [1] = &amp;quot;First&amp;quot;, [2] = &amp;quot;Second&amp;quot;, [3] = &amp;quot;Third&amp;quot; }; Adicionando a um dicionário # Dictionary&amp;lt;int, string&amp;gt; dict = new Dictionary&amp;lt;int, string&amp;gt;(); dict.</description>
    </item>
    
    <item>
      <title>Injeção de dependência</title>
      <link>https://www.wikiod.com/pt/dotnet/injecao-de-dependencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/injecao-de-dependencia/</guid>
      <description>Problemas resolvidos por injeção de dependência
Se não usássemos injeção de dependência, a classe Greeter poderia se parecer mais com isso:
public class ControlFreakGreeter { public void Greet() { var greetingProvider = new SqlGreetingProvider( ConfigurationManager.ConnectionStrings[&amp;quot;myConnectionString&amp;quot;].ConnectionString); var greeting = greetingProvider.GetGreeting(); Console.WriteLine(greeting); } } É um &amp;ldquo;control freak&amp;rdquo; porque controla a criação da classe que fornece a saudação, controla de onde vem a string de conexão SQL e controla a saída.
Usando injeção de dependência, a classe Greeter renuncia a essas responsabilidades em favor de uma única responsabilidade, escrevendo uma saudação fornecida a ela.</description>
    </item>
    
    <item>
      <title>ADO.NET</title>
      <link>https://www.wikiod.com/pt/dotnet/adonet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/adonet/</guid>
      <description>ADO(ActiveX Data Objects).Net é uma ferramenta fornecida pela Microsoft que fornece acesso a fontes de dados como SQL Server, Oracle e XML através de seus componentes. Os aplicativos front-end .Net podem recuperar, criar e manipular dados, desde que estejam conectados a uma fonte de dados por meio do ADO.Net com os privilégios apropriados.
O ADO.Net fornece uma arquitetura sem conexão. É uma abordagem segura para interagir com um banco de dados, pois a conexão não precisa ser mantida durante toda a sessão.</description>
    </item>
    
    <item>
      <title>Clientes HTTP</title>
      <link>https://www.wikiod.com/pt/dotnet/clientes-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/dotnet/clientes-http/</guid>
      <description>Os RFCs HTTP/1.1 atualmente relevantes são:
7230: Sintaxe e roteamento da mensagem 7231: Semântica e Conteúdo 7232: solicitações condicionais 7233: Solicitações de intervalo 7234: Cache 7235: Autenticação 7239: Extensão HTTP encaminhada 7240: Preferir cabeçalho para HTTP Há também as seguintes RFCs informativas:
7236: Registros do esquema de autenticação 7237: Registros de métodos E o RFC experimental:
7238: O código de status do protocolo de transferência de hipertexto 308 (redirecionamento permanente) Protocolos relacionados:</description>
    </item>
    
  </channel>
</rss>
