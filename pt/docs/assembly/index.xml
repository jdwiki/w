<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de linguagem assembly on </title>
    <link>https://www.wikiod.com/pt/docs/assembly/</link>
    <description>Recent content in Tutorial de linguagem assembly on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução à linguagem assembly</title>
      <link>https://www.wikiod.com/pt/assembly/introducao-a-linguagem-assembly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/introducao-a-linguagem-assembly/</guid>
      <description>Introdução # A linguagem de montagem é uma forma legível por humanos de linguagem de máquina ou código de máquina que é a sequência real de bits e bytes na qual a lógica do processador opera. Geralmente é mais fácil para os humanos ler e programar em mnemônicos do que binário, octal ou hexadecimal, então os humanos normalmente escrevem código em linguagem assembly e depois usam um ou mais programas para convertê-lo no formato de linguagem de máquina entendido pelo processador.</description>
    </item>
    
    <item>
      <title>Registros</title>
      <link>https://www.wikiod.com/pt/assembly/registros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/registros/</guid>
      <description>O que são Registros?
O processador pode operar com valores numéricos (números), mas estes devem ser armazenados em algum lugar primeiro. Os dados são armazenados principalmente na memória, ou dentro do opcode da instrução (que é armazenado geralmente na memória também), ou em uma memória especial no chip colocada diretamente no processador, que é chamada de registro.
Para trabalhar com valor no registrador, você não precisa endereçá-lo por endereço, mas &amp;ldquo;nomes&amp;rdquo; mnemônicos especiais são usados, como por exemplo ax em x86, ou A em Z80, ou r0 em ARM.</description>
    </item>
    
    <item>
      <title>A pilha</title>
      <link>https://www.wikiod.com/pt/assembly/a-pilha/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/a-pilha/</guid>
      <description>A pilha de computadores é como uma pilha de livros. PUSH adiciona um ao topo e POP tira o mais alto. Como na vida real, a pilha não pode ser infinita, por isso tem tamanho máximo. A pilha pode ser usada para algoritmos de ordenação, para lidar com uma quantidade maior de dados ou para valores seguros de registradores durante outra operação.
Pilha Zilog Z80 # O registrador sp é usado como ponteiro de pilha, apontando para o último valor armazenado na pilha (&amp;ldquo;topo&amp;rdquo; da pilha).</description>
    </item>
    
    <item>
      <title>Exemplos do Linux elf64 que não usam glibc</title>
      <link>https://www.wikiod.com/pt/assembly/exemplos-do-linux-elf64-que-nao-usam-glibc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/exemplos-do-linux-elf64-que-nao-usam-glibc/</guid>
      <description>Interface de usuário # Arrisco dizer que 80% do processamento que ocorre nos sistemas computacionais modernos não requer interação do usuário, como o código do kernel para Linux, OSX e Windows. Para aqueles que o fazem, existem dois fundamentos que são a interatividade via teclado (dispositivos apontadores) e console. Este exemplo e outros da minha série são orientados para console baseado em texto (emulação VT100) e teclado.
Por si só, este exemplo é muito simples, mas é um bloco de construção essencial para algoritmos mais complexos.</description>
    </item>
    
    <item>
      <title>Controle de fluxo</title>
      <link>https://www.wikiod.com/pt/assembly/controle-de-fluxo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/controle-de-fluxo/</guid>
      <description>Todo software não trivial precisa de estruturas de controle de fluxo para desviar o fluxo do programa de acordo com as condições.
Assembly sendo a linguagem de programação de nível mais baixo fornece apenas primitivos para estruturas de controle. Normalmente, as operações da máquina afetam sinalizadores na CPU e ramificações/saltos condicionais implementam o controle de fluxo. Na montagem, todas as estruturas de controle de nível superior precisam ser construídas a partir dessas primitivas.</description>
    </item>
    
    <item>
      <title>Interrupções</title>
      <link>https://www.wikiod.com/pt/assembly/interrupcoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/assembly/interrupcoes/</guid>
      <description>Por que precisamos de interrupções
Vamos imaginar: Nosso computador está conectado a um teclado. Queremos inserir algo. Quando apertamos a tecla nada acontece porque o computador está lidando com coisas diferentes e não percebe que queremos algo dele. Precisamos de interrupções!
As interrupções são acionadas por software (INT 80h) ou hardware (pressionamento de tecla), elas se comportam como uma Call (eles saltam para um local específico, executam código e voltam novamente).</description>
    </item>
    
  </channel>
</rss>
