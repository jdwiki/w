<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Idioma Elixir on </title>
    <link>https://www.wikiod.com/pt/docs/elixir/</link>
    <description>Recent content in Tutorial de Idioma Elixir on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/elixir/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Elixir Language</title>
      <link>https://www.wikiod.com/pt/elixir/introducao-ao-elixir-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/introducao-ao-elixir-language/</guid>
      <description>Olá Mundo # Para instruções de instalação no elixir, verifique aqui, descreve as instruções relacionadas a diferentes plataformas.
Elixir é uma linguagem de programação que é criada usando erlang, e usa o runtime BEAM de erlang (como JVM para java).
Podemos usar o elixir em dois modos: shell interativo iex ou executando diretamente usando comando elixir.
Coloque o seguinte em um arquivo chamado hello.exs:
IO.puts &amp;quot;Hello world!&amp;quot; Na linha de comando, digite o seguinte comando para executar o arquivo de origem do Elixir:</description>
    </item>
    
    <item>
      <title>Dicas e truques do console IEx</title>
      <link>https://www.wikiod.com/pt/elixir/dicas-e-truques-do-console-iex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/dicas-e-truques-do-console-iex/</guid>
      <description>Obtenha o valor do último comando com v # iex(1)&amp;gt; 1 + 1 2 iex(2)&amp;gt; v 2 iex(3)&amp;gt; 1 + v 3 Veja também: https://www.wikiod.com/pt/elixir/dicas-e-truques-do-console-iex#Obtenha o valor de um comando anterior com v
Histórico persistente # Por padrão, o histórico de entrada do usuário no IEx não persiste em diferentes sessões.
erlang-history adiciona suporte de histórico ao shell Erlang e IEx:
git clone git@github.com:ferd/erlang-history.git cd erlang-history sudo make install Agora você pode acessar suas entradas anteriores usando as teclas de seta para cima e para baixo, mesmo em diferentes sessões IEx.</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/elixir/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/correspondencia-de-padroes/</guid>
      <description>Correspondência de padrões em uma lista # Você também pode combinar padrões em Estruturas de Dados Elixir, como Listas.
Listas
A correspondência em uma lista é bastante simples.
[head | tail] = [1,2,3,4,5] # head == 1 # tail == [2,3,4,5] Isso funciona combinando os primeiros (ou mais) elementos da lista com o lado esquerdo do | (pipe) e o resto da lista com a variável do lado direito do |.</description>
    </item>
    
    <item>
      <title>Funções</title>
      <link>https://www.wikiod.com/pt/elixir/funcoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/funcoes/</guid>
      <description>Funções anônimas # No Elixir, uma prática comum é usar funções anônimas. Criar uma função anônima é simples:
iex(1)&amp;gt; my_func = fn x -&amp;gt; x * 2 end #Function&amp;lt;6.52032458/1 in :erl_eval.expr/5&amp;gt; A sintaxe geral é:
fn args -&amp;gt; output end Para facilitar a leitura, você pode colocar parênteses nos argumentos:
iex(2)&amp;gt; my_func = fn (x, y) -&amp;gt; x*y end #Function&amp;lt;12.52032458/2 in :erl_eval.expr/5&amp;gt; Para invocar uma função anônima, chame-a pelo nome atribuído e adicione .</description>
    </item>
    
    <item>
      <title>Listas</title>
      <link>https://www.wikiod.com/pt/elixir/listas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/listas/</guid>
      <description>Sintaxe # [] [1, 2, 3, 4] [1, 2] ++ [3, 4] # -&amp;gt; [1,2,3,4] hd([1, 2, 3, 4]) # -&amp;gt; 1 tl([1, 2, 3, 4]) # -&amp;gt; [2,3,4] [cabeça | rabo] [1 | [2, 3, 4]] # -&amp;gt; [1,2,3,4] [1 | [2 | [3 | [4 | []]]]] -&amp;gt; [1,2,3,4] &amp;lsquo;olá&amp;rsquo; = [?h, ?e, ?l, ?l, ?o] lista_palavra-chave = [a: 123, b: 456, c: 789] keyword_list[:a] # -&amp;gt; 123 Listas de palavras-chave # As listas de palavras-chave são listas em que cada item na lista é uma tupla de um átomo seguido por um valor.</description>
    </item>
    
    <item>
      <title>.gitignore básico para o programa elixir</title>
      <link>https://www.wikiod.com/pt/elixir/gitignore-basico-para-o-programa-elixir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/gitignore-basico-para-o-programa-elixir/</guid>
      <description>Note que a pasta /rel pode não ser necessária em seu arquivo .gitignore. Isso é gerado se você estiver usando uma ferramenta de gerenciamento de versão como exrm
Exemplo # ### Elixir ### /_build /cover /deps erl_crash.dump *.ez ### Erlang ### .eunit deps *.beam *.plt ebin rel/example_project .concrete/DEV_MODE .rebar ## Phoenix application /_build /db /deps /*.ez erl_crash.dump /node_modules /priv/static/ /config/prod.secret.exs /rel ## Standalone elixir application /_build /cover /deps erl_crash.dump *.ez /rel ## Auto-generated .</description>
    </item>
    
    <item>
      <title>Operadores</title>
      <link>https://www.wikiod.com/pt/elixir/operadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/operadores/</guid>
      <description>O Operador de Tubulação # O Pipe Operator |&amp;gt; pega o resultado de uma expressão à esquerda e o alimenta como o primeiro parâmetro para uma função à direita.
expression |&amp;gt; function Use o Pipe Operator para encadear expressões e documentar visualmente o fluxo de uma série de funções.
Considere o seguinte:
Oven.bake(Ingredients.Mix([:flour, :cocoa, :sugar, :milk, :eggs, :butter]), :temperature) No exemplo, Oven.bake vem antes de Ingredients.mix, mas é executado por último.</description>
    </item>
    
    <item>
      <title>Nós</title>
      <link>https://www.wikiod.com/pt/elixir/nos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/nos/</guid>
      <description>Conectando nós na mesma máquina # Inicie dois nós nomeados em duas janelas de terminal:
&amp;gt;iex --name bob@127.0.0.1 iex(bob@127.0.0.1)&amp;gt; &amp;gt;iex --name frank@127.0.0.1 iex(frank@127.0.0.1)&amp;gt; Conecte dois nós instruindo um nó para se conectar:
iex(bob@127.0.0.1)&amp;gt; Node.connect :&amp;quot;frank@127.0.0.1&amp;quot; true Os dois nós estão agora conectados e cientes um do outro:
iex(bob@127.0.0.1)&amp;gt; Node.list [:&amp;quot;frank@127.0.0.1&amp;quot;] iex(frank@127.0.0.1)&amp;gt; Node.list [:&amp;quot;bob@127.0.0.1&amp;quot;] Você pode executar código em outros nós:
iex(bob@127.0.0.1)&amp;gt; greet = fn() -&amp;gt; IO.puts(&amp;quot;Hello from #{inspect(Node.self)}&amp;quot;) end iex(bob@127.0.0.1)&amp;gt; Node.</description>
    </item>
    
    <item>
      <title>Sigilos</title>
      <link>https://www.wikiod.com/pt/elixir/sigilos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/sigilos/</guid>
      <description>Sigilos personalizados # Sigilos personalizados podem ser feitos criando um método sigil_X onde X é a letra que você deseja usar (isso só pode ser uma única letra).
defmodule Sigils do def sigil_j(string, options) do # Split on the letter p, or do something more useful String.split string, &amp;quot;p&amp;quot; end # Use this sigil in this module, or import it to use it elsewhere end O argumento options é um binário dos argumentos fornecidos no final do sigilo, por exemplo:</description>
    </item>
    
    <item>
      <title>Tipos embutidos</title>
      <link>https://www.wikiod.com/pt/elixir/tipos-embutidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/elixir/tipos-embutidos/</guid>
      <description>Números # Elixir vem com números inteiros e números de ponto flutuante. Um literal inteiro pode ser escrito nos formatos decimal, binário, octal e hexadecimal.
iex&amp;gt; x = 291 291 iex&amp;gt; x = 0b100100011 291 iex&amp;gt; x = 0o443 291 iex&amp;gt; x = 0x123 291 Como o Elixir usa aritmética bignum, o intervalo de inteiros é limitado apenas pela memória disponível no sistema.
Números de ponto flutuante são de precisão dupla e seguem a especificação IEEE-754.</description>
    </item>
    
  </channel>
</rss>
