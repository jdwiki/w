<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial de algoritmo on </title>
    <link>https://www.wikiod.com/pt/docs/algorithm/</link>
    <description>Recent content in tutorial de algoritmo on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao algoritmo</title>
      <link>https://www.wikiod.com/pt/algorithm/introducao-ao-algoritmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/introducao-ao-algoritmo/</guid>
      <description>Um exemplo de problema algorítmico # Um problema algorítmico é especificado descrevendo o conjunto completo de instâncias nas quais ele deve trabalhar e de sua saída após a execução em uma dessas instâncias. Essa distinção, entre um problema e uma instância de um problema, é fundamental. O problem algorítmico conhecido como sorting é definido da seguinte forma: [Skiena:2008:ADM:1410219]
Problema: classificação Entrada: Uma sequência de n teclas, a_1, a_2, ..., a_n. Saída: A reordenação da sequência de entrada tal que a&#39;_1 &amp;lt;= a&#39;_2 &amp;lt;= .</description>
    </item>
    
    <item>
      <title>Complexidade do algoritmo</title>
      <link>https://www.wikiod.com/pt/algorithm/complexidade-do-algoritmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/complexidade-do-algoritmo/</guid>
      <description>Todos os algoritmos são uma lista de passos para resolver um problema. Cada etapa tem dependências de algum conjunto de etapas anteriores ou do início do algoritmo. Um pequeno problema pode ter a seguinte aparência:
Essa estrutura é chamada de gráfico acíclico direcionado, ou DAG, abreviado. Os links entre cada nó no gráfico representam dependências na ordem das operações e não há ciclos no gráfico.
Como as dependências acontecem? Tomemos por exemplo o seguinte código:</description>
    </item>
    
    <item>
      <title>Notação Big-O</title>
      <link>https://www.wikiod.com/pt/algorithm/notacao-big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/notacao-big-o/</guid>
      <description>Definição
A notação Big-O é, em sua essência, uma notação matemática, usada para comparar a taxa de convergência de funções. Sejam n -&amp;gt; f(n) e n -&amp;gt; g(n) funções definidas sobre os números naturais. Então dizemos que f = O(g) se e somente se f(n)/g(n) é limitado quando n se aproxima do infinito. Em outras palavras, f = O(g) se e somente se existe uma constante A, tal que para todo n, f(n)/g(n) &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>Gráfico</title>
      <link>https://www.wikiod.com/pt/algorithm/grafico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/grafico/</guid>
      <description>Um gráfico é uma coleção de pontos e linhas conectando algum subconjunto (possivelmente vazio) deles. Os pontos de um gráfico são chamados de vértices do gráfico, &amp;ldquo;nós&amp;rdquo; ou simplesmente &amp;ldquo;pontos&amp;rdquo;. Da mesma forma, as linhas que conectam os vértices de um grafo são chamadas de arestas do grafo, &amp;ldquo;arcos&amp;rdquo; ou &amp;ldquo;linhas&amp;rdquo;.
Um grafo G pode ser definido como um par (V,E), onde V é um conjunto de vértices e E é um conjunto de arestas entre os vértices E ⊆ {(u,v) | u, v ∈ V}.</description>
    </item>
    
    <item>
      <title>Árvores de pesquisa binária</title>
      <link>https://www.wikiod.com/pt/algorithm/arvores-de-pesquisa-binaria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/arvores-de-pesquisa-binaria/</guid>
      <description>Árvore binária é uma árvore em que cada nó tem no máximo dois filhos. A árvore de busca binária (BST) é uma árvore binária cujos elementos são posicionados em uma ordem especial. Em cada BST, todos os valores (ou seja, chave) na subárvore esquerda são menores que os valores na subárvore direita.
Árvore de pesquisa binária - Inserção (Python) # Esta é uma implementação simples de Inserção de Árvore de Pesquisa Binária usando Python.</description>
    </item>
    
    <item>
      <title>Algoritmo de Dijkstra</title>
      <link>https://www.wikiod.com/pt/algorithm/algoritmo-de-dijkstra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/algoritmo-de-dijkstra/</guid>
      <description>Algoritmo de caminho mais curto de Dijkstra # Antes de prosseguir, é recomendável ter uma breve ideia sobre Matriz de Adjacência e BFS
Algoritmo de Dijkstra é conhecido como algoritmo de caminho mais curto de fonte única. Ele é usado para encontrar os caminhos mais curtos entre nós em um grafo, que pode representar, por exemplo, redes rodoviárias. Foi concebido por Edsger W. Dijkstra em 1956 e publicado três anos depois.</description>
    </item>
    
    <item>
      <title>Mesclar classificação</title>
      <link>https://www.wikiod.com/pt/algorithm/mesclar-classificacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/mesclar-classificacao/</guid>
      <description>Fundamentos de classificação de mesclagem # Merge Sort é um algoritmo de divisão e conquista. Ele divide a lista de entrada de comprimento n pela metade sucessivamente até que haja n listas de tamanho 1. Em seguida, os pares de listas são mesclados com o primeiro elemento menor entre o par de listas sendo adicionado em cada etapa. Através da fusão sucessiva e da comparação dos primeiros elementos, a lista ordenada é construída.</description>
    </item>
    
    <item>
      <title>Distorção Dinâmica do Tempo</title>
      <link>https://www.wikiod.com/pt/algorithm/distorcao-dinamica-do-tempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/distorcao-dinamica-do-tempo/</guid>
      <description>Introdução à distorção dinâmica do tempo # Dynamic Time Warping(DTW) é um algoritmo para medir a semelhança entre duas sequências temporais que podem variar em velocidade. Por exemplo, semelhanças na caminhada podem ser detectadas usando DTW, mesmo se uma pessoa estiver andando mais rápido que a outra, ou se houver acelerações e desacelerações durante o curso de uma observação. Ele pode ser usado para combinar um comando de voz de amostra com outro comando, mesmo se a pessoa falar mais rápido ou mais devagar do que a voz de amostra pré-gravada.</description>
    </item>
    
    <item>
      <title>Algoritmo de Bellman-Ford</title>
      <link>https://www.wikiod.com/pt/algorithm/algoritmo-de-bellman-ford/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/algoritmo-de-bellman-ford/</guid>
      <description>Dado um grafo direcionado G, muitas vezes queremos encontrar a distância mais curta de um dado nó A para o resto dos nós no grafo. O algoritmo Dijkstra é o algoritmo mais famoso para encontrar o caminho mais curto, mas funciona apenas se os pesos das arestas do grafo fornecido forem não negativos. Bellman-Ford, no entanto, visa encontrar o caminho mais curto de um determinado nó (se houver), mesmo que alguns dos pesos sejam negativos.</description>
    </item>
    
    <item>
      <title>Pesquisa de Substring</title>
      <link>https://www.wikiod.com/pt/algorithm/pesquisa-de-substring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/algorithm/pesquisa-de-substring/</guid>
      <description>Introdução ao algoritmo Knuth-Morris-Pratt (KMP) # Suponha que temos um texto e um padrão. Precisamos determinar se o padrão existe no texto ou não. Por exemplo:
+-------+---+---+---+---+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | +-------+---+---+---+---+---+---+---+---+ | Text | a | b | c | b | c | g | l | x | +-------+---+---+---+---+---+---+---+---+ +---------+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | +---------+---+---+---+---+ | Pattern | b | c | g | l | +---------+---+---+---+---+ Este padrão existe no texto.</description>
    </item>
    
  </channel>
</rss>
