<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rx-java tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/rx-java/</link>
    <description>Recent content in rx-java tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/rx-java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao rx-java</title>
      <link>https://www.wikiod.com/pt/rx-java/introducao-ao-rx-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/introducao-ao-rx-java/</guid>
      <description>Uma introdução ao RxJava # Os conceitos centrais do RxJava são seus Observables e Subscribers. Um Observable emite objetos, enquanto um Subscriber os consome.
Observável
Observable é uma classe que implementa o padrão de design reativo. Esses Observables fornecem métodos que permitem que os consumidores se inscrevam nas alterações de eventos. As mudanças de eventos são acionadas pelo observável. Não há restrição ao número de assinantes que um Observable pode ter, ou ao número de objetos que um Observable pode emitir.</description>
    </item>
    
    <item>
      <title>Contrapressão</title>
      <link>https://www.wikiod.com/pt/rx-java/contrapressao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/contrapressao/</guid>
      <description>Introdução # Backpressure é quando em um pipeline de processamento Observable, alguns estágios assíncronos não podem processar os valores com rapidez suficiente e precisam de uma maneira de dizer ao produtor upstream para diminuir a velocidade.
O caso clássico da necessidade de contrapressão é quando o produtor é uma fonte quente:
PublishSubject&amp;lt;Integer&amp;gt; source = PublishSubject.create(); source .observeOn(Schedulers.computation()) .subscribe(v -&amp;gt; compute(v), Throwable::printStackTrace); for (int i = 0; i &amp;lt; 1_000_000; i++) { source.</description>
    </item>
    
    <item>
      <title>Teste de unidade</title>
      <link>https://www.wikiod.com/pt/rx-java/teste-de-unidade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/teste-de-unidade/</guid>
      <description>Como todos os métodos dos Schedulers são estáticos, os testes de unidade que utilizam os ganchos RxJava não podem ser executados em paralelo na mesma instância da JVM. Se eles onde, um TestScheduler seria removido no meio de um teste de unidade. Essa é basicamente a desvantagem de usar a classe Schedulers.
Agendador de Testes # TestSchedulers permite que você controle o tempo e a execução de Observables em vez de ter que fazer esperas ocupadas, unir threads ou qualquer coisa para manipular o tempo do sistema.</description>
    </item>
    
    <item>
      <title>Android com RxJava</title>
      <link>https://www.wikiod.com/pt/rx-java/android-com-rxjava/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/android-com-rxjava/</guid>
      <description>O RxAndroid costumava ser uma biblioteca com muitos recursos. Ele foi dividido em muitas bibliotecas diferentes, passando da versão 0.25.0 para 1.x.
Uma lista de bibliotecas que implementam os recursos disponíveis antes do 1.0 é mantida aqui.
RxAndroid - Agendadores Android # Esta é literalmente a única coisa que você precisa para começar a usar o RxJava no Android.
Inclua RxJava e RxAndroid em suas dependências do gradle:
// use the last version compile &#39;io.</description>
    </item>
    
    <item>
      <title>RxJava2 Flowable e Assinante</title>
      <link>https://www.wikiod.com/pt/rx-java/rxjava2-flowable-e-assinante/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/rxjava2-flowable-e-assinante/</guid>
      <description>Este tópico mostra exemplos e documentação com relação aos conceitos reativos de Flowable e Subscriber que foram introduzidos no rxjava versão2
o exemplo precisa do rxjava2 como dependência, as coordenadas do maven para a versão usada são:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.reactivex.rxjava2&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;rxjava&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.8&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; exemplo de consumidor produtor com suporte de contrapressão no produtor # O TestProducer deste exemplo produz objetos Integer em um determinado intervalo e os envia para seu Subscriber. Ele estende a classe Flowable&amp;lt;Integer&amp;gt;.</description>
    </item>
    
    <item>
      <title>Observável</title>
      <link>https://www.wikiod.com/pt/rx-java/observavel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/observavel/</guid>
      <description>Crie um observável # Existem várias maneiras de criar um Observable em RxJava. A maneira mais poderosa é usar o método Observable.create. Mas também é a forma mais complicada. Então você deve evitar usá-lo, tanto quanto possível.
Emitindo um valor de saída # Se você já tem um valor, você pode usar Observable.just para emitir seu valor.
Observable.just(&amp;quot;Hello World&amp;quot;).subscribe(System.out::println); Emitindo um valor que deve ser computado # Se você quiser emitir um valor que ainda não foi calculado, ou que pode demorar muito para ser calculado, você pode usar Observable.</description>
    </item>
    
    <item>
      <title>assuntos</title>
      <link>https://www.wikiod.com/pt/rx-java/assuntos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/assuntos/</guid>
      <description>Sintaxe # Assunto&amp;lt;T, R&amp;gt; assunto = AsyncSubject.create(); // Padrão AsyncSubject Assunto&amp;lt;T, R&amp;gt; assunto = BehaviorSubject.create(); // Default BehaviorSubject Assunto&amp;lt;T, R&amp;gt; assunto = PublishSubject.create(); // PublishSubject padrão Assunto&amp;lt;T, R&amp;gt; assunto = ReplaySubject.create(); // Padrão ReplaySubject mySafeSubject = new SerializedSubject(unSafeSubject); // Converte um unsafeSubject em um safeSubject - geralmente para assuntos multi-thread Parâmetros # Parâmetros Detalhes T Tipo de entrada R Tipo de saída Esta documentação fornece detalhes e explicações sobre o Assunto.</description>
    </item>
    
    <item>
      <title>Operadores</title>
      <link>https://www.wikiod.com/pt/rx-java/operadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/operadores/</guid>
      <description>Este documento descreve o comportamento básico de um operador.
Operadores, uma introdução # Um operador pode ser usado para manipular o fluxo de objetos de Observable para Subscriber.
Observable&amp;lt;Integer&amp;gt; integerObservable = Observable.just(1, 2, 3); // creating a simple Integer observable Subscriber&amp;lt;String&amp;gt; mSubscriber = new Subscriber&amp;lt;String&amp;gt;() { @Override public void onCompleted() { System.out.println(&amp;quot;onCompleted called!&amp;quot;); } @Override public void onError(Throwable throwable) { System.out.println(&amp;quot;onError called&amp;quot;); } @Override public void onNext(String string) { System.out.println(&amp;quot;onNext called with: &amp;quot; + string); } }; // a simple String subscriber integerObservable .</description>
    </item>
    
    <item>
      <title>Agendadores</title>
      <link>https://www.wikiod.com/pt/rx-java/agendadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/agendadores/</guid>
      <description>Exemplos básicos # Agendadores são uma abstração RxJava sobre unidade de processamento. Um agendador pode ser apoiado por um serviço Executor, mas você pode implementar sua própria implementação do agendador.
Um Scheduler deve atender a este requisito:
Deve processar a tarefa sem atraso sequencialmente (ordem FIFO) A tarefa pode ser atrasada Um Scheduler pode ser usado como parâmetro em alguns operadores (exemplo: delay), ou usado com o método subscribeOn / observeOn.</description>
    </item>
    
    <item>
      <title>Retrofit e RxJava</title>
      <link>https://www.wikiod.com/pt/rx-java/retrofit-e-rxjava/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/rx-java/retrofit-e-rxjava/</guid>
      <description>Configurar Retrofit e RxJava # Retrofit2 vem com suporte para vários mecanismos de execução plugáveis, um deles é o RxJava.
Para usar o retrofit com RxJava, primeiro você precisa adicionar o adaptador Retrofit RxJava ao seu projeto:
compile &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39; então você precisa adicionar o adaptador ao construir sua instância de retrofit:
Retrofit retrofit = new Retrofit.Builder() .baseUrl(&amp;quot;https://api.example.com&amp;quot;) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .build(); Na sua interface quando você define a API o tipo de retorno deve ser Observable ex:</description>
    </item>
    
  </channel>
</rss>
