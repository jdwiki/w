<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de F# on </title>
    <link>https://www.wikiod.com/pt/docs/fsharp/</link>
    <description>Recent content in Tutorial de F# on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/fsharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com F#</title>
      <link>https://www.wikiod.com/pt/fsharp/comecando-com-f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/comecando-com-f/</guid>
      <description>Olá Mundo! # Este é o código para um projeto de console simples, que imprime &amp;ldquo;Hello, World!&amp;rdquo; para STDOUT e sai com um código de saída 0
[&amp;lt;EntryPoint&amp;gt;] let main argv = printfn &amp;quot;Hello, World!&amp;quot; 0 Exemplo de detalhamento linha por linha:
[&amp;lt;EntryPoint&amp;gt;] - Um .net Attribute que marca &amp;ldquo;o método que você usa para definir o ponto de entrada&amp;rdquo; do seu programa (source). let main argv - define uma função chamada main com um único parâmetro argv.</description>
    </item>
    
    <item>
      <title>Sindicatos Discriminados</title>
      <link>https://www.wikiod.com/pt/fsharp/sindicatos-discriminados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/sindicatos-discriminados/</guid>
      <description>Nomeando elementos de tuplas dentro de uniões discriminadas # Ao definir uniões discriminadas, você pode nomear elementos de tipos de tupla e usar esses nomes durante a correspondência de padrões.
type Shape = | Circle of diameter:int | Rectangle of width:int * height:int let shapeIsTenWide = function | Circle(diameter=10) | Rectangle(width=10) -&amp;gt; true | _ -&amp;gt; false Além disso, nomear os elementos de uniões discriminadas melhora a legibilidade do código e a interoperabilidade com C# - os nomes fornecidos serão usados ​​para nomes de propriedades e parâmetros de construtores.</description>
    </item>
    
    <item>
      <title>Padrões ativos</title>
      <link>https://www.wikiod.com/pt/fsharp/padroes-ativos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/padroes-ativos/</guid>
      <description>Padrões ativos simples # Padrões ativos são um tipo especial de correspondência de padrões onde você pode especificar categorias nomeadas nas quais seus dados podem se encaixar e, em seguida, usar essas categorias em instruções match.
Para definir um padrão ativo que classifica os números como positivos, negativos ou zero:
let (|Positive|Negative|Zero|) num = if num &amp;gt; 0 then Positive elif num &amp;lt; 0 then Negative else Zero Isso pode ser usado em uma expressão de correspondência de padrões:</description>
    </item>
    
    <item>
      <title>Dicas e truques de desempenho em F#</title>
      <link>https://www.wikiod.com/pt/fsharp/dicas-e-truques-de-desempenho-em-f/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/dicas-e-truques-de-desempenho-em-f/</guid>
      <description>Meça e verifique suas suposições de desempenho # Este exemplo foi escrito com F# em mente, mas as idéias são aplicáveis ​​em todos ambientes
A primeira regra ao otimizar o desempenho é não confiar em suposições; Sempre Meça e Verifique suas suposições.
Como não estamos escrevendo código de máquina diretamente, é difícil prever como o compilador e JIT:er transformar seu programa em código de máquina. É por isso que precisamos medir o tempo de execução para ver que obtemos a melhoria de desempenho que esperamos e Verifique se o programa real não contém nenhuma sobrecarga oculta.</description>
    </item>
    
    <item>
      <title>Mônadas</title>
      <link>https://www.wikiod.com/pt/fsharp/monadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/monadas/</guid>
      <description>Entender as Mônadas vem da prática # Este tópico é destinado a desenvolvedores de F# intermediários a avançados
&amp;ldquo;O que são Mônadas?&amp;rdquo; é uma pergunta comum. Isso é fácil de responder, mas como em [Guia do Mochileiro da Galáxia](https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life.2C_the_Universe. 2C_and_Everything_.2842.29) percebemos que não entendemos a resposta porque não sabíamos o que estávamos perguntando.
Muitos acreditam que a maneira de entender as Mônadas é praticando-as. Como programadores, normalmente não nos importamos com a base matemática do Princípio de Substituição de Liskov, subtipos ou subclasses.</description>
    </item>
    
    <item>
      <title>Memorização</title>
      <link>https://www.wikiod.com/pt/fsharp/memorizacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/memorizacao/</guid>
      <description>Memorização simples # A memoização consiste em armazenar em cache os resultados da função para evitar computar o mesmo resultado várias vezes. Isso é útil ao trabalhar com funções que realizam cálculos caros.
Podemos usar uma função fatorial simples como exemplo:
let factorial index = let rec innerLoop i acc = match i with | 0 | 1 -&amp;gt; acc | _ -&amp;gt; innerLoop (i - 1) (acc * i) innerLoop index 1 Chamar essa função várias vezes com o mesmo parâmetro resulta na mesma computação repetidas vezes.</description>
    </item>
    
    <item>
      <title>O tipo de unidade</title>
      <link>https://www.wikiod.com/pt/fsharp/o-tipo-de-unidade/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/o-tipo-de-unidade/</guid>
      <description>De que serve uma tupla 0? # Uma tupla de 2 ou 3 tuplas representa um grupo de itens relacionados. (Pontos no espaço 2D, valores RGB de uma cor, etc.) Uma tupla 1 não é muito útil, pois pode ser facilmente substituída por um único int.
Uma tupla 0 parece ainda mais inútil, pois não contém absolutamente nada. No entanto, possui propriedades que o tornam muito útil em linguagens funcionais como F#.</description>
    </item>
    
    <item>
      <title>Funções</title>
      <link>https://www.wikiod.com/pt/fsharp/funcoes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/funcoes/</guid>
      <description>Tubulação para frente e para trás # Os operadores de pipe são usados ​​para passar parâmetros para uma função de maneira simples e elegante. Permite eliminar valores intermediários e facilitar a leitura das chamadas de função.
Em F#, existem dois operadores de pipe:
Forward (|&amp;gt;): Passando parâmetros da esquerda para a direita
let print message = printf &amp;quot;%s&amp;quot; message // &amp;quot;Hello World&amp;quot; will be passed as a parameter to the print function &amp;quot;Hello World&amp;quot; |&amp;gt; print Backward (&amp;lt;|): Passando parâmetros da direita para a esquerda</description>
    </item>
    
    <item>
      <title>1 F# Código WPF por trás do aplicativo com FsXaml</title>
      <link>https://www.wikiod.com/pt/fsharp/1-f-codigo-wpf-por-tras-do-aplicativo-com-fsxaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/1-f-codigo-wpf-por-tras-do-aplicativo-com-fsxaml/</guid>
      <description>A maioria dos exemplos encontrados para programação em F# WPF parece lidar com o padrão MVVM e alguns com MVC, mas não há quase nenhum que mostre corretamente como começar a funcionar com o código &amp;ldquo;bom e velho&amp;rdquo; por trás.
O padrão de código por trás é muito fácil de usar para ensino e experimentação. É usado em vários livros de introdução e material de aprendizagem na web. É por isso.</description>
    </item>
    
    <item>
      <title>Correspondência de padrões</title>
      <link>https://www.wikiod.com/pt/fsharp/correspondencia-de-padroes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/fsharp/correspondencia-de-padroes/</guid>
      <description>A correspondência de padrões é um recurso poderoso de muitas linguagens funcionais, pois geralmente permite que a ramificação seja tratada de forma muito sucinta em comparação com o uso de várias instruções de estilo if/else if/else. No entanto, com opções suficientes e &amp;ldquo;quando&amp;rdquo; guardas, a correspondência de padrões também pode se tornar detalhada e difícil de entender de relance.
Quando isso acontece, os Padrões Ativos do F# podem ser uma ótima maneira de dar nomes significativos à lógica de correspondência, o que simplifica o código e também permite a reutilização.</description>
    </item>
    
  </channel>
</rss>
