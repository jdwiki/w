<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial opencv on </title>
    <link>https://www.wikiod.com/pt/docs/opencv/</link>
    <description>Recent content in Tutorial opencv on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/opencv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com o opencv</title>
      <link>https://www.wikiod.com/pt/opencv/comecando-com-o-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/comecando-com-o-opencv/</guid>
      <description>Carregar e exibir uma imagem com OpenCV # Com este exemplo, veremos como carregar uma imagem colorida do disco e exibi-la usando as funções internas do OpenCV. Podemos usar as ligações C/C++, Python ou Java para fazer isso.
Em C++:
#include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace cv; int main(int argc, char** argv) { // We&#39;ll start by loading an image from the drive Mat image = imread(&amp;quot;image.jpg&amp;quot;, CV_LOAD_IMAGE_COLOR); // We check that our image has been correctly loaded if(image.</description>
    </item>
    
    <item>
      <title>Contraste e brilho em C&#43;&#43;</title>
      <link>https://www.wikiod.com/pt/opencv/contraste-e-brilho-em-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/contraste-e-brilho-em-c-/</guid>
      <description>Sintaxe # void cv::Mat::convertTo(OutputArray m, int rtype,double alpha = 1,double beta = 0)const Parâmetros # Parâmetro Detalhes m matriz de saída; se não tiver tamanho ou tipo adequado antes da operação, é realocado rtype tipo de matriz de saída desejada, ou melhor, a profundidade, já que o número de canais é o mesmo que a entrada possui; se rtype for negativo, a matriz de saída terá o mesmo tipo que a entrada alfa fator de escala opcional.</description>
    </item>
    
    <item>
      <title>Acesso a pixels</title>
      <link>https://www.wikiod.com/pt/opencv/acesso-a-pixels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/acesso-a-pixels/</guid>
      <description>Tenha cuidado para estar ciente do tipo de cv::Mat com o qual você está lidando. Por exemplo, se você tiver um cv::Mat do tipo CV_8UC3, mas acessá-lo com image.at&amp;lt;uchar&amp;gt;(r,c) nenhum erro ocorrerá, mas seu programa terá algum comportamento inesperado.
Acesso eficiente de pixel usando o ponteiro cv::Mat::ptr # Se a eficiência for importante, uma maneira rápida de iterar sobre pixels em um objeto cv::Mat é usar seu método ptr&amp;lt;T&amp;gt;(int r) para obter um ponteiro para o início da linha r (0 índice baseado).</description>
    </item>
    
    <item>
      <title>Detecção de borda</title>
      <link>https://www.wikiod.com/pt/opencv/deteccao-de-borda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/deteccao-de-borda/</guid>
      <description>Sintaxe # bordas = cv2.Canny(imagem, limiar1, limiar2[, bordas[, tamanho da abertura[, gradiente L2]]]) void Canny(InputArray image, OutputArray Edges, double threshold1, double threshold2, int AberturaSize=3, bool L2gradient=false Parâmetros # Parâmetro Detalhes imagem Inserir imagem arestas Imagem de saída threshold1 Primeiro limite para procedimento de histerese limiar2 Segundo limite para procedimento de histerese apertureSize Tamanho da abertura para o operador Sobel L2gradient Sinalizador indicando se um algoritmo mais preciso para gradiente de imagem deve ser usado Algoritmo inteligente # O algoritmo de Canny é um detector de borda mais recente projetado como um problema de processamento de sinal.</description>
    </item>
    
    <item>
      <title>Processamento de imagem</title>
      <link>https://www.wikiod.com/pt/opencv/processamento-de-imagem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/processamento-de-imagem/</guid>
      <description>Sintaxe # Gaussian Blur Syntax C++: void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT ) Parâmetros # Parâmetros do Desfoque Gaussiano Detalhes src Imagem de entrada, a imagem pode ter qualquer número de canais, que são processados ​​independentemente, mas a profundidade deve ser CV_8U, CV_16U, CV_16S, CV_32F ou CV_64F. dst Imagem de saída do mesmo tamanho e tipo que src ksize Tamanho do kernel gaussiano. ksize.</description>
    </item>
    
    <item>
      <title>Desenhando Formas (Linha, Círculo, ..., etc) em C&#43;&#43;</title>
      <link>https://www.wikiod.com/pt/opencv/desenhando-formas-linha-circulo--etc-em-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/desenhando-formas-linha-circulo--etc-em-c-/</guid>
      <description>No OpenCV, pode-se desenhar inúmeras formas como ponto, linha, círculo, &amp;hellip;, etc. Existe um opcional para preencher uma forma. O código a seguir é autoexplicativo e mostra como as formas são desenhadas.
Amostra de Formas de Desenho # #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; // drawing shapes #include &amp;lt;iostream&amp;gt; int main( int argc, char** argv ) { // First create a black image. cv::Mat image(500,500, CV_8UC3, cv::Scalar(0,0,0)); // Check if the image is created successfully.</description>
    </item>
    
    <item>
      <title>Criando um vídeo</title>
      <link>https://www.wikiod.com/pt/opencv/criando-um-video/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/criando-um-video/</guid>
      <description>Sempre que você trabalha com feeds de vídeo, pode eventualmente querer salvar o resultado do processamento da imagem na forma de um novo arquivo de vídeo. Para saídas de vídeo simples, você pode usar a classe VideoWriter integrada do OpenCV, projetada para isso. É útil examinar alguns conceitos antes de usá-los. Esses conceitos são codec ou seja, decodificador e FourCC (Código de quatro caracteres).
Criando um vídeo com OpenCV (Java) # VideoWriter videoWriter; videoWriter = new VideoWriter(outputFile, VideoWriter.</description>
    </item>
    
    <item>
      <title>Classificadores em cascata</title>
      <link>https://www.wikiod.com/pt/opencv/classificadores-em-cascata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/classificadores-em-cascata/</guid>
      <description>Usando classificadores em cascata para detectar rosto # Pitão # Código # import numpy as np import cv2 #loading haarcascade classifiers for face and eye #You can find these cascade classifiers here #https://github.com/opencv/opencv/tree/master/data/haarcascades #or where you download opencv inside data/haarcascades face_cascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_default.xml&#39;) eye_cascade = cv2.CascadeClassifier(&#39;haarcascade_eye.xml&#39;) #loading the image img = cv2.imread(&#39;civil_war.jpg&#39;) #converting the image to gray scale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #detecting face in the grayscale image faces = face_cascade.</description>
    </item>
    
    <item>
      <title>Exibir imagem OpenCV</title>
      <link>https://www.wikiod.com/pt/opencv/exibir-imagem-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/exibir-imagem-opencv/</guid>
      <description>Leitura básica e exibição de uma imagem # import cv2 image_path= #put your image path here #use imread() function to read image data to variable img. img = cv2.imread(image_path) #display image data in a new window with title &#39;I am an image display window&#39; cv2.imshow(&#39;I am an image display window&#39;,img) #wait until user hits any key on keyboard cv2.waitKey(0) #close any windows opened by opencv cv2.destroyAllWindows() Para controlar o tamanho da janela de exibição na tela, adicione os seguintes comandos antes do comando cv2.</description>
    </item>
    
    <item>
      <title>Usando classificadores em cascata em Java</title>
      <link>https://www.wikiod.com/pt/opencv/usando-classificadores-em-cascata-em-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opencv/usando-classificadores-em-cascata-em-java/</guid>
      <description>Sintaxe # CascadeClassifier cascade = new CascadeClassifier(&amp;ldquo;cascade.xml&amp;rdquo;); // Cria um classificador em cascata a partir de cascade.xml Mat image = Imgcodecs.imread(&amp;ldquo;image.png&amp;rdquo;); // Converte image.png em um objeto Mat (Matrix) Detecções de MatOfRect = new MatOfRect(); // Cria um arquivo MatOfRect (Matriz de Retângulos) vazio, usado como saída para nossas classes de detecção detects.toArray(); // Retorna um array de objetos Rect que podem ser iterados Imgproc.rectangle(imagem, new Point(rect.x, rect.y), new Point(rect.x + rect.</description>
    </item>
    
  </channel>
</rss>
