<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de linguagem Haskell on </title>
    <link>https://www.wikiod.com/pt/docs/haskell/</link>
    <description>Recent content in Tutorial de linguagem Haskell on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/haskell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução à linguagem Haskell</title>
      <link>https://www.wikiod.com/pt/haskell/introducao-a-linguagem-haskell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/introducao-a-linguagem-haskell/</guid>
      <description>Olá Mundo! # Um básico &amp;ldquo;Olá, Mundo!&amp;rdquo; program em Haskell pode ser expresso de forma concisa em apenas uma ou duas linhas:
main :: IO () main = putStrLn &amp;quot;Hello, World!&amp;quot; A primeira linha é uma anotação de tipo opcional, indicando que main é um valor do tipo IO(), representando uma ação de E/S que &amp;ldquo;computa&amp;rdquo; um valor do tipo () (leia &amp;ldquo;unit&amp;rdquo;; o tupla vazia sem informação) além de realizar alguns efeitos colaterais no mundo exterior (aqui, imprimindo uma string no terminal).</description>
    </item>
    
    <item>
      <title>Lente</title>
      <link>https://www.wikiod.com/pt/haskell/lente/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/lente/</guid>
      <description>Lens é uma biblioteca para Haskell que fornece lentes, isomorfismos, dobras, travessias, getters e setters, que expõe uma interface uniforme para consultar e manipular estruturas arbitrárias, não muito diferente dos conceitos de acessador e modificador de Java.
O que é uma lente? # Lentes (e outras óticas) nos permitem separar a descrição de como queremos acessar alguns dados de o que queremos fazer com eles. É importante distinguir entre a noção abstrata de uma lente e a implementação concreta.</description>
    </item>
    
    <item>
      <title>Extensões de linguagem comuns do GHC</title>
      <link>https://www.wikiod.com/pt/haskell/extensoes-de-linguagem-comuns-do-ghc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/extensoes-de-linguagem-comuns-do-ghc/</guid>
      <description>Essas extensões de linguagem geralmente estão disponíveis ao usar o Glasgow Haskell Compiler (GHC), pois não fazem parte do Haskell 2010 language Report aprovado. Para usar essas extensões, deve-se informar ao compilador usando um flag ou colocar um programa LANGUAGE antes da palavra-chave module em um arquivo. A documentação oficial pode ser encontrada na seção 7 do guia do usuário GCH.
O formato do programa LANGUAGE é {-# LANGUAGE ExtensionOne, ExtensionTwo .</description>
    </item>
    
    <item>
      <title>Mônadas Grátis</title>
      <link>https://www.wikiod.com/pt/haskell/monadas-gratis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/monadas-gratis/</guid>
      <description>Mônadas grátis dividem cálculos monádicos em estruturas de dados e interpretadores # Por exemplo, uma computação envolvendo comandos para ler e escrever no prompt:
Primeiro, descrevemos os &amp;ldquo;comandos&amp;rdquo; de nossa computação como um tipo de dados Functor
{-# LANGUAGE DeriveFunctor #-} data TeletypeF next = PrintLine String next | ReadLine (String -&amp;gt; next) deriving Functor Então usamos Free para criar a &amp;ldquo;Free Monad over TeletypeF&amp;rdquo; e construir algumas operações básicas.</description>
    </item>
    
    <item>
      <title>IO</title>
      <link>https://www.wikiod.com/pt/haskell/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/io/</guid>
      <description>Tirando o &amp;lsquo;a&amp;rsquo; &amp;ldquo;de&amp;rdquo; &amp;lsquo;IO a&amp;rsquo; # Uma pergunta comum é &amp;ldquo;Eu tenho um valor de &amp;lsquo;IO a&amp;rsquo;, mas quero fazer algo com esse valor de &amp;lsquo;a&amp;rsquo;: como faço para ter acesso a ele?&amp;rdquo; Como se pode operar com dados que vêm do mundo exterior (por exemplo, incrementando um número digitado pelo usuário)?
O ponto é que, se você usar uma função pura em dados obtidos de forma impura, o resultado ainda será impuro.</description>
    </item>
    
    <item>
      <title>Mônadas</title>
      <link>https://www.wikiod.com/pt/haskell/monadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/monadas/</guid>
      <description>Uma mônada é um tipo de dados de ações que podem ser compostas. Monad é a classe de construtores de tipo cujos valores representam tais ações. Talvez IO seja o mais reconhecível: um valor de IO a é uma &amp;ldquo;receita para recuperar um valor a do mundo real&amp;rdquo;.
Dizemos que um construtor de tipo m (como [] ou Talvez) forma uma mônada se houver uma instância Mônada m que satisfaça certas leis sobre composição de ações.</description>
    </item>
    
    <item>
      <title>Dobrável</title>
      <link>https://www.wikiod.com/pt/haskell/dobravel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/dobravel/</guid>
      <description>Foldable é a classe de tipos t :: * -&amp;gt; * que admite uma operação folding. Uma dobra agrega os elementos de uma estrutura em uma ordem bem definida, usando uma função de combinação.
Se t for Foldable significa que para qualquer valor t a sabemos como acessar todos os elementos de a de &amp;ldquo;dentro&amp;rdquo; de t a em uma ordem linear fixa. Este é o significado de foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; (t a -&amp;gt; m): nós &amp;ldquo;visitamos&amp;rdquo; cada elemento com uma função de resumo e esmagamos todos os resumos juntos.</description>
    </item>
    
    <item>
      <title>Atravessável</title>
      <link>https://www.wikiod.com/pt/haskell/atravessavel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/atravessavel/</guid>
      <description>A classe Traversable generaliza a função anteriormente conhecida como mapM :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b] para trabalhar com efeitos Aplicativos sobre estruturas que não sejam listas.
Percorrendo uma estrutura ao contrário # Uma travessia pode ser executada na direção oposta com a ajuda do Backwards functor aplicativo , que inverte um aplicativo existente para que os efeitos compostos ocorram na ordem inversa.</description>
    </item>
    
    <item>
      <title>Literais sobrecarregados</title>
      <link>https://www.wikiod.com/pt/haskell/literais-sobrecarregados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/literais-sobrecarregados/</guid>
      <description>Literais inteiros # é um numeral sem um ponto decimal
por exemplo 0, 1, 42, &amp;hellip;
é aplicado implicitamente a fromInteger que faz parte da classe de tipo [Num] (https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Num) então ele realmente tem o tipo Num a =&amp;gt; a - ou seja, pode ter qualquer tipo que é uma instância de Num
Literais fracionários # é um numeral com um ponto decimal
por exemplo 0.0, -0.1111, &amp;hellip;
é implicitamente aplicado a fromRational que faz parte da classe de tipo [Fractional] (https://hackage.</description>
    </item>
    
    <item>
      <title>Teoria da categoria</title>
      <link>https://www.wikiod.com/pt/haskell/teoria-da-categoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/haskell/teoria-da-categoria/</guid>
      <description>Teoria das categorias como um sistema para organizar a abstração # A teoria das categorias é uma teoria matemática moderna e um ramo da álgebra abstrata focada na natureza da conectividade e da relação. É útil para fornecer bases sólidas e linguagem comum para muitas abstrações de programação altamente reutilizáveis. Haskell usa a teoria da categoria como inspiração para algumas das principais classes de tipos disponíveis na biblioteca padrão e em várias bibliotecas populares de terceiros.</description>
    </item>
    
  </channel>
</rss>
