<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de linguagem de montagem e microarquitetura Intel x86 on </title>
    <link>https://www.wikiod.com/pt/docs/x86/</link>
    <description>Recent content in Tutorial de linguagem de montagem e microarquitetura Intel x86 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/x86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução à linguagem de montagem e microarquitetura Intel x86</title>
      <link>https://www.wikiod.com/pt/x86/introducao-a-linguagem-de-montagem-e-microarquitetura-intel-x86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/introducao-a-linguagem-de-montagem-e-microarquitetura-intel-x86/</guid>
      <description>Exemplo x86 Linux Hello World # Este é um programa básico Hello World em assembly NASM para Linux x86 de 32 bits, usando chamadas de sistema diretamente (sem nenhuma chamada de função libc). É muito para absorver, mas com o tempo se tornará compreensível. Linhas que começam com ponto e vírgula(;) são comentários.
Se você ainda não conhece programação de sistemas Unix de baixo nível, talvez queira apenas escrever funções em asm e chamá-las de programas C ou C++.</description>
    </item>
    
    <item>
      <title>Convenções de chamada</title>
      <link>https://www.wikiod.com/pt/x86/convencoes-de-chamada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/convencoes-de-chamada/</guid>
      <description>Recursos # Visões gerais/comparações: Guia de convenção de chamadas agradável de Agner Fog. Além disso, x86 ABIs (wikipedia): convenções de chamada para funções, incluindo x86-64 Windows e System V (Linux).
SystemV x86-64 ABI (padrão oficial). Usado por todos os sistemas operacionais, exceto Windows. (Esta página wiki do github, atualizada por H.J. Lu, tem links para 32 bits, 64 bits e x32. Também links para o fórum oficial para mantenedores/contribuidores da ABI.</description>
    </item>
    
    <item>
      <title>Gerenciamento de multiprocessadores</title>
      <link>https://www.wikiod.com/pt/x86/gerenciamento-de-multiprocessadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/gerenciamento-de-multiprocessadores/</guid>
      <description>Parâmetros # Registro LAPIC Endereço (Relativo a APIC BASE) Registro de ID APIC local +20h Registro de vetor de interrupção espúrio +0f0h Registro de Comando de Interrupção (ICR); bits 0-31 +300h Registro de Comando de Interrupção (ICR); bits 32-63 +310h Para acessar os registradores LAPIC um segmento deve ser capaz de alcançar o intervalo de endereços começando em APIC Base (em IA32_APIC_BASE). Este endereço é relocável e teoricamente pode ser configurado para apontar para algum lugar na memória inferior, tornando assim a faixa endereçável em modo real.</description>
    </item>
    
    <item>
      <title>Registrar Fundamentos</title>
      <link>https://www.wikiod.com/pt/x86/registrar-fundamentos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/registrar-fundamentos/</guid>
      <description>Registradores de 16 bits # Quando a Intel definiu o 8086 original, era um processador de 16 bits com um barramento de endereços de 20 bits (veja abaixo). Eles definiram 8 registradores de 16 bits de uso geral - mas deram a eles funções específicas para determinadas instruções:
AX O registrador do acumulador. Muitos opcodes assumiram esse registro ou seriam mais rápidos se ele fosse especificado. DX O registro de dados.</description>
    </item>
    
    <item>
      <title>Montadores</title>
      <link>https://www.wikiod.com/pt/x86/montadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/montadores/</guid>
      <description>Montador de rede - NASM # O NASM é de longe o montador mais portado para a arquitetura x86 - está disponível para praticamente todos os sistemas operacionais baseados no x86 (mesmo sendo incluído no MacOS) e está disponível como montador multiplataforma em outras plataformas.
Este montador usa a sintaxe Intel, mas é diferente dos outros porque se concentra fortemente em sua própria linguagem &amp;ldquo;macro&amp;rdquo; - isso permite que o programador construa expressões mais complexas usando definições mais simples, permitindo que novas &amp;ldquo;instruções&amp;rdquo; sejam criadas.</description>
    </item>
    
    <item>
      <title>Mecanismos de Chamada do Sistema</title>
      <link>https://www.wikiod.com/pt/x86/mecanismos-de-chamada-do-sistema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/mecanismos-de-chamada-do-sistema/</guid>
      <description>Chamadas de BIOS # Como interagir com o BIOS # O Basic Input/Output System, ou BIOS, é o que controla o computador antes de qualquer sistema operacional ser executado. Para acessar os serviços fornecidos pelo BIOS, o código de montagem usa interrupções. Uma interrupção assume a forma de
int &amp;lt;interrupt&amp;gt; ; interrupt must be a literal number, not in a register or memory O número da interrupção deve estar entre 0 e 255 (0x00 - 0xFF), inclusive.</description>
    </item>
    
    <item>
      <title>Otimização</title>
      <link>https://www.wikiod.com/pt/x86/otimizacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/otimizacao/</guid>
      <description>A família x86 existe há muito tempo e, como tal, existem muitos truques e técnicas que foram descobertos e desenvolvidos que são de conhecimento público - ou talvez não tão público.
A maioria desses truques tira proveito do fato de que muitas instruções efetivamente fazem a mesma coisa - mas versões diferentes são mais rápidas, economizam memória ou não afetam os sinalizadores.
Aqui estão uma série de truques que foram descobertos.</description>
    </item>
    
    <item>
      <title>Modos Real vs Protegido</title>
      <link>https://www.wikiod.com/pt/x86/modos-real-vs-protegido/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/modos-real-vs-protegido/</guid>
      <description>Modo real # Quando a Intel projetou o x86 original, o 8086 (e o derivado 8088), eles incluíram a segmentação para permitir que o processador de 16 bits acessasse mais de 16 bits de endereço. Eles fizeram isso fazendo com que os endereços de 16 bits fossem relativos a um determinado Registrador de Segmento de 16 bits, dos quais eles definiram quatro: Segmento de Código (CS), Segmento de Dados (DS), Segmento Extra (ES) e Segmento de Pilha (SS).</description>
    </item>
    
    <item>
      <title>Controle de fluxo</title>
      <link>https://www.wikiod.com/pt/x86/controle-de-fluxo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/controle-de-fluxo/</guid>
      <description>Condições de teste # Para usar um salto condicional, uma condição deve ser testada. Testar uma condição aqui se refere apenas ao ato de verificar as bandeiras, o salto real é descrito em [Saltos condicionais](https://www.wikiod.com/pt/x86/controle-de-fluxo#Saltos condicionais -saltos).
x86 testa as condições contando com o registrador EFLAGS, que contém um conjunto de sinalizadores que cada instrução pode potencialmente definir.
Instruções aritméticas, como sub ou add, e instruções lógicas, como xor ou and, obviamente &amp;ldquo;definir os sinalizadores&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Paginação - Endereçamento e Memória Virtual</title>
      <link>https://www.wikiod.com/pt/x86/paginacao---enderecamento-e-memoria-virtual/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/x86/paginacao---enderecamento-e-memoria-virtual/</guid>
      <description>Introdução # História # Os primeiros computadores # Os primeiros computadores tinham um bloco de memória no qual o programador colocava código e dados, e a CPU executava nesse ambiente. Dado que os computadores da época eram muito caros, era lamentável que ele fizesse um trabalho, parasse e esperasse que o próximo trabalho fosse carregado nele e depois processasse aquele.
Multiusuário, multiprocessamento # Assim, os computadores rapidamente se tornaram mais sofisticados e suportavam vários usuários e/ou programas simultaneamente - mas foi aí que os problemas começaram a surgir com a ideia simples de &amp;ldquo;um bloco de memória&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>
