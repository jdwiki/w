<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clojurescript Tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/clojurescript/</link>
    <description>Recent content in clojurescript Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Clojurescript</title>
      <link>https://www.wikiod.com/pt/clojurescript/introducao-ao-clojurescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/introducao-ao-clojurescript/</guid>
      <description>Instalação ou Configuração # Leiningen # Observação: Se você for usar o Leiningen, primeiro você precisa baixar e instalar o JDK 6 ou mais recente.
A maneira mais fácil de começar com Clojure é baixar e instalar Leiningen, a ferramenta padrão de fato para gerenciar projetos Clojure.
##Linux:
curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein &amp;gt; ~/bin/lein export PATH=$PATH:~/bin chmod 755 ~/bin/lein lein OS X: # Siga as etapas do Linux acima ou
Instale com [Homebrew]:</description>
    </item>
    
    <item>
      <title>Introdução ao reagente</title>
      <link>https://www.wikiod.com/pt/clojurescript/introducao-ao-reagente/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/introducao-ao-reagente/</guid>
      <description>Reagent é uma biblioteca que implementa elementos do React.js no ClojureScript, como a criação de &amp;ldquo;tags&amp;rdquo; personalizadas, que são implementadas no Reagent por meio de funções.
UI usando Reagent e Hiccup # Reagent é uma interface entre ClojureScript e react. Ele permite que você defina componentes eficientes do React usando nada além de funções e dados simples do ClojureScript, que descrevem sua interface do usuário usando uma sintaxe semelhante ao Hiccup.</description>
    </item>
    
    <item>
      <title>Roda de figo</title>
      <link>https://www.wikiod.com/pt/clojurescript/roda-de-figo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/roda-de-figo/</guid>
      <description>O Figwheel reconstrói automaticamente seu código clojurescript quando os arquivos de origem são alterados e recarrega o código no navegador. O recarregamento funciona sem atualizar a página e você pode preservar parte do estado do aplicativo entre os recarregamentos usando defonce.
É uma alternativa ao desenvolvimento baseado em REPL (embora inclua o REPL também). Em vez de reavaliar as funções alteradas no REPL, ele recarrega todo o código e você pode usar println para ver o resultado da avaliação da expressão no console js do navegador.</description>
    </item>
    
    <item>
      <title>lein-cljsbuild</title>
      <link>https://www.wikiod.com/pt/clojurescript/lein-cljsbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/lein-cljsbuild/</guid>
      <description>Mais detalhes sobre os parâmetros para lein-clsjbuild podem ser encontrados em seu example project.
Desenvolvimento e produção do ClojureScript # Adicione um nó :cljsbuild como o seguinte ao seu arquivo project.clj.
:cljsbuild { :builds { ;;Different target goals should have different names. ;;We have the dev build here :dev { ;;The ClojureScript code should reside in these directories :source-paths [&amp;quot;src-cljs&amp;quot;] :compiler { ;;This is the target output file ;;This will include none of the goog code.</description>
    </item>
    
    <item>
      <title>Eventos JavaScript</title>
      <link>https://www.wikiod.com/pt/clojurescript/eventos-javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/eventos-javascript/</guid>
      <description>Sintaxe # (goog.events dom-element event-type event-handler-function) ;;Cria um ouvinte de evento Google Closure (.addEventListener dom-element load-event) ;;Cria um ouvinte de evento JavaScript normal. Pode ser específico do navegador. Todos os nomes de eventos Closure podem ser encontrados em sua documentação no EventType enum.
Adicionando evento ao botão usando a biblioteca de fechamento # (ns so-doc.events (:require [goog.dom :as dom] [goog.events :as events])) (defn handle-click [event] ;an event object is passed to all events (js/alert &amp;quot;button pressed&amp;quot;)) (events/listen (dom/getElement &amp;quot;button&amp;quot;); This is the dom element the event comes from (.</description>
    </item>
    
    <item>
      <title>Gerenciamento de estado com re-frame (httpsgithub.comDay8re-frame)</title>
      <link>https://www.wikiod.com/pt/clojurescript/gerenciamento-de-estado-com-re-frame-httpsgithubcomday8re-frame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/clojurescript/gerenciamento-de-estado-com-re-frame-httpsgithubcomday8re-frame/</guid>
      <description>Começa a ficar difícil quando pensamos no clojurescript como uma linguagem funcionalmente pura, que mantém o estado para os componentes da interface do usuário. Simplesmente, não é possível.
No entanto, é possível separar componentes individuais, bem como seus estados. Podemos fazer isso armazenando dados/estado em reagente/átomo. Mas quando há muitos estados e muitas dependências, as coisas rapidamente se tornam confusas e começamos a desejar uma solução pronta para o nosso gerenciamento de estado.</description>
    </item>
    
  </channel>
</rss>
