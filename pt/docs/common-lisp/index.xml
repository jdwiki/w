<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de lisp comum on </title>
    <link>https://www.wikiod.com/pt/docs/common-lisp/</link>
    <description>Recent content in Tutorial de lisp comum on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao common-lisp</title>
      <link>https://www.wikiod.com/pt/common-lisp/introducao-ao-common-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/introducao-ao-common-lisp/</guid>
      <description>Recursos de Aprendizagem de Lisp Comum # Livros on-line
São livros de livre acesso online.
Practical Common Lisp de Peter Seibel é uma boa introdução ao CL para programadores experientes, que tenta destacar desde o início o que torna o CL diferente de outras linguagens. Common Lisp: A Gentle Introduction to Symbolic Computation por David S. Touretzky é uma boa introdução para pessoas novas em programação. Common Lisp: Uma abordagem interativa de Stuart C.</description>
    </item>
    
    <item>
      <title>ASDF - Outra Instalação de Definição do Sistema</title>
      <link>https://www.wikiod.com/pt/common-lisp/asdf---outra-instalacao-de-definicao-do-sistema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/asdf---outra-instalacao-de-definicao-do-sistema/</guid>
      <description>ASDF - Outra Instalação de Definição do Sistema
ASDF é uma ferramenta para especificar como os sistemas de software Common Lisp são compostos de componentes (subsistemas e arquivos), e como operar esses componentes na ordem correta para que possam ser compilados, carregados, testados, etc.
Sistema ASDF simples com uma estrutura de diretório simples # Considere este projeto simples com uma estrutura de diretório simples:
example |-- example.asd |-- functions.lisp |-- main.</description>
    </item>
    
    <item>
      <title>ANSI Common Lisp, o padrão da linguagem e sua documentação</title>
      <link>https://www.wikiod.com/pt/common-lisp/ansi-common-lisp-o-padrao-da-linguagem-e-sua-documentacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/ansi-common-lisp-o-padrao-da-linguagem-e-sua-documentacao/</guid>
      <description>Comum Lisp HyperSpec # Common Lisp tem um padrão, que foi publicado inicialmente em 1994 como um padrão ANSI.
O Common Lisp HyperSpec, CLHS curto, fornecido por LispWorks é uma documentação HTML frequentemente usada, que é derivada do documento padrão. O HyperSpec também pode ser baixado e usado localmente.
Ambientes de desenvolvimento Lisp comuns geralmente permitem a consulta da documentação do HyperSpec para símbolos Lisp.
Para GNU Emacs existe clhs.el. SLIME para GNU Emacs fornece uma versão de hyperspec.</description>
    </item>
    
    <item>
      <title>macros</title>
      <link>https://www.wikiod.com/pt/common-lisp/macros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/macros/</guid>
      <description>O Propósito das Macros # As macros destinam-se a gerar código, transformar código e fornecer novas notações. Essas novas notações podem ser mais adequadas para expressar melhor o programa, por exemplo, fornecendo construções em nível de domínio ou novas linguagens incorporadas inteiras.
As macros podem tornar o código-fonte mais autoexplicativo, mas a depuração pode ser mais difícil. Como regra geral, não se deve usar macros quando uma função regular servirá. Quando você usá-los, evite as armadilhas usuais, tente se ater aos padrões e convenções de nomenclatura comumente usados.</description>
    </item>
    
    <item>
      <title>CLOS - o sistema de objetos Common Lisp</title>
      <link>https://www.wikiod.com/pt/common-lisp/clos---o-sistema-de-objetos-common-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/clos---o-sistema-de-objetos-common-lisp/</guid>
      <description>Mixins e interfaces # O Common Lisp não possui interfaces no sentido de algumas linguagens (por exemplo, Java) e há menos necessidade desse tipo de interface, pois o Common Lisp suporta herança múltipla e funções genéricas. No entanto, o mesmo tipo de padrões pode ser realizado facilmente usando classes mixin. Este exemplo mostra a especificação de uma interface de coleção com várias funções genéricas correspondentes.
;; Specification of the COLLECTION &amp;quot;interface&amp;quot; (defclass collection () () (:documentation &amp;quot;A collection mixin.</description>
    </item>
    
    <item>
      <title>Trabalhando com SLIME</title>
      <link>https://www.wikiod.com/pt/common-lisp/trabalhando-com-slime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/trabalhando-com-slime/</guid>
      <description>Usando REPL # CL-USER&amp;gt; (+ 2 3) 5 CL-USER&amp;gt; (sin 1.5) 0.997495 CL-USER&amp;gt; (mapcar (lambda (x) (+ x 2)) &#39;(1 2 3)) (3 4 5) O resultado que é impresso após a avaliação não é apenas uma string: há um objeto Lisp completo atrás dele que pode ser inspecionado clicando com o botão direito nele e escolhendo Inspect.
A entrada de várias linhas também é possível: use C-j para colocar uma nova linha.</description>
    </item>
    
    <item>
      <title>formato</title>
      <link>https://www.wikiod.com/pt/common-lisp/formato/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/formato/</guid>
      <description>Parâmetros # Lista Lambda (formato DESTINATION CONTROL-STRING &amp;amp; REST FORMAT-ARGUMENTS) DESTINOS a coisa para escrever. Isso pode ser um fluxo de saída, t (abreviação de *standard-output*), ou nil (que cria uma string para escrever) CONTROL-STRING a cadeia de modelo. Pode ser uma string primitiva ou pode conter diretivas de comando com prefixo til que especificam e de alguma forma transformam argumentos adicionais. FORMAT-ARGUMENTS argumentos adicionais potenciais requeridos pelo CONTROL-STRING fornecido. A documentação do CLHS para as diretivas FORMAT pode ser encontrada na Seção 22.</description>
    </item>
    
    <item>
      <title>LOOP, uma macro Common Lisp para iteração</title>
      <link>https://www.wikiod.com/pt/common-lisp/loop-uma-macro-common-lisp-para-iteracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/loop-uma-macro-common-lisp-para-iteracao/</guid>
      <description>Iteração Paralela # Múltiplas cláusulas FOR são permitidas em um LOOP. O loop termina quando a primeira dessas cláusulas termina:
(loop for a in &#39;(1 2 3 4 5) for b in &#39;(a b c) collect (list a b)) ;; Evaluates to: ((1 a) (2 b) (3 c)) Outras cláusulas que determinam se o loop deve continuar podem ser combinadas:
(loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) collect a) ;; Evaluates to: (1 2 3) (loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) repeat 1 collect a) ;; Evaluates to: (1) Determine qual lista é mais longa, cortando a iteração assim que a resposta for conhecida:</description>
    </item>
    
    <item>
      <title>Células e listas de contras</title>
      <link>https://www.wikiod.com/pt/common-lisp/celulas-e-listas-de-contras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/celulas-e-listas-de-contras/</guid>
      <description>O que é uma célula de contras? # Uma célula cons, também conhecida como par pontilhado (por causa de sua representação impressa), é simplesmente um par de dois objetos. Uma célula cons é criada pela função cons, e os elementos do par são extraídos usando as funções car e cdr.
(cons &amp;quot;a&amp;quot; 4) Por exemplo, isso retorna um par cujo primeiro elemento (que pode ser extraído com car) é &amp;quot;a&amp;quot;, e cujo segundo elemento (que pode ser extraído com cdr), é 4.</description>
    </item>
    
    <item>
      <title>sequência - como dividir uma sequência</title>
      <link>https://www.wikiod.com/pt/common-lisp/sequencia---como-dividir-uma-sequencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/common-lisp/sequencia---como-dividir-uma-sequencia/</guid>
      <description>Sintaxe # dividir a string de destino da regex e o limite inicial da chave com-registers-p omit-unmatched-p sharedp =&amp;gt; list lispworks:sequência de separação-saco de separação de sequência &amp;amp;chave início fim teste chave de separação separadores =&amp;gt; sequências Sequência do delimitador de sequência dividida &amp;amp;chave inicia fim da contagem final remove-empty-subseqs test test-not key =&amp;gt; lista de subsequências Dividir strings usando expressões regulares # A biblioteca CL-PPCRE fornece a função split que nos permite dividir strings em substrings que correspondem a uma expressão regular, descartando as partes da string que não correspondem.</description>
    </item>
    
  </channel>
</rss>
