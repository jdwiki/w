<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial Delphi Embarcadero on </title>
    <link>https://www.wikiod.com/pt/docs/delphi/</link>
    <description>Recent content in Tutorial Delphi Embarcadero on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/delphi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao Embarcadero Delphi</title>
      <link>https://www.wikiod.com/pt/delphi/introducao-ao-embarcadero-delphi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/introducao-ao-embarcadero-delphi/</guid>
      <description>Olá Mundo # Este programa, salvo em um arquivo chamado HelloWorld.dpr, compila em um aplicativo de console que imprime &amp;ldquo;Hello World&amp;rdquo; no console:
program HelloWorld; {$APPTYPE CONSOLE} begin WriteLn(&#39;Hello World&#39;); end. Mostrar &amp;lsquo;Hello World&amp;rsquo; usando a VCL # Este programa usa VCL, a biblioteca de componentes de interface do usuário padrão do Delphi, para imprimir &amp;ldquo;Hello World&amp;rdquo; em uma caixa de mensagem. A VCL envolve a maioria dos componentes WinAPI comumente usados.</description>
    </item>
    
    <item>
      <title>Uso de try, except e finalmente</title>
      <link>https://www.wikiod.com/pt/delphi/uso-de-try-except-e-finalmente/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/uso-de-try-except-e-finalmente/</guid>
      <description>Sintaxe # Try-except: try [statements] except [[[on E:ExceptionType do statement]] [else statement] | [statements] end;
Try-finally: try [statements] finally [statements] end;
Retorno seguro de exceção de um novo objeto # Quando uma função retorna um objeto (ao invés de usar um que é passado pelo chamador), tome cuidado para que uma exceção não faça com que o objeto vaze.
function MakeStrings: TStrings; begin // Create a new object before entering the try-block.</description>
    </item>
    
    <item>
      <title>Executando um thread enquanto mantém a GUI responsiva</title>
      <link>https://www.wikiod.com/pt/delphi/executando-um-thread-enquanto-mantem-a-gui-responsiva/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/executando-um-thread-enquanto-mantem-a-gui-responsiva/</guid>
      <description>GUI responsiva usando threads para trabalho em segundo plano e PostMessage para relatar os threads # Manter uma GUI responsiva durante a execução de um processo demorado requer alguns &amp;ldquo;retornos de chamada&amp;rdquo; muito elaborados para permitir que a GUI processe sua fila de mensagens ou o uso de threads (de segundo plano) (de trabalho).
Iniciar qualquer número de threads para fazer algum trabalho geralmente não é um problema. A diversão começa quando você deseja que a GUI mostre resultados intermediários e finais ou relate o progresso.</description>
    </item>
    
    <item>
      <title>Cordas</title>
      <link>https://www.wikiod.com/pt/delphi/cordas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/cordas/</guid>
      <description>Tipos de string # Delphi tem os seguintes tipos de strings (em ordem de popularidade):
Tipo Comprimento máximo Tamanho mínimo Descrição string 2 GB 16 bytes Uma string gerenciada. Um alias para AnsiString através do Delphi 2007 e um alias para UnicodeString a partir do Delphi 2009. UnicodeString 2GB 16 bytes Uma string gerenciada no formato UTF-16. AnsiString 2GB 16 bytes Uma string gerenciada no formato ANSI pré-Unicode. A partir do Delphi 2009, ele carrega um indicador de página de código explícito.</description>
    </item>
    
    <item>
      <title>Medição de intervalos de tempo</title>
      <link>https://www.wikiod.com/pt/delphi/medicao-de-intervalos-de-tempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/medicao-de-intervalos-de-tempo/</guid>
      <description>Usando a API do Windows GetTickCount # A função GetTickCount da API do Windows retorna o número de milissegundos desde que o sistema (computador) foi iniciado. Segue o exemplo mais simples:
var Start, Stop, ElapsedMilliseconds: cardinal; begin Start := GetTickCount; // do something that requires measurement Stop := GetTickCount; ElapsedMillseconds := Stop - Start; end; Observe que GetTickCount retorna DWORD de 32 bits, portanto, é agrupado a cada 49,7 dias. Para evitar a quebra, você pode usar GetTickCount64 (disponível desde o Windows Vista) ou rotinas especiais para calcular a diferença de escala:</description>
    </item>
    
    <item>
      <title>Genéricos</title>
      <link>https://www.wikiod.com/pt/delphi/genericos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/genericos/</guid>
      <description>Classifica um array dinâmico via TArray.Sort genérico # uses System.Generics.Collections, { TArray } System.Generics.Defaults; { TComparer&amp;lt;T&amp;gt; } var StringArray: TArray&amp;lt;string&amp;gt;; { Also works with &amp;quot;array of string&amp;quot; } ... { Sorts the array case insensitive } TArray.Sort&amp;lt;string&amp;gt;(StringArray, TComparer&amp;lt;string&amp;gt;.Construct( function (const A, B: string): Integer begin Result := string.CompareText(A, B); end )); Uso simples de TList # var List: TList&amp;lt;Integer&amp;gt;; ... List := TList&amp;lt;Integer&amp;gt;.Create; { Create List } try List.Add(100); { Add Items } List.</description>
    </item>
    
    <item>
      <title>Para loops</title>
      <link>https://www.wikiod.com/pt/delphi/para-loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/para-loops/</guid>
      <description>Sintaxe # for OrdinalVariable := LowerOrdinalValue para UpperOrdinalValue do begin {loop-body} end;
for OrdinalVariable := UpperOrdinalValue downto LowerOrdinalValue do begin {loop-body} end;
para EnumerableVariable em Collection, comece {loop-body} end;
A sintaxe for-loop do Delphi não fornece nada para alterar o valor do passo de 1 para qualquer outro valor.
Ao fazer um loop com valores ordinais variáveis, por exemplo variáveis ​​locais do tipo Integer, os valores superior e inferior serão determinados apenas uma vez.</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>https://www.wikiod.com/pt/delphi/interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/interfaces/</guid>
      <description>As interfaces são usadas para descrever as informações necessárias e a saída esperada de métodos e classes, sem fornecer informações da implementação explícita.
As classes podem implementar interfaces, e as interfaces podem herdar umas das outras. Se uma classe estiver implementando uma interface, isso significa que todas as funções e procedimentos expostos pela interface existem na classe.
Um aspecto especial das interfaces no delphi é que as instâncias de interfaces têm um gerenciamento de tempo de vida baseado na contagem de referências.</description>
    </item>
    
    <item>
      <title>Recuperando dados TDataSet atualizados em um thread em segundo plano</title>
      <link>https://www.wikiod.com/pt/delphi/recuperando-dados-tdataset-atualizados-em-um-thread-em-segundo-plano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/recuperando-dados-tdataset-atualizados-em-um-thread-em-segundo-plano/</guid>
      <description>Este exemplo FireDAC e os outros que estou planejando enviar evitarão o uso de chamadas nativas para abrir o conjunto de dados de forma assíncrona.
Exemplo FireDAC # O exemplo de código abaixo mostra uma maneira de recuperar registros de um MSSql Server em um thread em segundo plano usando FireDAC. Testado para Delphi 10 Seattle
Como escrito:
O encadeamento recupera dados usando seu próprio TFDConnection e TFDQuery e transfere os dados para FDQuery do formulário em uma chamada para Sychronize().</description>
    </item>
    
    <item>
      <title>Executando outros programas</title>
      <link>https://www.wikiod.com/pt/delphi/executando-outros-programas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/delphi/executando-outros-programas/</guid>
      <description>CriarProcesso # A função a seguir encapsula o código para usar a API do Windows CreateProcess para iniciar outros programas.
É configurável e pode esperar até que o processo de chamada termine ou retorne imediatamente.
Parâmetros:
FileName - caminho completo para executável
Params - parâmetros de linha de comando ou use string vazia
Folder - pasta de trabalho para o programa chamado - se o caminho vazio será extraído de FileName</description>
    </item>
    
  </channel>
</rss>
