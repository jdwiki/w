<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial opengl on </title>
    <link>https://www.wikiod.com/pt/docs/opengl/</link>
    <description>Recent content in tutorial opengl on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/opengl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com opengl</title>
      <link>https://www.wikiod.com/pt/opengl/comecando-com-opengl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/comecando-com-opengl/</guid>
      <description>Configuração manual do OpenGL no Windows # Código de exemplo completo incluído no final
Componentes do Windows para OpenGL WGL WGL (pode ser pronunciado wiggle) significa &amp;ldquo;Windows-GL&amp;rdquo;, como em &amp;ldquo;uma interface entre Windows e OpenGL&amp;rdquo; - um conjunto de funções da API do Windows para se comunicar com o OpenGL. As funções WGL têm um prefixo wgl e seus tokens têm um prefixo WGL_.
A versão padrão do OpenGL com suporte em sistemas Microsoft é 1.</description>
    </item>
    
    <item>
      <title>Texturização</title>
      <link>https://www.wikiod.com/pt/opengl/texturizacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/texturizacao/</guid>
      <description>Noções básicas de texturização # Uma textura é uma forma de armazenamento de dados que permite acesso conveniente não apenas a entradas de dados específicas, mas também a pontos de amostra que misturam (interpolam) várias entradas juntas.
No OpenGL, as texturas podem ser usadas para muitas coisas, mas o mais comum é mapear uma imagem para um polígono (por exemplo, um triângulo). Para mapear a textura para um triângulo (ou outro polígono) temos que dizer a cada vértice a qual parte da textura ele corresponde.</description>
    </item>
    
    <item>
      <title>Encapsulando objetos OpenGL com C&#43;&#43; RAII</title>
      <link>https://www.wikiod.com/pt/opengl/encapsulando-objetos-opengl-com-c-raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/encapsulando-objetos-opengl-com-c-raii/</guid>
      <description>Exemplos de várias maneiras de fazer com que objetos OpenGL funcionem com C++ RAII.
O encapsulamento RAII de objetos OpenGL tem perigos. O mais inevitável é que os objetos OpenGL estão associados ao contexto OpenGL que os criou. Portanto, a destruição de um objeto C++ RAII deve ser feita em um contexto OpenGL que compartilha a propriedade do objeto OpenGL gerenciado por esse objeto C++.
Isso também significa que se todos os contextos que possuem o objeto forem destruídos, então quaisquer objetos OpenGL encapsulados em RAII existentes tentarão destruir objetos que não existem mais.</description>
    </item>
    
    <item>
      <title>Matemática 3D</title>
      <link>https://www.wikiod.com/pt/opengl/matematica-3d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/matematica-3d/</guid>
      <description>Introdução às matrizes # Quando você está programando em OpenGL ou qualquer outra API gráfica, você vai se deparar com uma parede de tijolos quando não é tão bom em matemática. Aqui vou explicar com código de exemplo como você pode conseguir movimento/escalonamento e muitas outras coisas legais com seu objeto 3D.
Vamos pegar um caso da vida real&amp;hellip; Você fez um cubo (tridimensional) incrível em OpenGL e quer movê-lo para qualquer direção.</description>
    </item>
    
    <item>
      <title>Iluminação Básica</title>
      <link>https://www.wikiod.com/pt/opengl/iluminacao-basica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/iluminacao-basica/</guid>
      <description>Modelo de iluminação Phong # NOTA: Este exemplo é WIP, será atualizado com diagramas, imagens, mais exemplos, etc.
O que é Phong?
Phong é um modelo de luz muito básico, mas de aparência real, para superfícies que tem três partes: iluminação ambiente, difusa e especular.
Iluminação ambiente:
A iluminação ambiente é a mais simples das três partes para entender e calcular. A iluminação ambiente é a luz que inunda a cena e ilumina o objeto uniformemente em todas as direções.</description>
    </item>
    
    <item>
      <title>Tonalizadores</title>
      <link>https://www.wikiod.com/pt/opengl/tonalizadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/tonalizadores/</guid>
      <description>Sintaxe # #version version_number // Qual versão GLSL estamos usando void main() { /* Código */ } // Função principal do Shader no nome do tipo; // Especifica um parâmetro de entrada - GLSL 1.30 nome do tipo de saída; // Especifica um parâmetro de saída - GLSL 1.30 inout nome do tipo; // Parâmetro para entrada e saída - GLSL 1.30 Parâmetros # Parâmetro Detalhes tipo O tipo do parâmetro deve ser um tipo interno GLSL.</description>
    </item>
    
    <item>
      <title>Carregamento e compilação do sombreador</title>
      <link>https://www.wikiod.com/pt/opengl/carregamento-e-compilacao-do-sombreador/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/carregamento-e-compilacao-do-sombreador/</guid>
      <description>Esses exemplos demonstram várias maneiras de carregar e compilar sombreadores. Todos os exemplos devem incluir código de tratamento de erros.
Objetos Shader, como criados a partir de glCreateShader não fazem muito. Eles contêm o código compilado para um único estágio, mas nem precisam conter o código compilado completo para esse estágio. De muitas maneiras, eles funcionam como arquivos de objeto C e C++.
Os objetos de programa contêm o programa vinculado final.</description>
    </item>
    
    <item>
      <title>Visualização e projeção OGL</title>
      <link>https://www.wikiod.com/pt/opengl/visualizacao-e-projecao-ogl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/visualizacao-e-projecao-ogl/</guid>
      <description>Sobre matriz de modelo, matriz de visualização, projeção ortográfica e em perspectiva
Implemente uma câmera no OGL 4.0 GLSL 400 # Se queremos olhar para uma cena como se a tivéssemos fotografado com uma câmera, devemos primeiro definir algumas coisas:
A posição a partir da qual a cena é vista, a posição do olho pos. O ponto que olhamos na cena (target). It is also common to define the direction in which we look.</description>
    </item>
    
    <item>
      <title>Framebuffers</title>
      <link>https://www.wikiod.com/pt/opengl/framebuffers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/framebuffers/</guid>
      <description>Noções básicas de framebuffers # Framebuffer é um tipo de buffer que armazena valores de cor, profundidade e informações de estêncil de pixels na memória. Quando você desenha algo em OpenGL a saída é armazenada no framebuffer padrão e então você realmente vê os valores de cor desse buffer na tela. Você também pode criar seu próprio framebuffer, que pode ser usado para muitos efeitos interessantes de pós-processamento, como escala de cinza, desfoque, profundidade de campo, distorções, reflexos&amp;hellip;</description>
    </item>
    
    <item>
      <title>Usando VAOs</title>
      <link>https://www.wikiod.com/pt/opengl/usando-vaos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/opengl/usando-vaos/</guid>
      <description>O Vertex Array Object armazena como o opengl deve interpretar um conjunto de VBOs.
Em essência, ele permitirá que você evite chamar glVertexAttribPointer toda vez que desejar renderizar uma nova malha.
Se você não quiser lidar com VAOs, você pode simplesmente criar um e vinculá-lo durante a inicialização do programa e fingir que eles não existem.
Sintaxe # void glEnableVertexAttribArray​(GLuint attribIndex);
void glDisableVertexAttribArray​(GLuint attribIndex);
void glVertexAttribPointer(GLuint attribIndex, tamanho GLint, tipo GLenum, GLboolean normalizado, GLsizei stride, const GLvoid * ponteiro);</description>
    </item>
    
  </channel>
</rss>
