<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nunit Tutorial on </title>
    <link>https://www.wikiod.com/pt/docs/nunit/</link>
    <description>Recent content in Nunit Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/nunit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução ao nunit</title>
      <link>https://www.wikiod.com/pt/nunit/introducao-ao-nunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/nunit/introducao-ao-nunit/</guid>
      <description>Por que você não pode usar Assert.Equals # Já se perguntou por que você não pode usar Assert.Equals() para Nunit e MSTest. Se você não tiver, talvez para começar, você precisa estar ciente de que não pode usar esse método. Em vez disso, você usaria Assert.AreEqual() para comparar dois objetos para igualdade.
A razão aqui é muito simples. Como qualquer classe, a classe Assert é herdada de System.Object que possui um método Equals virtual público destinado a verificar se um determinado objeto é igual ao objeto atual.</description>
    </item>
    
    <item>
      <title>Escreva uma restrição personalizada para o modelo de restrição</title>
      <link>https://www.wikiod.com/pt/nunit/escreva-uma-restricao-personalizada-para-o-modelo-de-restricao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/nunit/escreva-uma-restricao-personalizada-para-o-modelo-de-restricao/</guid>
      <description>Corresponde a um inteiro aproximadamente # Suponha que queremos escrever uma restrição que corresponda a um número, mas de forma aproximada. Digamos, você deveria ter 95 pessoas em uma pesquisa, mas 93 ou 96 também servirão. Podemos escrever uma restrição personalizada do formulário:
public class AlmostEqualToConstraint : Constraint { readonly int _expected; readonly double _expectedMin; readonly double _expectedMax; readonly int _percentageTolerance; public AlmostEqualToConstraint(int expected, int percentageTolerance) { _expected = expected; _expectedMin = expected * (1 - (double)percentageTolerance / 100); _expectedMax = expected * (1 + (double)percentageTolerance / 100); _percentageTolerance = percentageTolerance; Description = $&amp;quot;AlmostEqualTo {expected} with a tolerance of {percentageTolerance}%&amp;quot;; } public override ConstraintResult ApplyTo&amp;lt;TActual&amp;gt;(TActual actual) { if (typeof(TActual) !</description>
    </item>
    
    <item>
      <title>Asserções Fluentes</title>
      <link>https://www.wikiod.com/pt/nunit/assercoes-fluentes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/nunit/assercoes-fluentes/</guid>
      <description>O formulário Assert.That() do NUnit suporta o uso de restrições como seu segundo parâmetro. Todas as restrições fornecidas pelo NUnit estão disponíveis através das classes estáticas Is, Has e Does. As restrições podem ser combinadas em expressões fluentes usando os métodos internos And, Or e With. As expressões podem ser convenientemente expandidas usando os vários métodos em ConstraintExpression, como AtMost e Contains.
Uso de restrição avançada # Asserções fluentes grandes se tornam mais difíceis de ler, mas quando combinadas com classes que possuem boas implementações de ToString(), elas podem gerar mensagens de erro muito úteis.</description>
    </item>
    
    <item>
      <title>Execução de teste e ciclo de vida</title>
      <link>https://www.wikiod.com/pt/nunit/execucao-de-teste-e-ciclo-de-vida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/nunit/execucao-de-teste-e-ciclo-de-vida/</guid>
      <description>Executando testes em uma determinada ordem # Normalmente seus testes devem ser criados de tal forma que a ordem de execução não seja uma preocupação. No entanto, sempre haverá um caso extremo em que você precisa quebrar essa regra.
O único cenário que encontrei foi com o R.NET, em que em um determinado processo você pode inicializar apenas um R Engine e, uma vez descartado, não pode reinicializar. Um dos meus testes aconteceu para lidar com o descarte do motor e, se esse teste fosse executado antes de qualquer outro teste, eles falhariam.</description>
    </item>
    
    <item>
      <title>Atributos</title>
      <link>https://www.wikiod.com/pt/nunit/atributos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/nunit/atributos/</guid>
      <description>A versão 1 do NUnit usou a abordagem clássica para identificar testes com base em herança e convenções de nomenclatura. A partir da versão 2.0, o NUnit usou atributos personalizados para essa finalidade.
Como os acessórios de teste do NUnit não herdam de uma classe de estrutura, o desenvolvedor é livre para usar a herança de outras maneiras. E como não há convenção arbitrária para nomenclatura de testes, a escolha de nomes pode ser inteiramente orientada para comunicar o propósito do teste.</description>
    </item>
    
  </channel>
</rss>
