<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial do symfony3 on </title>
    <link>https://www.wikiod.com/pt/docs/symfony3/</link>
    <description>Recent content in Tutorial do symfony3 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/symfony3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com o symfony3</title>
      <link>https://www.wikiod.com/pt/symfony3/comecando-com-o-symfony3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/comecando-com-o-symfony3/</guid>
      <description>3. Sistemas Windows # Você deve adicionar php à sua variável de ambiente de caminho. Siga estes passos:
Windows 7:
Clique com o botão direito do mouse em um ícone Meu Computador Clique em Propriedades Clique em Configurações avançadas do sistema no navegador esquerdo Clique na guia Avançado Clique no botão Variáveis ​​de Ambiente Na seção Variáveis ​​do Sistema, selecione Caminho (não diferencia maiúsculas de minúsculas) e clique no botão Editar Adicione um ponto e vírgula (;) ao final da string e adicione o caminho completo do sistema de arquivos da sua instalação PHP (por exemplo, C:\Program Files\PHP) Continue clicando em OK etc até que todas as caixas de diálogo desapareçam Feche o prompt de comando e abra-o novamente Ordenado Windows 8 e 10</description>
    </item>
    
    <item>
      <title>Roteamento</title>
      <link>https://www.wikiod.com/pt/symfony3/roteamento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/roteamento/</guid>
      <description>Uma rota é como mapear uma URL para uma ação (função) em uma classe Controller. O tópico a seguir se concentrará na criação de rotas, passando parâmetros para a classe Controller por meio de uma rota usando YAML ou anotação.
É útil ver o que é gerado pelo framework Symfony, este fornece ferramentas para observar todas as rotas de uma aplicação específica.
Do Documento do Symfony, use (em um shell):</description>
    </item>
    
    <item>
      <title>Teste</title>
      <link>https://www.wikiod.com/pt/symfony3/teste/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/teste/</guid>
      <description>Teste simples no Symfony3 # Teste de unidade
Os testes de unidade são usados ​​para garantir que seu código não tenha erros de sintaxe e para testar a lógica do seu código para funcionar conforme o esperado. Exemplo rápido:
src/AppBundle/Calculator/BillCalculator.php
&amp;lt;?php namespace AppBundle\Calculator; use AppBundle\Calculator\TaxCalculator; class BillCalculator { private $taxCalculator; public function __construct(TaxCalculator $taxCalculator) { $this-&amp;gt;taxCalculator = $taxCalculator; } public function calculate($products) { $totalPrice = 0; foreach ($products as $product) { $totalPrice += $product[&#39;price&#39;]; } $tax = $this-&amp;gt;taxCalculator-&amp;gt;calculate($totalPrice); return $totalPrice + $tax; } } src/AppBundle/Calculator/TaxCalculator.</description>
    </item>
    
    <item>
      <title>Trabalhando com WebServices</title>
      <link>https://www.wikiod.com/pt/symfony3/trabalhando-com-webservices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/trabalhando-com-webservices/</guid>
      <description>Rest API # Eu já escrevi [documentação][1] neste site para descrever como fazer web services no Symfony
Vou escrever novamente um tutorial para a versão do symfony &amp;gt;= 3.
Achamos que temos um servidor web instalado em uma versão configurada do [Symfony Framework][2]. Você deve ter [composer][3] (gerenciador de pacotes php) instalado também.
Para simplificar, se você tiver o compositor instalado, digite isso em um terminal/prompt de comando:
composer create-project symfony/framework-standard-edition example &amp;quot;3.</description>
    </item>
    
    <item>
      <title>Formulários dinâmicos</title>
      <link>https://www.wikiod.com/pt/symfony3/formularios-dinamicos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/formularios-dinamicos/</guid>
      <description>Como estender ChoiceType, EntityType e DocumentType para carregar opções com AJAX. # No Symfony, o ChoiceType embutido (e o EntityType ou DocumentType que o estende), basicamente funciona com uma lista de opções constante.
Se você quiser fazê-lo funcionar com chamadas ajax, você deve alterá-las para aceitar quaisquer opções extras enviadas.
Como começar com uma lista de opções vazia? Quando você construir seu formulário, apenas defina a opção choices para um array() vazio:</description>
    </item>
    
    <item>
      <title>Despachante de eventos</title>
      <link>https://www.wikiod.com/pt/symfony3/despachante-de-eventos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/despachante-de-eventos/</guid>
      <description>Sintaxe # $dispatcher-&amp;gt;dispatch(string $eventName, Evento $event);
$dispatcher-&amp;gt;addListener(string $eventName, callable $listener, int $priority = 0);
$dispatcher-&amp;gt;addSubscriber(EventSubscriberInterface $subscriber);
Geralmente, é melhor usar uma única instância do EventDispatcher em seu aplicativo que você injeta nos objetos que precisam disparar eventos.
É uma prática recomendada ter um único local onde você gerencia a configuração e adiciona ouvintes de eventos ao seu EventDispatcher. O framework Symfony usa o Dependency Injection Container.
Esses padrões permitirão que você altere facilmente seus ouvintes de eventos sem precisar alterar o código de qualquer módulo que esteja despachando eventos.</description>
    </item>
    
    <item>
      <title>Validação</title>
      <link>https://www.wikiod.com/pt/symfony3/validacao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/validacao/</guid>
      <description>Na verdade, a validação do formulário é baseada em um componente, chamado &amp;ldquo;Componente Validador&amp;rdquo;.
Muitas vezes, você pode usar o serviço dedicado se não precisar mostrar um formulário em um modelo. Como APIs. Você pode validar os dados da mesma forma, assim:
Por exemplo, baseado no symfony doc :
$validator = $this-&amp;gt;get(&#39;validator&#39;); $errors = $validator-&amp;gt;validate($author); if (count($errors) &amp;gt; 0) { /* * Uses a __toString method on the $errors variable which is a * ConstraintViolationList object.</description>
    </item>
    
    <item>
      <title>Entidades Declarantes</title>
      <link>https://www.wikiod.com/pt/symfony3/entidades-declarantes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/entidades-declarantes/</guid>
      <description>Declarando uma entidade do Symfony como YAML # AppBundle/Entity/Person.php
&lt;?php namespace AppBundle\Entity; /** * Person */ class Person { /** * @var int */ private $id; /** * @var string */ private $name; /** * @var int */ private $age; /** * Get id * * @return int */ public function getId() { return $this-&gt;id; } /** * Set name * * @param string $name * * @return Person */ public function setName($name) { $this-&gt;name = $name; return $this; } /** * Get name * * @return string */ public function getName() { return $this-&gt;name; } /** * Set age * * @param integer $age * * @return Person */ public function setAge($age) { $this-&gt;age = $age; return $this; } /** * Get age * * @return int */ public function getAge() { return $this-&gt;age; } } AppBundle/Resources/config/doctrine/Person.</description>
    </item>
    
    <item>
      <title>Gestão de ativos com Assetic</title>
      <link>https://www.wikiod.com/pt/symfony3/gestao-de-ativos-com-assetic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/gestao-de-ativos-com-assetic/</guid>
      <description>Ao usar o Assetic Bundle, de acordo com a documentação do Symfony, esteja ciente do seguinte:
A partir do Symfony 2.8, o Assetic não é mais incluído por padrão no Symfony Standard Edition. Antes de usar qualquer um de seus recursos, instale o AsseticBundle executando este comando de console em seu projeto:
$ compositor requer symfony/assetic-bundle
Existem outros passos que você tem que tomar. Para mais informações acesse: http://symfony.com/doc/current/assetic/asset_management.html
Parâmetros # Nome Exemplo Caminho &amp;lsquo;static/images/logo/logo-default.</description>
    </item>
    
    <item>
      <title>Configuração</title>
      <link>https://www.wikiod.com/pt/symfony3/configuracao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/symfony3/configuracao/</guid>
      <description>Exemplos e boas práticas para configurar sua aplicação Symfony que não estão na documentação oficial.
Use o nome de classe totalmente qualificado (FQCN) como ID de serviço # Em muitos exemplos, você encontrará um id de serviço como &amp;lsquo;acme.demo.service.id&amp;rsquo; (uma string com pontos). Seu services.yml ficará assim:
services: acme.demo.service.id: class: Acme\DemoBundle\Services\DemoService arguments: [&amp;quot;@doctrine.orm.default_entity_manager&amp;quot;, &amp;quot;@cache&amp;quot;] No seu controlador, você pode usar este serviço:
$service = $this-&amp;gt;get(&#39;acme.demo.service.id&#39;); Embora não haja problemas com isso, você pode usar um nome de classe totalmente qualificado (FQCN) como ID de serviço:</description>
    </item>
    
  </channel>
</rss>
