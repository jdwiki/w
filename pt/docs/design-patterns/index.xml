<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de padrões de design on </title>
    <link>https://www.wikiod.com/pt/docs/design-patterns/</link>
    <description>Recent content in Tutorial de padrões de design on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introdução aos padrões de design</title>
      <link>https://www.wikiod.com/pt/design-patterns/introducao-aos-padroes-de-design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/introducao-aos-padroes-de-design/</guid>
      <description>Introdução # De acordo com Wikipédia:
[A] padrão de projeto de software é uma solução geral reutilizável para um problema comum dentro de um determinado contexto no projeto de software. Não é um projeto acabado que pode ser transformado diretamente em código fonte ou máquina. É uma descrição ou modelo de como resolver um problema que pode ser usado em muitas situações diferentes. Padrões de projeto são práticas recomendadas formalizadas que o programador pode usar para resolver problemas comuns ao projetar um aplicativo ou sistema.</description>
    </item>
    
    <item>
      <title>Fábrica</title>
      <link>https://www.wikiod.com/pt/design-patterns/fabrica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/fabrica/</guid>
      <description>Fornecer uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.
&amp;ndash; GOF 1994
Fábrica simples (Java) # Uma fábrica diminui o acoplamento entre o código que precisa criar objetos a partir do código de criação de objetos. A criação de objetos não é feita explicitamente chamando um construtor de classe, mas chamando alguma função que cria o objeto em nome do chamador. Um exemplo simples de Java é o seguinte:</description>
    </item>
    
    <item>
      <title>Singleton</title>
      <link>https://www.wikiod.com/pt/design-patterns/singleton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/singleton/</guid>
      <description>O padrão de design Singleton às vezes é considerado como &amp;ldquo;Anti padrão&amp;rdquo;. Isto é devido ao fato de que ele tem alguns problemas. Você tem que decidir por si mesmo se acha apropriado usá-lo. Este tópico foi discutido várias vezes no StackOverflow.
Ver: http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons
Singleton (Java) # Singletons em Java são muito parecidos com C#, já que ambas as linguagens são orientadas a objetos. Abaixo está um exemplo de uma classe singleton, onde apenas uma versão do objeto pode estar ativa durante a vida útil do programa (assumindo que o programa funciona em um thread)</description>
    </item>
    
    <item>
      <title>Padrão de Estratégia</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-de-estrategia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-de-estrategia/</guid>
      <description>Exemplo de padrão de estratégia em java com classe Context # Estratégia:
Strategy é um padrão comportamental, que permite alterar o algoritmo dinamicamente a partir de uma família de algoritmos relacionados.
UML do padrão de estratégia da Wikipedia
:
import java.util.*; /* Interface for Strategy */ interface OfferStrategy { public String getName(); public double getDiscountPercentage(); } /* Concrete implementation of base Strategy */ class NoDiscountStrategy implements OfferStrategy{ public String getName(){ return this.</description>
    </item>
    
    <item>
      <title>Padrão do Construtor</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-do-construtor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-do-construtor/</guid>
      <description>Separa a construção de um objeto complexo de sua representação para que o mesmo processo de construção possa criar diferentes representações.
Separar a lógica da representação. Reutilize a lógica para trabalhar com diferentes conjuntos de dados. Java / Lombok # import lombok.Builder; @Builder public class Email { private String to; private String from; private String subject; private String body; } Exemplo de uso:
Email.builder().to(&amp;quot;email1@email.com&amp;quot;) .from(&amp;quot;email2@email.com&amp;quot;) .subject(&amp;quot;Email subject&amp;quot;) .body(&amp;quot;Email content&amp;quot;) .build(); Builder pattern em Java com composição # Intenção:</description>
    </item>
    
    <item>
      <title>Padrão de decorador</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-de-decorador/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-de-decorador/</guid>
      <description>O padrão Decorator permite que um usuário adicione novas funcionalidades a um objeto existente sem alterar sua estrutura. Esse tipo de padrão de projeto vem sob o padrão estrutural, pois esse padrão atua como um wrapper para a classe existente.
Esse padrão cria uma classe decoradora que envolve a classe original e fornece funcionalidade adicional, mantendo a assinatura dos métodos da classe intacta.
Parâmetros # Parâmetro Descrição Bebida pode ser Chá ou Café ##VendingMachineDecorator Definição de decorador de acordo com a Wikipedia:</description>
    </item>
    
    <item>
      <title>Injeção de dependência</title>
      <link>https://www.wikiod.com/pt/design-patterns/injecao-de-dependencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/injecao-de-dependencia/</guid>
      <description>A ideia geral por trás da Injeção de Dependência é que você projete seu aplicativo em torno de componentes fracamente acoplados enquanto adere ao Princípio de Inversão de Dependência. Por não depender de implementações concretas, permite projetar sistemas altamente flexíveis.
A ideia básica por trás da injeção de dependência é criar um código mais flexível. Quando uma classe, em vez de criar suas próprias dependências, recebe suas dependências, a classe se torna mais simples de testar como uma unidade (testes de unidade).</description>
    </item>
    
    <item>
      <title>Padrão de visitante</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-de-visitante/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-de-visitante/</guid>
      <description>Exemplo de padrão de visitante em java # O padrão Visitor permite adicionar novas operações ou métodos a um conjunto de classes sem modificar a estrutura dessas classes.
Esse padrão é especialmente útil quando você deseja centralizar uma operação específica em um objeto sem estender o objeto ou sem modificar o objeto.
Diagrama UML da wikipedia:
Fragmento de código:
import java.util.HashMap; interface Visitable{ void accept(Visitor visitor); } interface Visitor{ void logGameStatistics(Chess chess); void logGameStatistics(Checkers checkers); void logGameStatistics(Ludo ludo); } class GameVisitor implements Visitor{ public void logGameStatistics(Chess chess){ System.</description>
    </item>
    
    <item>
      <title>Padrão de comando</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-de-comando/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-de-comando/</guid>
      <description>Exemplo de padrão de comando em Java # [wikipédia] definição:
O padrão de comando é um padrão de design comportamental no qual um objeto é usado para encapsular todas as informações necessárias para executar uma ação ou acionar um evento posteriormente
Diagrama UML de dofactory:
Componentes básicos e fluxo de trabalho:
Command declara uma interface para comandos abstratos como execute() O Receiver sabe como executar um determinado comando Invoker contém ConcreteCommand, que deve ser executado Client cria ConcreteCommand e atribui Receiver ConcreteCommand define a vinculação entre Command e Receiver Dessa forma, o padrão Command separa Sender (Client) de Receiver por meio de Invoker.</description>
    </item>
    
    <item>
      <title>Padrão de repositório</title>
      <link>https://www.wikiod.com/pt/design-patterns/padrao-de-repositorio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/design-patterns/padrao-de-repositorio/</guid>
      <description>Sobre a implementação de IEnumerable&amp;lt;TEntity&amp;gt; Get(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter): A ideia disso é usar expressões como i =&amp;gt; x.id == 17 para escrever solicitações genéricas. É uma maneira de consultar dados sem usar a linguagem de consulta específica de sua tecnologia. A implementação é bastante extensa, portanto você pode querer considerar outras alternativas, como métodos específicos em seus repositórios implementados: Um CompanyRepository imaginário poderia fornecer o método GetByName(string name).
Repositórios somente leitura (C#) # Um padrão de repositório pode ser usado para encapsular código específico de armazenamento de dados em componentes designados.</description>
    </item>
    
  </channel>
</rss>
