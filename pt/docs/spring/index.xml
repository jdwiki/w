<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de primavera on </title>
    <link>https://www.wikiod.com/pt/docs/spring/</link>
    <description>Recent content in Tutorial de primavera on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/pt/docs/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Começando com a primavera</title>
      <link>https://www.wikiod.com/pt/spring/comecando-com-a-primavera/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/comecando-com-a-primavera/</guid>
      <description>Configuração (Configuração XML) # Etapas para criar o Hello Spring:
Investigue Spring Boot para ver se isso atenderia melhor às suas necessidades. Configure um projeto com as dependências corretas. É recomendável que você esteja usando Maven ou Gradle. crie uma classe POJO, por exemplo Funcionário.java crie um arquivo XML onde você pode definir sua classe e variáveis. por exemplo, beans.xml crie sua classe principal, por exemplo Cliente.java Inclua spring-beans (e suas dependências transitivas!</description>
    </item>
    
    <item>
      <title>Escopos de feijão</title>
      <link>https://www.wikiod.com/pt/spring/escopos-de-feijao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/escopos-de-feijao/</guid>
      <description>Escopos adicionais em contextos com reconhecimento da Web # Existem vários escopos que estão disponíveis apenas em um contexto de aplicativo com reconhecimento da Web:
request - nova instância de bean é criada por solicitação HTTP sessão - nova instância de bean é criada por sessão HTTP aplicativo - nova instância de bean é criada por ServletContext globalSession - nova instância de bean é criada por sessão global no ambiente Portlet (no ambiente Servlet o escopo da sessão global é igual ao escopo da sessão) websocket - nova instância de bean é criada por sessão WebSocket Nenhuma configuração adicional é necessária para declarar e acessar beans com escopo da Web no ambiente Spring Web MVC.</description>
    </item>
    
    <item>
      <title>Criando e usando beans</title>
      <link>https://www.wikiod.com/pt/spring/criando-e-usando-beans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/criando-e-usando-beans/</guid>
      <description>Ligando automaticamente todos os beans de um tipo específico # Se você tiver várias implementações da mesma interface, o Spring pode conectar automaticamente todas elas em um objeto de coleção. Vou usar um exemplo usando um padrão Validador1
Classe Foo:
public class Foo { private String name; private String emailAddress; private String errorMessage; /** Getters &amp;amp; Setters omitted **/ } Interface:
public interface FooValidator { public Foo validate(Foo foo); } Classe do validador de nome:</description>
    </item>
    
    <item>
      <title>Configuração do ApplicationContext</title>
      <link>https://www.wikiod.com/pt/spring/configuracao-do-applicationcontext/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/configuracao-do-applicationcontext/</guid>
      <description>O Spring fez com que configurar um ApplicationContext fosse extremamente flexível. Existem várias maneiras de aplicar cada tipo de configuração, e todas elas podem ser misturadas e combinadas perfeitamente.
Configuração Java é uma forma de configuração explícita. Uma classe anotada @Configuration é usada para especificar os beans que farão parte do ApplicationContext, bem como definir e conectar as dependências de cada bean.
Configuração XML é uma forma de configuração explícita. Um esquema xml específico é usado para definir os beans que farão parte do ApplicationContext.</description>
    </item>
    
    <item>
      <title>Núcleo de mola</title>
      <link>https://www.wikiod.com/pt/spring/nucleo-de-mola/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/nucleo-de-mola/</guid>
      <description>Introdução ao Spring Core # O Spring é um framework vasto, então o framework Spring foi dividido em vários módulos, o que torna o Spring leve. Alguns módulos importantes são:
Núcleo de mola AOP de mola Primavera JDBC Transação de Primavera ORM de mola Mola MVC Todos os módulos do Spring são independentes uns dos outros, exceto Spring Core. Como o Spring core é o módulo base, então em todos os módulos temos que usar o Spring Core</description>
    </item>
    
    <item>
      <title>Execução e agendamento de tarefas</title>
      <link>https://www.wikiod.com/pt/spring/execucao-e-agendamento-de-tarefas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/execucao-e-agendamento-de-tarefas/</guid>
      <description>Expressão Cron # Uma expressão Cron consiste em seis campos sequenciais -
second, minute, hour, day of month, month, day(s) of week e é declarado da seguinte forma
@Scheduled(cron = &amp;quot;* * * * * *&amp;quot;) Também podemos definir o fuso horário como -
@Scheduled(cron=&amp;quot;* * * * * *&amp;quot;, zone=&amp;quot;Europe/Istanbul&amp;quot;) Notas: -
syntax means example explanation ------------------------------------------------------------------------------------ * match any &amp;quot;* * * * * *&amp;quot; do always */x every x &amp;quot;*/5 * * * * *&amp;quot; do every five seconds ?</description>
    </item>
    
    <item>
      <title>Registro condicional de bean no Spring</title>
      <link>https://www.wikiod.com/pt/spring/registro-condicional-de-bean-no-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/registro-condicional-de-bean-no-spring/</guid>
      <description>Ponto importante a ser observado ao usar a condição
A classe de condição é referida como classe direta (não como bean de mola) então ela não pode usar a injeção de propriedade @Value, ou seja, nenhum outro feijão de mola pode ser injetado dentro dela. De documentos java - As condições devem seguir as mesmas restrições que BeanFactoryPostProcessor e tomar cuidado para nunca interagir com instâncias de bean. As restrições mencionadas aqui são Um BeanFactoryPostProcessor pode interagir e modificar definições de bean, mas nunca instâncias de bean.</description>
    </item>
    
    <item>
      <title>Injeção de Dependência (DI) e Inversão de Controle (IoC)</title>
      <link>https://www.wikiod.com/pt/spring/injecao-de-dependencia-di-e-inversao-de-controle-ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/injecao-de-dependencia-di-e-inversao-de-controle-ioc/</guid>
      <description>O código-fonte para grandes aplicativos de software geralmente é organizado em várias unidades. A definição de uma unidade normalmente varia de acordo com a linguagem de programação utilizada. Por exemplo, o código escrito em uma linguagem de programação procedural (como C) é organizado em funções ou procedures. Da mesma forma, o código em uma linguagem de programação orientada a objetos (como Java, Scala e C#) é organizado em classes, interfaces e assim por diante.</description>
    </item>
    
    <item>
      <title>RestTemplate</title>
      <link>https://www.wikiod.com/pt/spring/resttemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/resttemplate/</guid>
      <description>Baixando um arquivo grande # Os métodos getForObject e getForEntity de RestTemplate carregam toda a resposta na memória. Isso não é adequado para baixar arquivos grandes, pois pode causar exceções de falta de memória. Este exemplo mostra como transmitir a resposta de uma solicitação GET.
RestTemplate restTemplate // = ...; // Optional Accept header RequestCallback requestCallback = request -&amp;gt; request.getHeaders() .setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL)); // Streams the response instead of loading it all in memory ResponseExtractor&amp;lt;Void&amp;gt; responseExtractor = response -&amp;gt; { // Here I write the response to a file but do what you like Path path = Paths.</description>
    </item>
    
    <item>
      <title>JdbcTemplateName</title>
      <link>https://www.wikiod.com/pt/spring/jdbctemplatename/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/pt/spring/jdbctemplatename/</guid>
      <description>A classe JdbcTemplate executa consultas SQL, instruções de atualização e chamadas de procedimento armazenado, executa iteração sobre ResultSets e extração de valores de parâmetros retornados. Ele também captura exceções JDBC e as traduz para a hierarquia de exceção genérica e mais informativa definida no pacote org.springframework.dao.
As instâncias da classe JdbcTemplate são threadsafe uma vez configuradas para que possam ser injetadas com segurança essa referência compartilhada em vários DAOs.
Métodos básicos de consulta # Alguns dos métodos queryFor* disponíveis em JdbcTemplate são úteis para instruções sql simples que executam operações CRUD.</description>
    </item>
    
  </channel>
</rss>
