<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design patterns Tutorial on </title>
    <link>https://www.wikiod.com/docs/design-patterns/</link>
    <description>Recent content in Design patterns Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Design patterns</title>
      <link>https://www.wikiod.com/design-patterns/getting-started-with-design-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/getting-started-with-design-patterns/</guid>
      <description>Introduction # According to Wikipedia:
[A] software design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is not a finished design that can be transformed directly into source or machine code. It is a description or template for how to solve a problem that can be used in many different situations. Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.</description>
    </item>
    
    <item>
      <title>Factory</title>
      <link>https://www.wikiod.com/design-patterns/factory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/factory/</guid>
      <description>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.
&amp;ndash; GOF 1994
Simple factory (Java) # A factory decreases coupling between code that needs to create objects from object creation code. Object creation is not made explicitly by calling a class constructor but by calling some function that creates the object on behalf the caller. A simple Java example is the following one:</description>
    </item>
    
    <item>
      <title>Singleton</title>
      <link>https://www.wikiod.com/design-patterns/singleton/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/singleton/</guid>
      <description>The Singleton design pattern is sometimes regarded as &amp;ldquo;Anti pattern&amp;rdquo;. This is due to the fact that it has some problems. You have to decide for yourself if you think it is appropriate to use it. This topic has been discussed several times on StackOverflow.
See: http://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons
Singleton (Java) # Singletons in Java are very similar to C#, being as both languages are object orientated. Below is an example of a singleton class, where only one version of the object can be alive during the program&amp;rsquo;s lifetime (Assuming the program works on one thread)</description>
    </item>
    
    <item>
      <title>Strategy Pattern</title>
      <link>https://www.wikiod.com/design-patterns/strategy-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/strategy-pattern/</guid>
      <description>Strategy pattern example in java with Context class # Strategy:
Strategy is a behavioural pattern, which allows to change the algorithm dynamically from a family of related algorithms.
UML of Strategy pattern from Wikipedia
:
import java.util.*; /* Interface for Strategy */ interface OfferStrategy { public String getName(); public double getDiscountPercentage(); } /* Concrete implementation of base Strategy */ class NoDiscountStrategy implements OfferStrategy{ public String getName(){ return this.getClass().getName(); } public double getDiscountPercentage(){ return 0; } } /* Concrete implementation of base Strategy */ class QuarterDiscountStrategy implements OfferStrategy{ public String getName(){ return this.</description>
    </item>
    
    <item>
      <title>Builder Pattern</title>
      <link>https://www.wikiod.com/design-patterns/builder-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/builder-pattern/</guid>
      <description>Separates the construction of a complex object from its representation so that the same construction process can create different representations.
Separate the logic from representation. Reuse logic to work with different set of data. Java / Lombok # import lombok.Builder; @Builder public class Email { private String to; private String from; private String subject; private String body; } Usage example:
Email.builder().to(&amp;quot;email1@email.com&amp;quot;) .from(&amp;quot;email2@email.com&amp;quot;) .subject(&amp;quot;Email subject&amp;quot;) .body(&amp;quot;Email content&amp;quot;) .build(); Builder pattern in Java with composition # Intent:</description>
    </item>
    
    <item>
      <title>Decorator pattern</title>
      <link>https://www.wikiod.com/design-patterns/decorator-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/decorator-pattern/</guid>
      <description>Decorator pattern allows a user to add new functionality to an existing object without altering its structure. This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class.
This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact.
Parameters # Parameter Description Beverage it can be Tea or Coffee VendingMachineDecorator # Definition of Decorator as per Wikiepdia:</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://www.wikiod.com/design-patterns/dependency-injection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/dependency-injection/</guid>
      <description>The general idea behind Dependency Injection is that you design your application around loosely coupled components while adhering to the Dependency Inversion Principle. By not depending on concrete implementations, allows to design highly flexible systems.
The basic idea behind dependency injection is to create more loosely coupled code. When a class, rather than newing up its own dependencies, takes in its dependencies instead, the class becomes more simple to test as a unit (unit testing).</description>
    </item>
    
    <item>
      <title>Visitor Pattern</title>
      <link>https://www.wikiod.com/design-patterns/visitor-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/visitor-pattern/</guid>
      <description>Visitor pattern example in java # Visitor pattern allows you to add new operations or methods to a set of classes without modifying the structure of those classes.
This pattern is especially useful when you want to centralise a particular operation on an object without extending the object Or without modifying the object.
UML diagram from wikipedia:
Code snippet:
import java.util.HashMap; interface Visitable{ void accept(Visitor visitor); } interface Visitor{ void logGameStatistics(Chess chess); void logGameStatistics(Checkers checkers); void logGameStatistics(Ludo ludo); } class GameVisitor implements Visitor{ public void logGameStatistics(Chess chess){ System.</description>
    </item>
    
    <item>
      <title>Command pattern</title>
      <link>https://www.wikiod.com/design-patterns/command-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/command-pattern/</guid>
      <description>Command pattern example in Java # wikipedia definition:
Command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time
UML diagram from dofactory:
Basic components and workflow:
Command declares an interface for abstract commands like execute() Receiver knows how to execute a particular command Invoker holds ConcreteCommand, which has to be executed Client creates ConcreteCommand and assign Receiver ConcreteCommand defines binding between Command and Receiver In this way, Command pattern decouples Sender (Client) from Receiver through Invoker.</description>
    </item>
    
    <item>
      <title>Repository Pattern</title>
      <link>https://www.wikiod.com/design-patterns/repository-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/design-patterns/repository-pattern/</guid>
      <description>About the implementation of IEnumerable&amp;lt;TEntity&amp;gt; Get(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter): The idea of this is to use Expressions like i =&amp;gt; x.id == 17 to write generic requests. It is a way to query data without using the specific query language of your technology. The implementation is rather extensive, therefore you might want to consider other alternatives, like specific methods on your implemented repositories: An imaginary CompanyRepository could provide the method GetByName(string name).</description>
    </item>
    
  </channel>
</rss>
