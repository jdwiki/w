<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; Tutorial on </title>
    <link>https://www.wikiod.com/docs/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with C&#43;&#43;</title>
      <link>https://www.wikiod.com/c-/getting-started-with-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/getting-started-with-c-/</guid>
      <description>Hello World # This program prints Hello World! to the standard output stream:
#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; } See it live on Coliru.
Analysis # Let&amp;rsquo;s examine each part of this code in detail:
#include &amp;lt;iostream&amp;gt; is a preprocessor directive that includes the content of the standard C++ header file iostream.
iostream is a standard library header file that contains definitions of the standard input and output streams.</description>
    </item>
    
    <item>
      <title>stdvector</title>
      <link>https://www.wikiod.com/c-/stdvector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/stdvector/</guid>
      <description>A vector is a dynamic array with automatically handled storage. The elements in a vector can be accessed just as efficiently as those in an array with the advantage being that vectors can dynamically change in size.
In terms of storage the vector data is (usually) placed in dynamically allocated memory thus requiring some minor overhead; conversely C-arrays and std::array use automatic storage relative to the declared location and thus do not have any overhead.</description>
    </item>
    
    <item>
      <title>Returning several values from a function</title>
      <link>https://www.wikiod.com/c-/returning-several-values-from-a-function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/returning-several-values-from-a-function/</guid>
      <description>There are many situations where it is useful to return several values from a function: for example, if you want to input an item and return the price and number in stock, this functionality could be useful. There are many ways to do this in C++, and most involve the STL. However, if you wish to avoid the STL for some reason, there are still several ways to do this, including structs/classes and arrays.</description>
    </item>
    
    <item>
      <title>The Rule of Three, Five, And Zero</title>
      <link>https://www.wikiod.com/c-/the-rule-of-three-five-and-zero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/the-rule-of-three-five-and-zero/</guid>
      <description>Rule of Zero # We can combine the principles of the Rule of Five and RAII to get a much leaner interface: the Rule of Zero: any resource that needs to be managed should be in its own type. That type would have to follow the Rule of Five, but all users of that resource do not need to write any of the five special member functions and can simply default all of them.</description>
    </item>
    
    <item>
      <title>Lambdas</title>
      <link>https://www.wikiod.com/c-/lambdas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/lambdas/</guid>
      <description>Syntax # [default-capture, capture-list] (argument-list) mutable throw-specification attributes -&amp;gt; return-type { lambda-body } // Order of lambda specifiers and attributes. [capture-list] (argument-list) { lambda-body } // Common lambda definition. [=] (argument-list) { lambda-body } // Captures all needed local variables by value. [&amp;amp;] (argument-list) { lambda-body } // Captures all needed local variables by reference. [capture-list] { lambda-body } // Argument list and specifiers can be omitted. Parameters # Parameter Details default-capture Specifies how all non-listed variables are captured.</description>
    </item>
    
    <item>
      <title>Smart Pointers</title>
      <link>https://www.wikiod.com/c-/smart-pointers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/smart-pointers/</guid>
      <description>Syntax # std::shared_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_shared&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); std::shared_ptr&amp;lt;ClassType&amp;gt; variableName (new ClassType(arg1, arg2, ...)); std::unique_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_unique&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); // C++14 std::unique_ptr&amp;lt;ClassType&amp;gt; variableName (new ClassType(arg1, arg2, ...)); C++ is not a memory-managed language. Dynamically allocated memory (i.e. objects created with new) will be &amp;ldquo;leaked&amp;rdquo; if it is not explicitly deallocated (with delete). It is the programmer&amp;rsquo;s responsibility to ensure that the dynamically allocated memory is freed before discarding the last pointer to that object.</description>
    </item>
    
    <item>
      <title>stdstring</title>
      <link>https://www.wikiod.com/c-/stdstring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/stdstring/</guid>
      <description>Strings are objects that represent sequences of characters. The standard string class provides a simple, safe and versatile alternative to using explicit arrays of chars when dealing with text and other sequences of characters. The C++ string class is part of the std namespace and was standardized in 1998.
Syntax # // Empty string declaration
std::string s;
// Constructing from const char* (c-string)
std::string s(&amp;ldquo;Hello&amp;rdquo;);
std::string s = &amp;ldquo;Hello&amp;rdquo;;
// Constructing using copy constructor</description>
    </item>
    
    <item>
      <title>Templates</title>
      <link>https://www.wikiod.com/c-/templates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/templates/</guid>
      <description>Classes, functions, and (since C++14) variables can be templated. A template is a piece of code with some free parameters that will become a concrete class, function, or variable when all parameters are specified. Parameters can be types, values, or themselves templates. A well-known template is std::vector, which becomes a concrete container type when the element type is specified, e.g., std::vector&amp;lt;int&amp;gt;.
Syntax # template &amp;lt; template-parameter-list &amp;gt; declaration export template &amp;lt; template-parameter-list &amp;gt; declaration /* until C++11 */ template &amp;lt;&amp;gt; declaration template declaration extern template declaration /* since C++11 */ template &amp;lt; template-parameter-list &amp;gt; class &amp;hellip;(opt) identifier(opt) template &amp;lt; template-parameter-list &amp;gt; class identifier(opt) = id-expression template &amp;lt; template-parameter-list &amp;gt; typename &amp;hellip;(opt) identifier(opt) /* since C++17 */ template &amp;lt; template-parameter-list &amp;gt; typename identifier(opt) = id-expression /* since C++17 */ postfix-expression .</description>
    </item>
    
    <item>
      <title>Metaprogramming</title>
      <link>https://www.wikiod.com/c-/metaprogramming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/metaprogramming/</guid>
      <description>In C++ Metaprogramming refers to the use of macros or templates to generate code at compile-time.
In general, macros are frowned upon in this role and templates are preferred, although they are not as generic.
Template metaprogramming often makes use of compile-time computations, whether via templates or constexpr functions, to achieve its goals of generating code, however compile-time computations are not metaprogramming per se.
Metaprogramming (or more specifically, Template Metaprogramming) is the practice of using templates to create constants, functions, or data structures at compile-time.</description>
    </item>
    
    <item>
      <title>Threading</title>
      <link>https://www.wikiod.com/c-/threading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/c-/threading/</guid>
      <description>Syntax # thread() thread(thread&amp;amp;&amp;amp; other) explicit thread(Function&amp;amp;&amp;amp; func, Args&amp;amp;&amp;amp;&amp;hellip; args) Parameters # Parameter Details other Takes ownership of other, other doesn&amp;rsquo;t own the thread anymore func Function to call in a seperate thread args Arguments for func Some notes:
Two std::thread objects can never represent the same thread. A std::thread object can be in a state where it doesn&amp;rsquo;t represent any thread (i.e. after a move, after calling join, etc.). Creating a std::thread # In C++, threads are created using the std::thread class.</description>
    </item>
    
  </channel>
</rss>
