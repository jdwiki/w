<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unit-testing Tutorial on </title>
    <link>https://www.wikiod.com/docs/unit-testing/</link>
    <description>Recent content in unit-testing Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/unit-testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with unit-testing</title>
      <link>https://www.wikiod.com/unit-testing/getting-started-with-unit-testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/getting-started-with-unit-testing/</guid>
      <description>A basic unit test # At its simplest, a unit test consists of three stages:
Prepare the environment for the test Execute the code to be tested Validate the expected behaviour matches the observed behaviour These three stages are often called &amp;lsquo;Arrange-Act-Assert&amp;rsquo;, or &amp;lsquo;Given-When-Then&amp;rsquo;.
Below is example in C# that uses the NUnit framework.
[TestFixture] public CalculatorTest { [Test] public void Add_PassSevenAndThree_ExpectTen() { // Arrange - setup environment var systemUnderTest = new Calculator(); // Act - Call system under test var calculatedSum = systemUnderTest.</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://www.wikiod.com/unit-testing/dependency-injection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/dependency-injection/</guid>
      <description>One approach that can be taken to writing software is to create dependencies as they are needed. This is quite an intuitive way to write a program and is the way that most people will tend to be taught, partly because it is easy to follow. One of the issues with this approach is that it can be hard to test. Consider a method that does some processing based on the current date.</description>
    </item>
    
    <item>
      <title>Test Doubles</title>
      <link>https://www.wikiod.com/unit-testing/test-doubles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/test-doubles/</guid>
      <description>When testing, it is sometimes useful to use a test double to manipulate or verify the behaviour of the system under test. The doubles are passed or injected into the class or method under test instead of instances of production code.
Using a stub to supply canned responses # A stub is a light weight test double that provides canned responses when methods are called. Where a class under test relies on an interface or base class an alternative &amp;lsquo;stub&amp;rsquo; class can be implemented for testing which conforms to the interface.</description>
    </item>
    
    <item>
      <title>Unit Testing Best Practices</title>
      <link>https://www.wikiod.com/unit-testing/unit-testing-best-practices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/unit-testing-best-practices/</guid>
      <description>A unit test is the smallest testable part of an application like functions, classes, procedures, interfaces. Unit testing is a method by which individual units of source code are tested to determine if they are fit for use. Unit tests are basically written and executed by software developers to make sure that code meets its design and requirements and behaves as expected.
MakeSut concept # Testcode has the same quality demands, as production code.</description>
    </item>
    
    <item>
      <title>The general rules for unit testing for all languages</title>
      <link>https://www.wikiod.com/unit-testing/the-general-rules-for-unit-testing-for-all-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/the-general-rules-for-unit-testing-for-all-languages/</guid>
      <description>When starting with unit-testing all kinds of questions come up:
What is unit-testing? What is a SetUp and TearDown? How do I deal with dependencies? Why do unit-testing at all? How do I make good unit tests?
This article will answer all these questions, so you can start unit-testing in any language you want.
What is unit testing? # Unit testing is the testing of code to ensure that it performs the task that it is meant to perform.</description>
    </item>
    
    <item>
      <title>Guide unit testing in Visual Studio for C#</title>
      <link>https://www.wikiod.com/unit-testing/guide-unit-testing-in-visual-studio-for-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/guide-unit-testing-in-visual-studio-for-c/</guid>
      <description>How to create unit test project and unit tests and how to run the unit tests and code coverage tool.
In this guide the standard MSTest framework will be used and the standard Code Coverage Analyses tool which are available in Visual Studio.
The guide was written for Visual Studio 2015, so it&amp;rsquo;s possible some things are different in other versions.
Creating a unit test project # Open the C# project Right-click on the solution -&amp;gt; Add -&amp;gt; New Project… (Figure 1) Go to Installed -&amp;gt; Visual C# -&amp;gt; Test Click on Unit Test Project Give it a name and click OK (Figure 2) The unit test project is added to the solution (Figure 3) Adding the reference to the application you want to test # In the unit test project, add a reference to the project you want to test Right-click on References -&amp;gt; Add Reference… (Figure 3) Select the project you want to test Go to Projects -&amp;gt; Solution Check the checkbox of the project you want to test -&amp;gt; click OK (Figure 4) Two methods to create unit tests # Method 1 # Go to your unit test class in the unit test project</description>
    </item>
    
    <item>
      <title>Assertion Types</title>
      <link>https://www.wikiod.com/unit-testing/assertion-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/assertion-types/</guid>
      <description>Verifying a Returned Value # [Test] public void Calculator_Add_ReturnsSumOfTwoNumbers() { Calculator calculatorUnderTest = new Calculator(); double result = calculatorUnderTest.Add(2, 3); Assert.AreEqual(5, result); } State Based Testing # Given this simple class, we can test that the ShaveHead method is working correctly by asserting state of the HairLength variable is set to zero after the ShaveHead method is called.
public class Person { public string Name; public int HairLength; public Person(string name, int hairLength) { this.</description>
    </item>
    
    <item>
      <title>Unit testing of Loops (Java)</title>
      <link>https://www.wikiod.com/unit-testing/unit-testing-of-loops-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/unit-testing/unit-testing-of-loops-java/</guid>
      <description>Loops considered as one of the important control structures in any programming language. There are different ways in which we can achieve loop coverage.
These methods differ based on type of loop.
Single loops
Nested Loops
Concatenated loops
Single loop test # These are loops in which their loop body contains no other loops (the innermost loop in case of nested).
In order to have loop coverage, testers should exercise the tests given below.</description>
    </item>
    
  </channel>
</rss>
