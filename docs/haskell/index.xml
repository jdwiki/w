<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell Language Tutorial on </title>
    <link>https://www.wikiod.com/docs/haskell/</link>
    <description>Recent content in Haskell Language Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/haskell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Haskell Language</title>
      <link>https://www.wikiod.com/haskell/getting-started-with-haskell-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/getting-started-with-haskell-language/</guid>
      <description>Hello, World! # A basic &amp;ldquo;Hello, World!&amp;rdquo; program in Haskell can be expressed concisely in just one or two lines:
main :: IO () main = putStrLn &amp;quot;Hello, World!&amp;quot; The first line is an optional type annotation, indicating that main is a value of type IO (), representing an I/O action which &amp;ldquo;computes&amp;rdquo; a value of type () (read &amp;ldquo;unit&amp;rdquo;; the empty tuple conveying no information) besides performing some side effects on the outside world (here, printing a string at the terminal).</description>
    </item>
    
    <item>
      <title>Lens</title>
      <link>https://www.wikiod.com/haskell/lens/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/lens/</guid>
      <description>Lens is a library for Haskell that provides lenses, isomorphisms, folds, traversals, getters and setters, which exposes a uniform interface for querying and manipulating arbitrary structures, not unlike Java&amp;rsquo;s accessor and mutator concepts.
What is a Lens? # Lenses (and other optics) allow us to separate describing how we want to access some data from what we want to do with it. It is important to distinguish between the abstract notion of a lens and the concrete implementation.</description>
    </item>
    
    <item>
      <title>Common GHC Language Extensions</title>
      <link>https://www.wikiod.com/haskell/common-ghc-language-extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/common-ghc-language-extensions/</guid>
      <description>These language extensions are typically available when using the Glasgow Haskell Compiler (GHC) as they are not part of the approved Haskell 2010 language Report. To use these extensions, one must either inform the compiler using a flag or place a LANGUAGE programa before the module keyword in a file. The official documentation can be found in section 7 of the GCH users guide.
The format of the LANGUAGE programa is {-# LANGUAGE ExtensionOne, ExtensionTwo .</description>
    </item>
    
    <item>
      <title>Free Monads</title>
      <link>https://www.wikiod.com/haskell/free-monads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/free-monads/</guid>
      <description>Free monads split monadic computations into data structures and interpreters # For instance, a computation involving commands to read and write from the prompt:
First we describe the &amp;ldquo;commands&amp;rdquo; of our computation as a Functor data type
{-# LANGUAGE DeriveFunctor #-} data TeletypeF next = PrintLine String next | ReadLine (String -&amp;gt; next) deriving Functor Then we use Free to create the &amp;ldquo;Free Monad over TeletypeF&amp;rdquo; and build some basic operations.</description>
    </item>
    
    <item>
      <title>IO</title>
      <link>https://www.wikiod.com/haskell/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/io/</guid>
      <description>Getting the &amp;lsquo;a&amp;rsquo; &amp;ldquo;out of&amp;rdquo; &amp;lsquo;IO a&amp;rsquo; # A common question is &amp;ldquo;I have a value of IO a, but I want to do something to that a value: how do I get access to it?&amp;rdquo; How can one operate on data that comes from the outside world (for example, incrementing a number typed by the user)?
The point is that if you use a pure function on data obtained impurely, then the result is still impure.</description>
    </item>
    
    <item>
      <title>Monads</title>
      <link>https://www.wikiod.com/haskell/monads/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/monads/</guid>
      <description>A monad is a data type of composable actions. Monad is the class of type constructors whose values represent such actions. Perhaps IO is the most recognizable one: a value of IO a is a &amp;ldquo;recipe for retrieving an a value from the real world&amp;rdquo;.
We say a type constructor m (such as [] or Maybe) forms a monad if there is an instance Monad m satisfying certain laws about composition of actions.</description>
    </item>
    
    <item>
      <title>Foldable</title>
      <link>https://www.wikiod.com/haskell/foldable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/foldable/</guid>
      <description>Foldable is the class of types t :: * -&amp;gt; * which admit a folding operation. A fold aggregates the elements of a structure in a well-defined order, using a combining function.
If t is Foldable it means that for any value t a we know how to access all of the elements of a from &amp;ldquo;inside&amp;rdquo; of t a in a fixed linear order. This is the meaning of foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; (t a -&amp;gt; m): we &amp;ldquo;visit&amp;rdquo; each element with a summary function and smash all the summaries together.</description>
    </item>
    
    <item>
      <title>Traversable</title>
      <link>https://www.wikiod.com/haskell/traversable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/traversable/</guid>
      <description>The Traversable class generalises the function formerly known as mapM :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b] to work with Applicative effects over structures other than lists.
Traversing a structure in reverse # A traversal can be run in the opposite direction with the help of the Backwards applicative functor, which flips an existing applicative so that composed effects take place in reversed order.</description>
    </item>
    
    <item>
      <title>Overloaded Literals</title>
      <link>https://www.wikiod.com/haskell/overloaded-literals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/overloaded-literals/</guid>
      <description>Integer Literals # is a numeral without a decimal point
for example 0, 1, 42, &amp;hellip;
is implicitly applied to fromInteger which is part of the Num type class so it indeed has type Num a =&amp;gt; a - that is it can have any type that is an instance of Num
Fractional Literals # is a numeral with a decimal point
for example 0.0, -0.1111, &amp;hellip;
is implicitly applied to fromRational which is part of the Fractional type class so it indeed has type a =&amp;gt; a - that is it can have any type that is an instance of Fractional</description>
    </item>
    
    <item>
      <title>Category Theory</title>
      <link>https://www.wikiod.com/haskell/category-theory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haskell/category-theory/</guid>
      <description>Category theory as a system for organizing abstraction # Category theory is a modern mathematical theory and a branch of abstract algebra focused on the nature of connectedness and relation. It is useful for giving solid foundations and common language to many highly reusable programming abstractions. Haskell uses Category theory as inspiration for some of the core typeclasses available in both the standard library and several popular third-party libraries.
An example # The Functor typeclass says that if a type F instantiates Functor (for which we write Functor F) then we have a generic operation</description>
    </item>
    
  </channel>
</rss>
