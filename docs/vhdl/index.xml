<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vhdl Tutorial on </title>
    <link>https://www.wikiod.com/docs/vhdl/</link>
    <description>Recent content in vhdl Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/vhdl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with vhdl</title>
      <link>https://www.wikiod.com/vhdl/getting-started-with-vhdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/getting-started-with-vhdl/</guid>
      <description>Signals vs. variables, a brief overview of the simulation semantics of VHDL # This example deals with one of the most fundamental aspects of the VHDL language: the simulation semantics. It is intended for VHDL beginners and presents a simplified view where many details have been omitted (postponed processes, VHDL Procedural Interface, shared variables&amp;hellip;) Readers interested in the real complete semantics shall refer to the Language Reference Manual (LRM).
Signals and variables # Most classical imperative programming languages use variables.</description>
    </item>
    
    <item>
      <title>Digital hardware design using VHDL in a nutshell</title>
      <link>https://www.wikiod.com/vhdl/digital-hardware-design-using-vhdl-in-a-nutshell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/digital-hardware-design-using-vhdl-in-a-nutshell/</guid>
      <description>In this topic we propose a simple method to correctly design simple digital circuits with VHDL. The method is based on graphical block diagrams and an easy-to-remember principle:
Think hardware first, code VHDL next
It is intended for beginners in digital hardware design using VHDL, with a limited understanding of the synthesis semantics of the language.
Digital hardware design using VHDL is simple, even for beginners, but there are a few important things to know and a small set of rules to obey.</description>
    </item>
    
    <item>
      <title>Protected types</title>
      <link>https://www.wikiod.com/vhdl/protected-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/protected-types/</guid>
      <description>Prior VHDL 1993, two concurrent processes could communicate only with signals. Thanks to the simulation semantics of the language that updates signals only between simulation steps, the result of a simulation was deterministic: it did not depend on the order chosen by the simulation scheduler to execute the processes.
[In fact, this is not 100% true. Processes could also communicate using file input/output. But if a designer was compromising the determinism by using files, it could not really be a mistake.</description>
    </item>
    
    <item>
      <title>Resolution functions, unresolved and resolved types</title>
      <link>https://www.wikiod.com/vhdl/resolution-functions-unresolved-and-resolved-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/resolution-functions-unresolved-and-resolved-types/</guid>
      <description>VHDL types can be unresolved or resolved. The bit type declared by the std.standard package, for instance, is unresolved while the std_logic type declared by the ieee.std_logic_1164 package is resolved.
A signal which type is unresolved cannot be driven (assigned) by more than one VHDL process while a signal which type is resolved can.
The use of resolved types should be reserved to situations where the intention is really to model a hardware wire (or set of wires) driven by more than one hardware circuit.</description>
    </item>
    
    <item>
      <title>Wait</title>
      <link>https://www.wikiod.com/vhdl/wait/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/wait/</guid>
      <description>Syntax # wait [on SIGNAL1[, SIGNAL2[&amp;hellip;]]] [until CONDITION] [for TIMEOUT]; wait; &amp;ndash; Eternal wait wait on s1, s2; &amp;ndash; Wait until signals s1 or s2 (or both) change wait until s1 = 15; &amp;ndash; Wait until signal s1 changes and its new value is 15 wait until s1 = 15 for 10 ns; &amp;ndash; Wait until signal s1 changes and its new value is 15 for at most 10 ns Wait until condition # It is possible to omit the on &amp;lt;sensitivity_list&amp;gt; and the for &amp;lt;timeout&amp;gt; clauses, like in:</description>
    </item>
    
    <item>
      <title>D-Flip-Flops (DFF) and latches</title>
      <link>https://www.wikiod.com/vhdl/d-flip-flops-dff-and-latches/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/d-flip-flops-dff-and-latches/</guid>
      <description>D-Flip-Flops (DFF) and latches are memory elements. A DFF samples its input on one or the other edge of its clock (not both) while a latch is transparent on one level of its enable and memorizing on the other. The following figure illustrates the difference:
Modelling DFFs or latches in VHDL is easy but there are a few important aspects that must be taken into account:
The differences between VHDL models of DFFs and latches.</description>
    </item>
    
    <item>
      <title>Static Timing Analysis - what does it mean when a design fails timing?</title>
      <link>https://www.wikiod.com/vhdl/static-timing-analysis---what-does-it-mean-when-a-design-fails-timing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/static-timing-analysis---what-does-it-mean-when-a-design-fails-timing/</guid>
      <description>What is timing? # The concept of timing is related more to the physics of flip flops than VHDL, but is an important concept that any designer using VHDL to create hardware should know.
When designing digital hardware, we are typically creating synchronous logic. This means our data travels from flip-flop to flip-flop, possibly with some combinatorial logic between them. The most basic diagram of synchronous logic that incorporates a combinatorial function is shown below:</description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>https://www.wikiod.com/vhdl/comments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/comments/</guid>
      <description>Any decent programming language supports comments. In VHDL they are especially important because understanding a VHDL code, even moderately sophisticated, is frequently challenging.
Single line comments # A single line comment starts with two hyphens (--) and extends up to the end of the line. Example :
-- This process models the state register process(clock, aresetn) begin if aresetn = &#39;0&#39; then -- Active low, asynchronous reset state &amp;lt;= IDLE; elsif rising_edge(clock) then -- Synchronized on the rising edge of the clock state &amp;lt;= next_state; end if; end process; Delimited comments # Starting with VHDL 2008, a comment can also extend on several lines.</description>
    </item>
    
    <item>
      <title>Memories</title>
      <link>https://www.wikiod.com/vhdl/memories/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/memories/</guid>
      <description>This covers single port and dual port memories.
Syntax # Memory type for constant width and depth.
type MEMORY_TYPE is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0); Memory type for variable depth and constant width.
type MEMORY_TYPE is array (natural range &amp;lt;&amp;gt;) of std_logic_vector(WIDTH-1 downto 0); Shift register # A shift register of generic length. With serial in and serial out.
library ieee; use ieee.std_logic_1164.all; use ieee.numeric_std.all; entity SHIFT_REG is generic( LENGTH: natural := 8 ); port( SHIFT_EN : in std_logic; SO : out std_logic; SI : in std_logic; clk : in std_logic; rst : in std_logic ); end entity SHIFT_REG; architecture Behavioral of SHIFT_REG is signal reg : std_logic_vector(LENGTH-1 downto 0) := (others =&amp;gt; &#39;0&#39;); begin main_process : process(clk) is begin if rising_edge(clk) then if rst = &#39;1&#39; then reg &amp;lt;= (others =&amp;gt; &#39;0&#39;); else if SHIFT_EN = &#39;1&#39; then --Shift reg &amp;lt;= reg(LENGTH-2 downto 0) &amp;amp; SI; else reg &amp;lt;= reg; end if; end if; end if; end process main_process; SO &amp;lt;= reg(LENGTH-1); end architecture Behavioral; For Parallel out,</description>
    </item>
    
    <item>
      <title>Literals</title>
      <link>https://www.wikiod.com/vhdl/literals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/vhdl/literals/</guid>
      <description>This has how to specify constants, called literals in VHDL
Numeric literals # 16#A8# -- hex 2#100# -- binary 2#1000_1001_1111_0000 -- long number, adding (optional) _ (one or more) for readability 1234 -- decimal Enumerated literal # type state_t is (START, READING, WRITING); -- user-defined enumerated type </description>
    </item>
    
  </channel>
</rss>
