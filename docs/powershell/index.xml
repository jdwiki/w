<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PowerShell Tutorial on </title>
    <link>https://www.wikiod.com/docs/powershell/</link>
    <description>Recent content in PowerShell Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/powershell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with PowerShell</title>
      <link>https://www.wikiod.com/powershell/getting-started-with-powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/getting-started-with-powershell/</guid>
      <description>Allow scripts stored on your machine to run un-signed # For security reasons, PowerShell is set up by default to only allow signed scripts to execute. Executing the following command will allow you to run unsigned scripts (you must run PowerShell as Administrator to do this).
Set-ExecutionPolicy RemoteSigned Another way to run PowerShell scripts is to use Bypass as ExecutionPolicy:
powershell.exe -ExecutionPolicy Bypass -File &amp;quot;c:\MyScript.ps1&amp;quot; Or from within your existing PowerShell console or ISE session by running:</description>
    </item>
    
    <item>
      <title>Switch statement</title>
      <link>https://www.wikiod.com/powershell/switch-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/switch-statement/</guid>
      <description>A switch statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each switch case. It enables you to write a script that can choose from a series of options, but without requiring you to write a long series of if statements.
This topic is documenting the switch statement used for branching the flow of the script.</description>
    </item>
    
    <item>
      <title>URL EncodeDecode</title>
      <link>https://www.wikiod.com/powershell/url-encodedecode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/url-encodedecode/</guid>
      <description>The regular expression used in the Decode URL examples was taken from RFC 2396, Appendix B: Parsing a URI Reference with a Regular Expression; for posterity, here&amp;rsquo;s a quote:
The following line is the regular expression for breaking-down a URI reference into its components.
^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))? 12 3 4 5 6 7 8 9 The numbers in the second line above are only to assist readability; they indicate the reference points for each subexpression (i.</description>
    </item>
    
    <item>
      <title>Loops</title>
      <link>https://www.wikiod.com/powershell/loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/loops/</guid>
      <description>A loop is a sequence of instruction(s) that is continually repeated until a certain condition is reached. Being able to have your program repeatedly execute a block of code is one of the most basic but useful tasks in programming. A loop lets you write a very simple statement to produce a significantly greater result simply by repetition. If the condition has been reached, the next instruction &amp;ldquo;falls through&amp;rdquo; to the next sequential instruction or branches outside the loop.</description>
    </item>
    
    <item>
      <title>Working with XML Files</title>
      <link>https://www.wikiod.com/powershell/working-with-xml-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/working-with-xml-files/</guid>
      <description>Accessing an XML File # &amp;lt;!-- file.xml --&amp;gt; &amp;lt;people&amp;gt; &amp;lt;person id=&amp;quot;101&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Jon Lajoie&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;22&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;person id=&amp;quot;102&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Lord Gaben&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;65&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;person id=&amp;quot;103&amp;quot;&amp;gt; &amp;lt;name&amp;gt;Gordon Freeman&amp;lt;/name&amp;gt; &amp;lt;age&amp;gt;29&amp;lt;/age&amp;gt; &amp;lt;/person&amp;gt; &amp;lt;/people&amp;gt; Loading an XML File
To load an XML file, you can use any of these:
# First Method $xdoc = New-Object System.Xml.XmlDocument $file = Resolve-Path(&amp;quot;.\file.xml&amp;quot;) $xdoc.load($file) # Second Method [xml] $xdoc = Get-Content &amp;quot;.\file.xml&amp;quot; # Third Method $xdoc = [xml] (Get-Content &amp;quot;.\file.xml&amp;quot;) Accessing XML as Objects</description>
    </item>
    
    <item>
      <title>Using ShouldProcess</title>
      <link>https://www.wikiod.com/powershell/using-shouldprocess/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/using-shouldprocess/</guid>
      <description>Syntax # $PSCmdlet.ShouldProcess(&amp;ldquo;Target&amp;rdquo;) $PSCmdlet.ShouldProcess(&amp;ldquo;Target&amp;rdquo;, &amp;ldquo;Action&amp;rdquo;) Parameters # Parameter Details Target The resource being changed. Action The operation being performed. Defaults to the name of the cmdlet. $PSCmdlet.ShouldProcess() will also automatically write a message to the verbose output.
PS&amp;gt; Invoke-MyCmdlet -Verbose VERBOSE: Performing the operation &amp;quot;Invoke-MyCmdlet&amp;quot; on target &amp;quot;Target of action&amp;quot; Full Usage Example # Other examples couldn&amp;rsquo;t clearly explain to me how to trigger the conditional logic.
This example also shows that underlying commands will also listen to the -Confirm flag!</description>
    </item>
    
    <item>
      <title>PowerShell Functions</title>
      <link>https://www.wikiod.com/powershell/powershell-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/powershell-functions/</guid>
      <description>A function is basically a named block of code. When you call the function name, the script block within that function runs. It is a list of PowerShell statements that has a name that you assign. When you run a function, you type the function name.It is a method of saving time when tackling repetitive tasks. PowerShell formats in three parts: the keyword &amp;lsquo;Function&amp;rsquo;, followed by a Name, finally, the payload containing the script block, which is enclosed by curly/parenthesis style bracket.</description>
    </item>
    
    <item>
      <title>TCP Communication with PowerShell</title>
      <link>https://www.wikiod.com/powershell/tcp-communication-with-powershell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/tcp-communication-with-powershell/</guid>
      <description>TCP listener # Function Receive-TCPMessage { Param ( [Parameter(Mandatory=$true, Position=0)] [ValidateNotNullOrEmpty()] [int] $Port ) Process { Try { # Set up endpoint and start listening $endpoint = new-object System.Net.IPEndPoint([ipaddress]::any,$port) $listener = new-object System.Net.Sockets.TcpListener $EndPoint $listener.start() # Wait for an incoming connection $data = $listener.AcceptTcpClient() # Stream setup $stream = $data.GetStream() $bytes = New-Object System.Byte[] 1024 # Read data from stream and write it to host while (($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){ $EncodedText = New-Object System.</description>
    </item>
    
    <item>
      <title>Handling Secrets and Credentials</title>
      <link>https://www.wikiod.com/powershell/handling-secrets-and-credentials/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/handling-secrets-and-credentials/</guid>
      <description>In Powershell, to avoid storing the password in clear text we use different methods of encryption and store it as secure string. When you are not specifying a key or securekey, this will only work for the same user on the same computer will be able to decrypt the encrypted string if youâ€™re not using Keys/SecureKeys. Any process that runs under that same user account will be able to decrypt that encrypted string on that same machine.</description>
    </item>
    
    <item>
      <title>PowerShell.exe Command-Line</title>
      <link>https://www.wikiod.com/powershell/powershellexe-command-line/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/powershell/powershellexe-command-line/</guid>
      <description>Parameters # Parameter Description -Help | -? | /? Shows the help -File &amp;lt;FilePath&amp;gt; [&amp;lt;Args&amp;gt;] Path to script-file that should be executed and arguments (optional) -Command { - | &amp;lt;script-block&amp;gt; [-args &amp;lt;arg-array&amp;gt;] | &amp;lt;string&amp;gt; [&amp;lt;CommandParameters&amp;gt;] } Commands to be executed followed by arguments -EncodedCommand &amp;lt;Base64EncodedCommand&amp;gt; Base64 encoded commands -ExecutionPolicy &amp;lt;ExecutionPolicy&amp;gt; Sets the execution policy for this process only -InputFormat { Text | XML} Sets input format for data sent to process.</description>
    </item>
    
  </channel>
</rss>
