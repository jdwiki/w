<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data-structures Tutorial on </title>
    <link>https://www.wikiod.com/docs/data-structures/</link>
    <description>Recent content in data-structures Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/data-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with data-structures</title>
      <link>https://www.wikiod.com/data-structures/getting-started-with-data-structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/getting-started-with-data-structures/</guid>
      <description>Intro to Data Structures # A data structure is a way of organizing and storing information.
Let a &amp;ldquo;Hello, World!&amp;rdquo; string be the information that we need to organize and store in byte-addressable memory.
Each ASCII character requires 7 bits of storage. Most systems reserve 8 bits (1 byte) for each character, so each character in &amp;ldquo;Hello, World!&amp;rdquo; is stored in an individual byte-sized unit of memory, one after another, consecutively.</description>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://www.wikiod.com/data-structures/linked-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/linked-list/</guid>
      <description>XOR Linked List # A XOR Linked list is also called a Memory-Efficient Linked List. It is another form of a doubly linked list. This is highly dependent on the XOR logic gate and its properties.
Why is this called the Memory-Efficient Linked List? This is called so because this uses less memory than a traditional doubly linked list.
Is this different from a Doubly Linked List?
Yes, it is.</description>
    </item>
    
    <item>
      <title>Trie (Prefix TreeRadix Tree)</title>
      <link>https://www.wikiod.com/data-structures/trie-prefix-treeradix-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/trie-prefix-treeradix-tree/</guid>
      <description>Introduction To Trie # Have you ever wondered how the search engines work? How does Google line-up millions of results in front of you in just a few milliseconds? How does a huge database situated thousands of miles away from you find out information you&amp;rsquo;re searching for and send them back to you? The reason behind this is not possible only by using faster internet and super-computers. Some mesmerizing searching algorithms and data-structures work behind it.</description>
    </item>
    
    <item>
      <title>Binary Search Tree</title>
      <link>https://www.wikiod.com/data-structures/binary-search-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/binary-search-tree/</guid>
      <description>Creating a Node in BST # The Binary Search Tree (BST) is a hierarchical data structure with a single pointer to the root node.
The Node in the BST generally contains &amp;ldquo;items&amp;rdquo; (such as numbers or names) for fast look up. Each node has at-most two children (left and right). Every node is organized by some key data field. For every node in BST its key is greater than left child&amp;rsquo;s key and less than right child&amp;rsquo;s key</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>https://www.wikiod.com/data-structures/stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/stack/</guid>
      <description>Intro to Stack # The stack is a LIFO (last-in, first-out) data-structure, i.e. the most recent (or &amp;ldquo;last in&amp;rdquo;) element added to the stack will be the first element removed (&amp;ldquo;first out&amp;rdquo;).
Let us consider the example of books in a box. Only one book can be added or removed from from the box at a time, and it can only be added and removed from the top.
Now, the box with the first two books looks like this:</description>
    </item>
    
    <item>
      <title>Queue</title>
      <link>https://www.wikiod.com/data-structures/queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/queue/</guid>
      <description>Intro to Queue # The queue is a FIFO (first-in, first-out) data-structure, i.e. the first element added to the queue will be the first element removed (&amp;ldquo;first out&amp;rdquo;).
Let us consider the example of customers waiting to be helped. Alice, Bob, and Dan are all at the supermarket. Alice is ready to pay, so she approaches the cashier. Alice is now in the queue. She is the only person in the queue, so she is both at the front and at the back.</description>
    </item>
    
    <item>
      <title>Segment Tree</title>
      <link>https://www.wikiod.com/data-structures/segment-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/segment-tree/</guid>
      <description>Introduction To Segment Tree # Suppose we have an array:
+-------+-----+-----+-----+-----+-----+-----+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | +-------+-----+-----+-----+-----+-----+-----+ | Value | -1 | 3 | 4 | 0 | 2 | 1 | +-------+-----+-----+-----+-----+-----+-----+ We want to perform some query on this array. For example:
What is the minimum from index-2 to index-4? -&amp;gt; 0 What is the maximum from index-0 to index-3?</description>
    </item>
    
    <item>
      <title>Graph traversals</title>
      <link>https://www.wikiod.com/data-structures/graph-traversals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/graph-traversals/</guid>
      <description>All the algorithms related to Graph traversals. Their complexities, both runtime and space
Depth First Search # Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array.
Below algorithm presents the steps for graph traversal using DFS:</description>
    </item>
    
    <item>
      <title>Deque(Double ended queue)</title>
      <link>https://www.wikiod.com/data-structures/dequedouble-ended-queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/dequedouble-ended-queue/</guid>
      <description>Insertion and Deletion from both front and end of the Queue # </description>
    </item>
    
    <item>
      <title>Matrices</title>
      <link>https://www.wikiod.com/data-structures/matrices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/data-structures/matrices/</guid>
      <description>This article aims to explain what a matrix is and how to use it.
Intro to matrices # Matrices are essentially two-dimensional arrays.
That means that it associates (i, j) coordinates, where i is the row and j is the column, to a value.
So, you could have :
m3, 4 = &amp;ldquo;Hello&amp;rdquo;
The easiest implementation is to make an array or arrays. In python, that would go as follows.</description>
    </item>
    
  </channel>
</rss>
