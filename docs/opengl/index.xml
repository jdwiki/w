<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>opengl Tutorial on </title>
    <link>https://www.wikiod.com/docs/opengl/</link>
    <description>Recent content in opengl Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/opengl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with opengl</title>
      <link>https://www.wikiod.com/opengl/getting-started-with-opengl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/getting-started-with-opengl/</guid>
      <description>Manual OpenGL setup on Windows # Full example code included at the end
Windows components for OpenGL WGL WGL (can be pronounced wiggle) stands for &amp;ldquo;Windows-GL&amp;rdquo;, as in &amp;ldquo;an interface between Windows and OpenGL&amp;rdquo; - a set of functions from the Windows API to communicate with OpenGL. WGL functions have a wgl prefix and its tokens have a WGL_ prefix.
Default OpenGL version supported on Microsoft systems is 1.1. That is a very old version (most recent one is 4.</description>
    </item>
    
    <item>
      <title>Texturing</title>
      <link>https://www.wikiod.com/opengl/texturing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/texturing/</guid>
      <description>Basics of texturing # A texture is a form of data storage that allows convenient access not just to particular data entries, but also to sample points mixing (interpolating) multiple entries together.
In OpenGL textures can be used for many things, but most commonly it&amp;rsquo;s mapping an image to a polygon (for example a triangle). In order to map the texture to a triangle (or another polygon) we have to tell each vertex which part of the texture it corresponds to.</description>
    </item>
    
    <item>
      <title>Encapsulating OpenGL objects with C&#43;&#43; RAII</title>
      <link>https://www.wikiod.com/opengl/encapsulating-opengl-objects-with-c-raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/encapsulating-opengl-objects-with-c-raii/</guid>
      <description>Examples of various ways to have OpenGL objects work with C++ RAII.
RAII encapsulation of OpenGL objects has dangers. The most unavoidable is that OpenGL objects are associated with the OpenGL context that created them. So the destruction of a C++ RAII object must be done in a OpenGL context which shares ownership of the OpenGL object managed by that C++ object.
This also means that if all contexts which own the object are destroyed, then any existing RAII encapsulated OpenGL objects will try to destroy objects which no longer exist.</description>
    </item>
    
    <item>
      <title>3d Math</title>
      <link>https://www.wikiod.com/opengl/3d-math/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/3d-math/</guid>
      <description>Introduction to matrices # When you are programming in OpenGL or any other graphics api you will hit a brick wall when you are not that good in math. Here I will explain with example code how you can achieve movement/scaling and many other cool stuff with your 3d object.
Let&amp;rsquo;s take a real life case&amp;hellip; You&amp;rsquo;ve made a awesome (three dimensional) cube in OpenGL and you want to move it to any direction.</description>
    </item>
    
    <item>
      <title>Basic Lighting</title>
      <link>https://www.wikiod.com/opengl/basic-lighting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/basic-lighting/</guid>
      <description>Phong Lighting Model # NOTE: This example is WIP, it will be updated with diagrams, images, more examples, etc.
What is Phong?
Phong is a very basic, but real looking light model for surfaces that has three parts: ambient, diffuse, and specular lighting.
Ambient Lighting:
Ambient lighting is the simplest of the three parts to understand and calculate. Ambient lighting is light that floods the scene and lights up the object evenly in all directions.</description>
    </item>
    
    <item>
      <title>Shaders</title>
      <link>https://www.wikiod.com/opengl/shaders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/shaders/</guid>
      <description>Syntax # #version version_number // Which GLSL version we are using void main() { /* Code */ } // Shader&amp;rsquo;s main function in type name; // Specifies an input parameter - GLSL 1.30 out type name; // Specifies an output parameter - GLSL 1.30 inout type name; // Parameter for both input and output - GLSL 1.30 Parameters # Parameter Details type The parameter&amp;rsquo;s type, it has to be a GLSL built-in type.</description>
    </item>
    
    <item>
      <title>Shader Loading and Compilation</title>
      <link>https://www.wikiod.com/opengl/shader-loading-and-compilation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/shader-loading-and-compilation/</guid>
      <description>These examples demonstrate various ways to load and compile shaders. All examples must include error handling code.
Shader objects, as created from glCreateShader do not do much. They contain the compiled code for a single stage, but they do not even have to contain the complete compiled code for that stage. In many ways, they work like C and C++ object files.
Program objects contain the final linked program. But they also hold the state for the program&amp;rsquo;s uniform values, as well as a number of other state data.</description>
    </item>
    
    <item>
      <title>OGL view and projection</title>
      <link>https://www.wikiod.com/opengl/ogl-view-and-projection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/ogl-view-and-projection/</guid>
      <description>About model matrix, view matrix, orthographic- and perspective projection
Implement a camera in OGL 4.0 GLSL 400 # If we want to look at a scene as if we had photographed it with a camera, we must first define some things:
The position from which the scene is viewed, the eye position pos. The point we look at in the scene (target). It is also common to define the direction in which we look.</description>
    </item>
    
    <item>
      <title>Framebuffers</title>
      <link>https://www.wikiod.com/opengl/framebuffers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/framebuffers/</guid>
      <description>Basics of framebuffers # Framebuffer is a type of buffer which stores color values, depth and stencil information of pixels in memory. When you draw something in OpenGL the output is stored in the default framebuffer and then you actually see the color values of this buffer on screen. You can also make your own framebuffer which can be used for a lot of cool post-processing effects such as gray-scale, blur, depth of field, distortions, reflections&amp;hellip;</description>
    </item>
    
    <item>
      <title>Using VAOs</title>
      <link>https://www.wikiod.com/opengl/using-vaos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opengl/using-vaos/</guid>
      <description>The Vertex Array Object stores how opengl should interpret a set of VBOs.
In essence it will let you avoid calling glVertexAttribPointer every time you want to render a new mesh.
If you don&amp;rsquo;t want to deal with VAOs you can simply create one and bind it during program initialization and pretend they don&amp;rsquo;t exist.
Syntax # void glEnableVertexAttribArray​(GLuint attribIndex);
void glDisableVertexAttribArray​(GLuint attribIndex);
void glVertexAttribPointer(GLuint attribIndex, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);</description>
    </item>
    
  </channel>
</rss>
