<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fortran Tutorial on </title>
    <link>https://www.wikiod.com/docs/fortran/</link>
    <description>Recent content in Fortran Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/fortran/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Fortran</title>
      <link>https://www.wikiod.com/fortran/getting-started-with-fortran/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/getting-started-with-fortran/</guid>
      <description>Hello, world # Any Fortran program has to include end as last statement. Therefore, the simplest Fortran program looks like this:
end Here are some examples of &amp;ldquo;hello, world&amp;rdquo; programs:
print *, &amp;quot;Hello, world&amp;quot; end With write statement:
write(*,*) &amp;quot;Hello, world&amp;quot; end For clarity it is now common to use the program statement to start a program and give it a name. The end statement can then refer to this name to make it obvious what it is referring to, and let the compiler check the code for correctness.</description>
    </item>
    
    <item>
      <title>Arrays</title>
      <link>https://www.wikiod.com/fortran/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/arrays/</guid>
      <description>Array constructors # A rank-1 array value can be created using an array constructor, with the syntax
(/ ... /) [ ... ] The form [...] was introduced in Fortran 2003 and is generally regarded as clearer to read, especially in complex expressions. This form is used exclusively in this example.
The values featuring in an array constructor may be scalar values, array values, or implied-do loops.
The type and type parameters of the constructed array match those of the values in the array constructor</description>
    </item>
    
    <item>
      <title>Data Types</title>
      <link>https://www.wikiod.com/fortran/data-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/data-types/</guid>
      <description>Precision of floating point numbers # Floating point numbers of type real cannot have any real value. They can represent real numbers up to certain amount of decimal digits.
FORTRAN 77 guaranteed two floating point types and more recent standards guarantee at least two real types. Real variables may be declared as
real x double precision y x here is a real of default kind and y is a real of kind with greater decimal precision than x.</description>
    </item>
    
    <item>
      <title>Object Oriented Programming</title>
      <link>https://www.wikiod.com/fortran/object-oriented-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/object-oriented-programming/</guid>
      <description>Derived type definition # Fortran 2003 introduced support for object oriented programming. This feature allows to take advantage of modern programming techniques. Derived types are defined with the following form:
TYPE [[, attr-list] :: ] name [(name-list)] [def-stmts] [PRIVATE statement or SEQUENCE statement]. . . [component-definition]. . . [procedure-part] END TYPE [name] where,
attr-list - a list of attribute specifiers name - the name of derived data type name-list - a list of type parameter names separated by commas def-stmts - one or more INTEGER declarations of the type parameters named in the name-list component-definition - one or more type declaration statements or procedure pointer statements defining the component of derived type procedure-part - a CONTAINS statement, optionally followed by a PRIVATE statement, and one or more procedure binding statements Example:</description>
    </item>
    
    <item>
      <title>Modern alternatives to historical features</title>
      <link>https://www.wikiod.com/fortran/modern-alternatives-to-historical-features/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/modern-alternatives-to-historical-features/</guid>
      <description>Arithmetic if statement # Arithmetic if statement allows one to use three branches depending on the result of an arithmetic expression
if (arith_expr) label1, label2, label3 This if statement transfers control flow to one of the labels in a code. If the result of arith_expr is negative label1 is involved, if the result is zero label2 is used, and if the result is positive last label3 is applied. Arithmetic if requires all three labels but it allows the re-use of labels, therefore this statement can be simplified to a two branch if.</description>
    </item>
    
    <item>
      <title>Program units and file layout</title>
      <link>https://www.wikiod.com/fortran/program-units-and-file-layout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/program-units-and-file-layout/</guid>
      <description>Internal subprograms # A program unit which is not an internal subprogram may contain other program units, called internal subprograms.
program prog implicit none contains function f() end function f subroutine g() end subroutine g end program Such an internal subprogram has a number of features:
there is host association between entities in the subprogram and the outer program implicit typing rules are inherited (implicit none is in effect in f above) internal subprograms have an explicit interface available in the host Module subprograms and external subprograms may have internal subprograms, such as</description>
    </item>
    
    <item>
      <title>Procedures - Functions and Subroutines</title>
      <link>https://www.wikiod.com/fortran/procedures---functions-and-subroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/procedures---functions-and-subroutines/</guid>
      <description>Functions and subroutines, in conjunction with modules, are the tools to break down a program into units. This makes the program more readable and manageable. Each one of these units can be thought of as part of the code that, ideally, could be compiled and tested in isolation. The main program(s) can call (or invoke) such subprograms (functions or subroutines) to accomplish a task.
Functions and subroutines are different in the following sense:</description>
    </item>
    
    <item>
      <title>Usage of Modules</title>
      <link>https://www.wikiod.com/fortran/usage-of-modules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/usage-of-modules/</guid>
      <description>Module syntax # Module is a collection of type declarations, data declarations and procedures. The basic syntax is:
module module_name use other_module_being_used ! The use of implicit none here will set it for the scope of the module. ! Therefore, it is not required (although considered good practice) to repeat ! it in the contained subprograms. implicit none ! Parameters declaration real, parameter, public :: pi = 3.14159 ! The keyword private limits access to e parameter only for this module real, parameter, private :: e = 2.</description>
    </item>
    
    <item>
      <title>Explicit and implicit interfaces</title>
      <link>https://www.wikiod.com/fortran/explicit-and-implicit-interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/explicit-and-implicit-interfaces/</guid>
      <description>External subprograms and implicit interfaces # A subprogram is said to be external when it is not contained in the main program, nor in a module or antoher subprogram. In particular it can be defined by means of a programming language other than Fortran.
When an external subprogram is invoked, the compiler cannot access to its code, so all the information allowable to the compiler is implicitly contained in the calling statement of the calling program and in the type an properties of the acutal arguments, not the dummy arguments (whose declaration is unknown to the compiler).</description>
    </item>
    
    <item>
      <title>Execution Control</title>
      <link>https://www.wikiod.com/fortran/execution-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/fortran/execution-control/</guid>
      <description>If construct # The if construct (called a block IF statement in FORTRAN 77) is common across many programming languages. It conditionally executes one block of code when a logical expression is evaluated to true.
[name:] IF (expr) THEN block [ELSE IF (expr) THEN [name] block] [ELSE [name] block] END IF [name] where,
name - the name of the if construct (optional) expr - a scalar logical expression enclosed in parentheses block - a sequence of zero or more statements or constructs A construct name at the beginning of an if then statement must have the same value as the construct name at the end if statement, and it should be unique for the current scoping unit.</description>
    </item>
    
  </channel>
</rss>
