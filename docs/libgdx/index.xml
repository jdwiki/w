<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>libgdx Tutorial on </title>
    <link>https://www.wikiod.com/docs/libgdx/</link>
    <description>Recent content in libgdx Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/libgdx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with libgdx</title>
      <link>https://www.wikiod.com/libgdx/getting-started-with-libgdx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/getting-started-with-libgdx/</guid>
      <description>Installation or Setup # LibGDX has a fairly simple setup, with the help of a simple Java program. You can find the download here. When you startup the application, it will look something like this: Note: This screenshot have been taken on Linux and shows path that differs from a Windows installation. However, the form is the same on any OS compatible with this setup application
Input boxes # In the &amp;ldquo;Name&amp;rdquo; input box, is the name of the game for your project.</description>
    </item>
    
    <item>
      <title>Ashley Entity System</title>
      <link>https://www.wikiod.com/libgdx/ashley-entity-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/ashley-entity-system/</guid>
      <description>Ashley Entity System is an Entity System library that&amp;rsquo;s managed under the LibGDX organization and is and well-suited for game development. It depends on LibGDX utility classes, but can be used with other Java game frameworks not based on LibGDX with some work.
Entity systems provide a different way to manage data and functionality towards large sets of objects without having to make the object classes rich with inheritance.
Utilizing Ashley might be a helpful approach for those looking for an object modeling approach like Unity provides, but with the scope of a framework instead of game engine.</description>
    </item>
    
    <item>
      <title>Moving actors on path with constant speed</title>
      <link>https://www.wikiod.com/libgdx/moving-actors-on-path-with-constant-speed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/moving-actors-on-path-with-constant-speed/</guid>
      <description>Simple movement between two locations # For this the best solution is using actions. To add a new action to an actors in Scene2D just call:
Action action = Actions.moveTo(x,y,duration); actorObject.addAction(action); Where x and y is the target location and duration is the speed of this movement in seconds(float).
If you want to stop this action(and the actor by it) you can do it by calling:
actorObject.removeAction(action); or you can remove all actions by calling:</description>
    </item>
    
    <item>
      <title>Supporting Multiple Resolutions</title>
      <link>https://www.wikiod.com/libgdx/supporting-multiple-resolutions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/supporting-multiple-resolutions/</guid>
      <description>Viewports # To support multiple resolutions and aspect ratios Libgdx uses the so called Viewports.
There are a few types of Viewports which use different strategies to handle multiple resolutions and aspect ratios.
A Viewport uses a Camera under the hood and manages it&amp;rsquo;s viewportHeight and viewportWidth. You can optionally give the Viewport a Camera in it&amp;rsquo;s constructor, otherwise it will use an OrthographicCamera by default:
private Viewport viewport; private Camera camera; public void create() { camera = new PerspectiveCamera(); viewport = new FitViewport(8f, 4.</description>
    </item>
    
    <item>
      <title>Box2D</title>
      <link>https://www.wikiod.com/libgdx/box2d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/box2d/</guid>
      <description>Create Box2D Bodies from Tiled Map # The objects created within a Tiled Map (.tmx), can be simply loaded as bodies into a Box2D world using the Libgdx MapObject class as following:
public void buildBuildingsBodies(TiledMap tiledMap, World world, String layer){ MapObjects objects = tiledMap.getLayers().get(layer).getObjects(); for (MapObject object: objects) { Rectangle rectangle = ((RectangleMapObject)object).getRectangle(); //create a dynamic within the world body (also can be KinematicBody or StaticBody BodyDef bodyDef = new BodyDef(); bodyDef.</description>
    </item>
    
    <item>
      <title>Life-cycle</title>
      <link>https://www.wikiod.com/libgdx/life-cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/libgdx/life-cycle/</guid>
      <description>Create # This method is called once when the Application is started. In this method resources should be loaded and variables should be initialized.
Render # The method is called every frame, and is used to display whatever needs to be displayed. It is also used to update any variables/classes that may need to be updated, such as a camera.
Dispose # This method is called when the application is destroyed, and is used to free any resources, for examples Textures or the SpriteBatch.</description>
    </item>
    
  </channel>
</rss>
