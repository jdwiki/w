<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Regular Expressions Tutorial on </title>
    <link>https://www.wikiod.com/docs/regex/</link>
    <description>Recent content in Regular Expressions Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/regex/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Regular Expressions</title>
      <link>https://www.wikiod.com/regex/getting-started-with-regular-expressions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/getting-started-with-regular-expressions/</guid>
      <description>Character Guide # Note that some syntax elements have different behavior depending on the expression.
Syntax Description ? Match the preceding character or subexpression 0 or 1 times. Also used for non-capturing groups, and named capturing groups. * Match the preceding character or subexpression 0 or more times. + Match the preceding character or subexpression 1 or more times. {n} Match the preceding character or subexpression exactly n times. {min,} Match the preceding character or subexpression min or more times.</description>
    </item>
    
    <item>
      <title>Anchor Characters Caret (^)</title>
      <link>https://www.wikiod.com/regex/anchor-characters-caret/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/anchor-characters-caret/</guid>
      <description>Terminology
The Caret (^) character is also referred to by the following terms:
hat control uparrow chevron circumflex accent Usage
It has two uses in regular expressions:
To denote the start of the line If used immediately after a square bracket ([^) it acts to negate the set of allowed characters (i.e. [123] means the character 1, 2, or 3 is allowed, whilst the statement [^123] means any character other than 1, 2, or 3 is allowed.</description>
    </item>
    
    <item>
      <title>Greedy and Lazy quantifiers</title>
      <link>https://www.wikiod.com/regex/greedy-and-lazy-quantifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/greedy-and-lazy-quantifiers/</guid>
      <description>Parameters # Quantifiers Description ? Match the preceding character or subexpression 0 or 1 times (preferably 1). * Match the preceding character or subexpression 0 or more times (as many as possible). + Match the preceding character or subexpression 1 or more times (as many as possible). {n} Match the preceding character or subexpression exactly n times. {min,} Match the preceding character or subexpression min or more times (as many as possible).</description>
    </item>
    
    <item>
      <title>Lookahead and Lookbehind</title>
      <link>https://www.wikiod.com/regex/lookahead-and-lookbehind/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/lookahead-and-lookbehind/</guid>
      <description>Syntax # Positive lookahead: (?=pattern) Negative lookahead: (?!pattern) Positive lookbehind: (?&amp;lt;=pattern) Negative lookbehind: (?&amp;lt;!pattern) Not supported by all regex engines.
Additionally, many regex engines limit the patterns inside lookbehinds to fixed-length strings. For example the pattern (?&amp;lt;=a+)b should match the b in aaab but throws an error in Python.
Capturing groups are allowed and work as expected, including backreferences. The lookahead/lookbehind itself is not a capturing group, however.
Basics # A positive lookahead (?</description>
    </item>
    
    <item>
      <title>Regex modifiers (flags)</title>
      <link>https://www.wikiod.com/regex/regex-modifiers-flags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/regex-modifiers-flags/</guid>
      <description>Regular expression patterns are often used with modifiers (also called flags) that redefine regex behavior. Regex modifiers can be regular (e.g. /abc/i) and inline (or embedded) (e.g. (?i)abc). The most common modifiers are global, case-insensitive, multiline and dotall modifiers. However, regex flavors differ in the number of supported regex modifiers and their types.
PCRE Modifiers Modifier Inline Description PCRE_CASELESS (?i) Case insensitive match PCRE_MULTILINE (?m) Multiple line matching PCRE_DOTALL (?s) .</description>
    </item>
    
    <item>
      <title>Capture Groups</title>
      <link>https://www.wikiod.com/regex/capture-groups/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/capture-groups/</guid>
      <description>Basic Capture Groups # A group is a section of a regular expression enclosed in parentheses (). This is commonly called &amp;ldquo;sub-expression&amp;rdquo; and serves two purposes:
It makes the sub-expression atomic, i.e. it will either match, fail or repeat as a whole. The portion of text it matched is accessible in the remainder of the expression and the rest of the program. Groups are numbered in regex engines, starting with 1.</description>
    </item>
    
    <item>
      <title>Character classes</title>
      <link>https://www.wikiod.com/regex/character-classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/character-classes/</guid>
      <description>Simple classes # Regex Matches [abc] Any of the following characters: a, b, or c [a-z] Any character from a to z, inclusive (this is called a range) [0-9] Any digit from 0 to 9, inclusive Common classes # Some groups/ranges of characters are so often used, they have special abbreviations:
Regex Matches \w Alphanumeric characters plus the underscore (also referred to as &amp;ldquo;word characters&amp;rdquo;) \W Non-word characters (same as [^\w]) \d Digits (wider than [0-9] since include Persian digits, Indian ones etc.</description>
    </item>
    
    <item>
      <title>Word Boundary</title>
      <link>https://www.wikiod.com/regex/word-boundary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/word-boundary/</guid>
      <description>Syntax # POSIX style, end of word: [[:&amp;gt;:]] POSIX style, start of word: [[:&amp;lt;:]] POSIX style, word boundary: [[:&amp;lt;:][:&amp;gt;:]] SVR4/GNU, end of word: \&amp;gt; SVR4/GNU, start of word: \&amp;lt; Perl/GNU, word boundary: \b Tcl, end of word: \M Tcl, start of word: \m Tcl, word boundary: \y Portable ERE, start of word: (^|[^[:alnum:]_]) Portable ERE, end of word: ([^[:alnum:]_]|$) Additional Resources # POSIX chapter on regular expressions
Perl regular expression documentation</description>
    </item>
    
    <item>
      <title>Match Reset K</title>
      <link>https://www.wikiod.com/regex/match-reset-k/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/match-reset-k/</guid>
      <description>Regex101 defines \K functionality as:
\K resets the starting point of the reported match. Any previously consumed characters are no longer included in the final match
The \K escape sequence is supported by several engines, languages or tools, such as:
boost (since ???) grep -P ‚Üê uses PCRE Oniguruma (since 5.13.3) PCRE (since 7.2) Perl (since 5.10.0) PHP (since 5.2.4) Ruby (since 2.0.0) &amp;hellip;and (so far) not supported by:
.NET awk bash GNU ICU Java Javascript Notepad++ Objective-C POSIX Python Qt/QRegExp sed Tcl vim XML XPath Search and replace using \K operator # Given the text:</description>
    </item>
    
    <item>
      <title>Useful Regex Showcase</title>
      <link>https://www.wikiod.com/regex/useful-regex-showcase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/regex/useful-regex-showcase/</guid>
      <description>Match an email address # Matching an email address within a string is a hard task, because the specification defining it, the RFC2822, is complex making it hard to implement as a regex. For more details why it is not a good idea to match an email with a regex, please refer to the antipattern example when not to use a regex: for matching emails. The best advice to note from that page is to use a peer reviewed and widely library in your favorite language to implement this.</description>
    </item>
    
  </channel>
</rss>
