<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cobol Tutorial on </title>
    <link>https://www.wikiod.com/docs/cobol/</link>
    <description>Recent content in cobol Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/cobol/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with cobol</title>
      <link>https://www.wikiod.com/cobol/getting-started-with-cobol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/getting-started-with-cobol/</guid>
      <description>Hello, world # HELLO * HISTORIC EXAMPLE OF HELLO WORLD IN COBOL IDENTIFICATION DIVISION. PROGRAM-ID. HELLO. PROCEDURE DIVISION. DISPLAY &amp;quot;HELLO, WORLD&amp;quot;. STOP RUN. The days of punch card layout and uppercase only inputs are far behind. Yet most COBOL implementations still handle the same code layout. Even current implementations follow the same (often even in uppercase,) compiled and in production.
A well-formatted modern implementation might look like:
*&amp;gt; Hello, world identification division.</description>
    </item>
    
    <item>
      <title>CALL statement</title>
      <link>https://www.wikiod.com/cobol/call-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/call-statement/</guid>
      <description>The COBOL CALL statement provides access to compiled library routines.
CALL statement # COBOL can use static linkage for the following statement. GnuCOBOL uses dynamic linkage by default for all external symbols known at compile time, even when the symbol is a literal:
CALL &amp;quot;subprogram&amp;quot; USING a b c *&amp;gt; run a (possibly static linked) sub program *&amp;gt; passing three fields CALL some-prog USING a b c *&amp;gt; some-prog is a PIC X item and can be changed *&amp;gt; at run-time to do a dynamic lookup This statement forces compile time link edit resolution.</description>
    </item>
    
    <item>
      <title>GnuCOBOL installation with GNULinux</title>
      <link>https://www.wikiod.com/cobol/gnucobol-installation-with-gnulinux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/gnucobol-installation-with-gnulinux/</guid>
      <description>GNU/Linux install # For most GNU/Linux distributions, a version of GnuCOBOL is available in the repositories. GnuCOBOL was originally OpenCOBOL, rebranded when the project became an official GNU project. Many repositories are still using open-cobol as the package name (as of August 2016).
For Fedora, and other RPM based package managers
sudo yum install open-cobol For Debian, Ubuntu and APT based packages
sudo apt install open-cobol This is usually version 1.</description>
    </item>
    
    <item>
      <title>ALTER statement</title>
      <link>https://www.wikiod.com/cobol/alter-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/alter-statement/</guid>
      <description>The much beloved ALTER statement. Changes the target of a GO TO paragraph.
No longer part of the COBOL standard, still supported by many compilers for reasons of backward compatibility. (The syntax diagram is dimmed to show that this is no longer standard COBOL).
A contrived example using ALTER # identification division. program-id. altering. date-written. 2015-10-28/06:36-0400. remarks. Demonstrate ALTER. procedure division. main section. *&amp;gt; And now for some altering. contrived. ALTER story TO PROCEED TO beginning GO TO story .</description>
    </item>
    
    <item>
      <title>ACCEPT statement</title>
      <link>https://www.wikiod.com/cobol/accept-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/accept-statement/</guid>
      <description>The COBOL ACCEPT statement is used to retrieve data from the system.
ACCEPT statement # ACCEPT variable. ACCEPT variable FROM CONSOLE. ACCEPT variable FROM ENVIRONMENT &amp;quot;path&amp;quot;. ACCEPT variable FROM COMMAND-LINE. ACCEPT variable FROM ARGUMENT-NUMBER ACCEPT variable FROM ARGUMENT-VALUE ACCEPT variable AT 0101. ACCEPT screen-variable. ACCEPT today FROM DATE. ACCEPT today FROM DATE YYYYMMDD. ACCEPT thetime FROM TIME. ACCEPT theday FROM DAY. ACCEPT theday FROM DAY YYYYDDD. ACCEPT weekday FROM DAY-OF-WEEK. ACCEPT thekey FROM ESCAPE KEY.</description>
    </item>
    
    <item>
      <title>EXIT statement</title>
      <link>https://www.wikiod.com/cobol/exit-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/exit-statement/</guid>
      <description>The COBOL EXIT statement is a terminating flow control verb.
EXIT comes is a few flavours:
bare EXIT is a common end point for a series of procedures. EXIT PARAGRAPH, EXIT SECTION provides a means of exiting a structured procedure without executing any of the subsequent statements. EXIT FUNCTION, EXIT METHOD, EXIT PROGRAM marks the logical end of a module of code. EXIT PERFORM breaks out of a inline perform loop.</description>
    </item>
    
    <item>
      <title>START statement</title>
      <link>https://www.wikiod.com/cobol/start-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/start-statement/</guid>
      <description>The START statement provides a way to position a read in a file for subsequent sequential retrieval (by key).
The key relational can include (but is not limited to):
KEY IS GREATER THAN
KEY IS &amp;gt;
KEY IS LESS THAN
KEY IS &amp;lt;
KEY IS EQUAL TO
KEY IS =
KEY IS NOT GREATER THAN
KEY IS NOT &amp;gt;
KEY IS NOT LESS THAN
KEY IS NOT &amp;lt;
KEY IS NOT EQUAL TO</description>
    </item>
    
    <item>
      <title>WRITE statement</title>
      <link>https://www.wikiod.com/cobol/write-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/write-statement/</guid>
      <description>The WRITE statement releases logical records to an output or input-output storage resource, and for logical positioning of lines within a logical page.
WRITE sequential
WRITE random
WRITE examples # WRITE record-buff WRITE indexed-record WITH LOCK ON INVALID KEY DISPLAY &amp;quot;Key exists, REWRITING...&amp;quot; END-DISPLAY PERFORM rewrite-key END-WRITE IF indexed-file-status NOT EQUAL ZERO THEN DISPLAY &amp;quot;Write problem: &amp;quot; indexed-file-status UPON SYSERR END-DISPLAY PERFORM evasive-manoeuvres END-IF WRITE record-name-1 AFTER ADVANCING PAGE WRITE record-name-1 FROM header-record-1 AFTER ADVANCING 2 LINES AT END-OF-PAGE PERFORM write-page-header PERFORM write-last-detail-reminder END-WRITE </description>
    </item>
    
    <item>
      <title>CONTINUE statement</title>
      <link>https://www.wikiod.com/cobol/continue-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/continue-statement/</guid>
      <description>The CONTINUE statement causes the flow of control to continue at the next statement. Not quite a no-op, as it can influence control flow when inside compound statement sequences, in particular IF/THEN/ELSE.
A handy? example is during early development and building with and without debugging aids.
CALL &amp;quot;CBL_OC_DUMP&amp;quot; USING structure ON EXCEPTION CONTINUE END-CALL That code, while expensive, will allow for formatted memory dumps when the module CBL_OC_DUMP is linked into the executable, but will harmlessly fail when it is not.</description>
    </item>
    
    <item>
      <title>Intrinsic Functions</title>
      <link>https://www.wikiod.com/cobol/intrinsic-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/cobol/intrinsic-functions/</guid>
      <description>Intrinsic Functions are included in the COBOL standard as a set of functions that return values from a specific algorithm, given zero or more arguments. These intrinsic functions are provided as a facility of the compiler and runtime system. The return items are temporary COBOL fields, and can be character data, bit fields, or numeric values.
Examples include trigonometric functions, date time routines, data type conversions, standard deviation, and other support algorithms.</description>
    </item>
    
  </channel>
</rss>
