<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>makefile Tutorial on </title>
    <link>https://www.wikiod.com/docs/makefile/</link>
    <description>Recent content in makefile Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/makefile/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with makefile</title>
      <link>https://www.wikiod.com/makefile/getting-started-with-makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/makefile/getting-started-with-makefile/</guid>
      <description>Basic Makefile # Consider writing a &amp;ldquo;hello world!&amp;rdquo; program in c. Lets say our source code is in a file called source.c, now in order to run our program we need to compile it, typically on Linux (using gcc) we would need to type $&amp;gt; gcc source.c -o output where output is the name of the executable to be generated. For a basic program this works well but as programs become more complex our compilation command can also become more complex.</description>
    </item>
    
    <item>
      <title>Advanced Makefile</title>
      <link>https://www.wikiod.com/makefile/advanced-makefile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/makefile/advanced-makefile/</guid>
      <description>Building from different source folders to different target folders # Main features of this Makefile :
Automatic detection of C sources in specified folders Multiple source folders Multiple corresponding target folders for object and dependency files Automatic rule generation for each target folder Creation of target folders when they don&amp;rsquo;t exist Dependency management with gcc : Build only what is necessary Works on Unix and DOS systems Written for GNU Make This Makefile can be used to build a project with this kind of structure :</description>
    </item>
    
    <item>
      <title>Variables</title>
      <link>https://www.wikiod.com/makefile/variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/makefile/variables/</guid>
      <description>Conditional Variable Assignment # The ?= operator is an extension that behaves like =, except that the assignment only occurs if the variable is not already set.
x = hello x ?= world # $(x) will yield &amp;quot;hello&amp;quot; Automatic Variables # Within the context of an individual rule, Make automatically defines a number of special variables. These variables can have a different value for each rule in a makefile and are designed to make writing rules simpler.</description>
    </item>
    
    <item>
      <title>.PHONY target</title>
      <link>https://www.wikiod.com/makefile/phony-target/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/makefile/phony-target/</guid>
      <description>Using .PHONY for non-files targets # Use .PHONY to specify the targets that are not files, e.g., clean or mrproper.
Good example
.PHONY: clean clean: rm *.o temp Bad example
clean: rm *.o temp In the good example make knows that clean is not a file, therefore it will not search if it is or not up to date and will execute the recipe.
In the bad example make will look for a file named clean.</description>
    </item>
    
    <item>
      <title>GNU Pattern Rules</title>
      <link>https://www.wikiod.com/makefile/gnu-pattern-rules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/makefile/gnu-pattern-rules/</guid>
      <description>Targets matching multiple Pattern Rules # If a target matches multiple pattern rules, make will use the one whose prerequisites exist or can be built. For example:
%.o: %.c $(CC) $(CFLAGS) -c $&amp;lt; -o $@ %.o: %.s $(AS) $(ASFLAGS) $&amp;lt; -o $@ Will compile foo.c to foo.o or assemble foo.s to foo.o, depending on which one of foo.c or foo.s exists.
If multiple rules have prerequisites that exist or can be built, make will use the rule that matches to the shortest stem.</description>
    </item>
    
  </channel>
</rss>
