<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>opencv Tutorial on </title>
    <link>https://www.wikiod.com/docs/opencv/</link>
    <description>Recent content in opencv Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/opencv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with opencv</title>
      <link>https://www.wikiod.com/opencv/getting-started-with-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/getting-started-with-opencv/</guid>
      <description>Load and display an image with OpenCV # With this example, we will see how to load a color image from disk and display it using OpenCV&amp;rsquo;s built-in functions. We can use the C/C++, Python or Java bindings to accomplish this.
In C++:
#include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace cv; int main(int argc, char** argv) { // We&#39;ll start by loading an image from the drive Mat image = imread(&amp;quot;image.</description>
    </item>
    
    <item>
      <title>Contrast and Brightness in C&#43;&#43;</title>
      <link>https://www.wikiod.com/opencv/contrast-and-brightness-in-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/contrast-and-brightness-in-c-/</guid>
      <description>Syntax # void cv::Mat::convertTo(OutputArray m, int rtype,double alpha = 1,double beta = 0)const Parameters # Parameter Details m output matrix; if it does not have a proper size or type before the operation, it is reallocated rtype desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input alpha optional scale factor.</description>
    </item>
    
    <item>
      <title>Pixel Access</title>
      <link>https://www.wikiod.com/opencv/pixel-access/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/pixel-access/</guid>
      <description>Be careful to be aware of the type of cv::Mat you are dealing with. For example, if you have a cv::Mat of type CV_8UC3, but access it with image.at&amp;lt;uchar&amp;gt;(r,c) no error will occur, but your program will have some unexpected behavior.
Efficient pixel access using cv::Mat::ptr pointer # If efficiency is important, a fast way to iterate over pixels in a cv::Mat object is to use its ptr&amp;lt;T&amp;gt;(int r) method to obtain a pointer to the beginning of row r (0-based index).</description>
    </item>
    
    <item>
      <title>Edge detection</title>
      <link>https://www.wikiod.com/opencv/edge-detection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/edge-detection/</guid>
      <description>Syntax # edges = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]]) void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize=3, bool L2gradient=false Parameters # Parameter Details image Input image edges Output image threshold1 First threshold for hysteresis procedure threshold2 Second threshold for hysteresis procedure apertureSize Aperture size for Sobel operator L2gradient Flag indicating whether a more accurate algorithm for image gradient should be used Canny algorithm # The Canny algorithm is a more recent edge detector designed as a signal processing problem.</description>
    </item>
    
    <item>
      <title>Image Processing</title>
      <link>https://www.wikiod.com/opencv/image-processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/image-processing/</guid>
      <description>Syntax # Gaussian Blur Syntax C++: void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT ) Parameters # Parameters of Gaussian Blur Details src Input image, the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F. dst Output image of the same size and type as src ksize Gaussian kernel size. ksize.width and ksize.</description>
    </item>
    
    <item>
      <title>Drawing Shapes (Line, Circle, ..., etc) in C&#43;&#43;</title>
      <link>https://www.wikiod.com/opencv/drawing-shapes-line-circle--etc-in-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/drawing-shapes-line-circle--etc-in-c-/</guid>
      <description>In OpenCV, one can draw numerous shapes such as point, line, circle, &amp;hellip;, etc. There is an optional for filling a shape. The following code is self-explanatory which shows how shapes are drawn.
Drawing Shapes Sample # #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; // drawing shapes #include &amp;lt;iostream&amp;gt; int main( int argc, char** argv ) { // First create a black image. cv::Mat image(500,500, CV_8UC3, cv::Scalar(0,0,0)); // Check if the image is created successfully.</description>
    </item>
    
    <item>
      <title>Creating a Video</title>
      <link>https://www.wikiod.com/opencv/creating-a-video/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/creating-a-video/</guid>
      <description>Whenever you work with video feeds you may eventually want to save your image processing result in a form of a new video file. For simple video outputs you can use the OpenCV built-in VideoWriter class, designed for this. It is useful to look at some concepts before using them. These concepts are codec ie decoder and FourCC (Four character code).
Creating a video with OpenCV (Java) # VideoWriter videoWriter; videoWriter = new VideoWriter(outputFile, VideoWriter.</description>
    </item>
    
    <item>
      <title>Cascade Classifiers</title>
      <link>https://www.wikiod.com/opencv/cascade-classifiers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/cascade-classifiers/</guid>
      <description>Using Cascade Classifiers to detect face # Python # Code # import numpy as np import cv2 #loading haarcascade classifiers for face and eye #You can find these cascade classifiers here #https://github.com/opencv/opencv/tree/master/data/haarcascades #or where you download opencv inside data/haarcascades face_cascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_default.xml&#39;) eye_cascade = cv2.CascadeClassifier(&#39;haarcascade_eye.xml&#39;) #loading the image img = cv2.imread(&#39;civil_war.jpg&#39;) #converting the image to gray scale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #detecting face in the grayscale image faces = face_cascade.detectMultiScale(gray, 1.</description>
    </item>
    
    <item>
      <title>Display Image OpenCV</title>
      <link>https://www.wikiod.com/opencv/display-image-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/display-image-opencv/</guid>
      <description>Basic reading and display of an image # import cv2 image_path= #put your image path here #use imread() function to read image data to variable img. img = cv2.imread(image_path) #display image data in a new window with title &#39;I am an image display window&#39; cv2.imshow(&#39;I am an image display window&#39;,img) #wait until user hits any key on keyboard cv2.waitKey(0) #close any windows opened by opencv cv2.destroyAllWindows() To control the size of the display window on the screen, add the following commands before the cv2.</description>
    </item>
    
    <item>
      <title>Using Cascade Classifiers In Java</title>
      <link>https://www.wikiod.com/opencv/using-cascade-classifiers-in-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/opencv/using-cascade-classifiers-in-java/</guid>
      <description>Syntax # CascadeClassifier cascade = new CascadeClassifier(&amp;ldquo;cascade.xml&amp;rdquo;); // Creates a cascade classifier from cascade.xml Mat image = Imgcodecs.imread(&amp;ldquo;image.png&amp;rdquo;); // Converts image.png into a Mat (Matrix) object MatOfRect detections = new MatOfRect(); // Creates an empty MatOfRect (Matrix of Rectangles) file, used as output for our detection classes detections.toArray(); // Returns an array of Rect objects that can be iterated over Imgproc.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.</description>
    </item>
    
  </channel>
</rss>
