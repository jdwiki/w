<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash Tutorial on </title>
    <link>https://www.wikiod.com/docs/bash/</link>
    <description>Recent content in Bash Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/bash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Bash</title>
      <link>https://www.wikiod.com/bash/getting-started-with-bash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/getting-started-with-bash/</guid>
      <description>Hello World # Interactive Shell # The Bash shell is commonly used interactively: It lets you enter and edit commands, then executes them when you press the Return key. Many Unix-based and Unix-like operating systems use Bash as their default shell (notably Linux and macOS). The terminal automatically enters an interactive Bash shell process on startup.
Output Hello World by typing the following:
echo &amp;quot;Hello World&amp;quot; #&amp;gt; Hello World # Output Example Notes # You can change the shell by just typing the name of the shell in terminal.</description>
    </item>
    
    <item>
      <title>Arrays</title>
      <link>https://www.wikiod.com/bash/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/arrays/</guid>
      <description>Array Assignments # List Assignment
If you are familiar with Perl, C, or Java, you might think that Bash would use commas to separate array elements, however this is not the case; instead, Bash uses spaces:
# Array in Perl my @array = (1, 2, 3, 4); # Array in Bash array=(1 2 3 4) Create an array with new elements:
array=(&#39;first element&#39; &#39;second element&#39; &#39;third element&#39;) Subscript Assignment
Create an array with explicit element indices:</description>
    </item>
    
    <item>
      <title>Using trap to react to signals and system events</title>
      <link>https://www.wikiod.com/bash/using-trap-to-react-to-signals-and-system-events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/using-trap-to-react-to-signals-and-system-events/</guid>
      <description>Syntax # trap action sigspec&amp;hellip; # Run &amp;ldquo;action&amp;rdquo; on a list of signals trap sigspec&amp;hellip; # Omitting action resets traps for signals Parameters # Parameter Meaning -p List currently installed traps -l List signal names and corresponding numbers The trap utility is a special shell built-in. It&amp;rsquo;s defined in POSIX, but bash adds some useful extensions as well.
Examples that are POSIX-compatible start with #!/bin/sh, and examples that start with #!</description>
    </item>
    
    <item>
      <title>Internal variables</title>
      <link>https://www.wikiod.com/bash/internal-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/internal-variables/</guid>
      <description>An overview of Bash&amp;rsquo;s internal variables, where, how, and when to use them.
Bash internal variables at a glance # Variable Details $* / $@ Function/script positional parameters (arguments). Expand as follows:
$* and $@ are the same as $1 $2 ... (note that it generally makes no sense to leave those unquoted)
&amp;quot;$*&amp;quot; is the same as &amp;quot;$1 $2 ...&amp;quot; 1 &amp;quot;$@&amp;quot; is the same as &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot; ... 1.</description>
    </item>
    
    <item>
      <title>Bash Parameter Expansion</title>
      <link>https://www.wikiod.com/bash/bash-parameter-expansion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/bash-parameter-expansion/</guid>
      <description>The $ character introduces parameter expansion, command substitution, or arithmetic expansion. The parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect the variable to be expanded from characters immediately following it which could be interpreted as part of the name.
Read more in the Bash User Manual.
Syntax # ${parameter:offset} # Substring starting at offset ${parameter:offset:length} # Substring of length &amp;ldquo;length&amp;rdquo; starting at offset ${#parameter} # Length of parameter ${parameter/pattern/string} # Replace the first occurrence of pattern with string ${parameter//pattern/string} # Replace all occurrences of pattern with string ${parameter/#pattern/string} # Replace pattern with string if pattern is at the beginning ${parameter/%pattern/string} # Replace pattern with string if pattern is at the ending ${parameter#pattern} # Remove shortest match of pattern from beginning of parameter ${parameter##pattern} # Remove longest match of pattern from beginning of parameter ${parameter%pattern} # Remove shortest match of pattern from end of parameter ${parameter%%pattern} # Remove longest match of pattern from end of parameter ${parameter:-word} # Expand to word if parameter unset/undefined ${parameter:=word} # Expand to word if parameter unset/undefined and set parameter ${parameter:+word} # Expand to word if parameter set/defined Modifying the case of alphabetic characters # To uppercase</description>
    </item>
    
    <item>
      <title>Redirection</title>
      <link>https://www.wikiod.com/bash/redirection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/redirection/</guid>
      <description>Syntax # command &amp;lt;/path/to/file # Redirect standard input to file command &amp;gt;/path/to/file # Redirect standard output to flie command file_descriptor&amp;gt;/path/to/file # Redirect output of file_descriptor to file command &amp;gt;&amp;amp;file_descriptor # Redirect output to file_descriptor command file_descriptor&amp;gt;&amp;amp;another_file_descriptor # Redirect file_descriptor to another_file_descriptor command &amp;lt;&amp;amp;file_descriptor # Redirect file_descriptor to standard input command &amp;amp;&amp;gt;/path/to/file # Redirect standard output and standard error to file Parameters # Parameter Details internal file descriptor An integer. direction One of &amp;gt;, &amp;lt; or &amp;lt;&amp;gt; external file descriptor or path &amp;amp; followed by an integer for file descriptor or a path.</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://www.wikiod.com/bash/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/functions/</guid>
      <description>Syntax # Define a function with the function keyword:
function f { }
Define a function with ():
f(){ }
Define a function with both the function keyword and ():
function f(){ }
Functions with arguments # In helloJohn.sh:
#!/bin/bash greet() { local name=&amp;quot;$1&amp;quot; echo &amp;quot;Hello, $name&amp;quot; } greet &amp;quot;John Doe&amp;quot; # running above script $ bash helloJohn.sh Hello, John Doe If you don&amp;rsquo;t modify the argument in any way, there is no need to copy it to a local variable - simply echo &amp;quot;Hello, $1&amp;quot;.</description>
    </item>
    
    <item>
      <title>Here documents and here strings</title>
      <link>https://www.wikiod.com/bash/here-documents-and-here-strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/here-documents-and-here-strings/</guid>
      <description>Execute command with here document # ssh -p 21 example@example.com &amp;lt;&amp;lt;EOF echo &#39;printing pwd&#39; echo &amp;quot;\$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF $ is escaped because we do not want it to be expanded by the current shell i.e $(pwd) is to be executed on the remote shell.
Another way:
ssh -p 21 example@example.com &amp;lt;&amp;lt;&#39;EOF&#39; echo &#39;printing pwd&#39; echo &amp;quot;$(pwd)&amp;quot; ls -a find &#39;*.txt&#39; EOF Note: The closing EOF should be at the beginning of the line (No whitespaces before).</description>
    </item>
    
    <item>
      <title>Listing Files</title>
      <link>https://www.wikiod.com/bash/listing-files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/listing-files/</guid>
      <description>Syntax # ls [OPTION]&amp;hellip; [FILE]&amp;hellip; Parameters # Option Description -a, --all List all entries including ones that start with a dot -A, --almost-all List all entries excluding . and .. -c Sort files by change time -d, --directory List directory entries -h, --human-readable Show sizes in human readable format (i.e. K, M) -H Same as above only with powers of 1000 instead of 1024 -l Show contents in long-listing format -o Long -listing format without group info -r, --reverse Show contents in reverse order -s, --size Print size of each file in blocks -S Sort by file size --sort=WORD Sort contents by a word.</description>
    </item>
    
    <item>
      <title>Find</title>
      <link>https://www.wikiod.com/bash/find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/bash/find/</guid>
      <description>find is a command to recursively search a directory for files(or directories) that match a criteria, and then perform some action on the selected files.
find search_path selection_criteria action
Syntax # find [-H] [-L] [-P] [-D debugopts] [-Olevel] [path&amp;hellip;] [expression] Searching for a file by name or extension # To find files/directories with a specific name, relative to pwd:
$ find . -name &amp;quot;myFile.txt&amp;quot; ./myFile.txt To find files/directories with a specific extension, use a wildcard:</description>
    </item>
    
  </channel>
</rss>
