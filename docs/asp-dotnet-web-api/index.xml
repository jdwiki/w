<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>asp.net-web-api Tutorial on </title>
    <link>https://www.wikiod.com/docs/asp-dotnet-web-api/</link>
    <description>Recent content in asp.net-web-api Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/asp-dotnet-web-api/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with asp.net-web-api</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/getting-started-with-aspnet-web-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/getting-started-with-aspnet-web-api/</guid>
      <description>Installation or Setup # Detailed instructions on getting asp.net-web-api set up or installed.
What and Why ASP.NET Web API ? # What? : A fully supported and extensible framework for building HTTP based endpoints. In the world of HTML5, mobile devices, and modern development techniques HTTP have become the default option for building rich, scalable services. The ASP.NET Web API provides an easy to use set of default options but also provides a deep extensibility infrastructure to meet the demands of any scenario using HTTP.</description>
    </item>
    
    <item>
      <title>ASP.NET Web API Content Negotiation</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-content-negotiation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-content-negotiation/</guid>
      <description>ASP.NET Web API Content Negotiation Basic Information # Content Negotiation can be defined as the process of selecting best representation for a given resource. So Content negotiation means the client and server can negotiate between them so that client can get data according to their required format.
There are three points on which internet depends,
The Resource A Pointer to resource(URL) Representation of resource Third point is more important than other two, because everything is works on the basis of how we can see the resource.</description>
    </item>
    
    <item>
      <title>Web API Url Routing</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/web-api-url-routing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/web-api-url-routing/</guid>
      <description>How Routing works in asp.net webapi # In ASP.NET Web API, a controller is a class that handles HTTP requests. The public methods of the controller are called action methods or simply actions.
When the Web API framework receives a request, it routes the request to an action. To determine which action to invoke, the framework uses a routing table. The Visual Studio project template for Web API creates a default route:</description>
    </item>
    
    <item>
      <title>ASP.NET Web API MediaTypeFormatter</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-mediatypeformatter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-mediatypeformatter/</guid>
      <description>MediaTypeFormatter Basic Information # MediaTypeFormatter is an abstract class from which JsonMediaTypeFormatter and XmlMediaTypeFormatter classes inherit from. Here, JsonMediaTypeFormatter class handles JSON objects and XmlMediaTypeFormatter class handles XML objects.
Return only JSON irrespective of the Accept Header value:
To return only JSON objects in the response of the request weather Accept Header value of request if application/json or application/xml write the following line in the Register method of WebApiConfig class.</description>
    </item>
    
    <item>
      <title>ASP.NET WEB API CORS Enabling</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-cors-enabling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/aspnet-web-api-cors-enabling/</guid>
      <description>Configure CORS for WebAPI 2 with Windows Authentication # The following server-side configuration allows CORS request to work along with Windows Authentication (no anonymous must be enabled in IIS).
web.config - allow unauthenticated (anonymous) preflight requests (OPTIONS)
&amp;lt;system.web&amp;gt; &amp;lt;authentication mode=&amp;quot;Windows&amp;quot; /&amp;gt; &amp;lt;authorization&amp;gt; &amp;lt;allow verbs=&amp;quot;OPTIONS&amp;quot; users=&amp;quot;*&amp;quot;/&amp;gt; &amp;lt;deny users=&amp;quot;?&amp;quot; /&amp;gt; &amp;lt;/authorization&amp;gt; &amp;lt;/system.web&amp;gt; global.asax.cs - properly reply with headers that allow caller from another domain to receive data
protected void Application_AuthenticateRequest(object sender, EventArgs e) { if (Context.</description>
    </item>
    
    <item>
      <title>Quick Start Working with JSON</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/quick-start-working-with-json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/quick-start-working-with-json/</guid>
      <description>Examples to get you up and running quickly (and correctly) with ASP.NET WebAPI
Return JSON from GET using attributes # 1. Setup your formatter and routing in Register of (App_Start/WebApiConfig) # public static class WebApiConfig { public static void Register(HttpConfiguration config) { GlobalConfiguration.Configuration.Formatters.Clear(); GlobalConfiguration.Configuration.Formatters.Add(new JsonMediaTypeFormatter()); config.MapHttpAttributeRoutes(); } } 2. Create methods in an ApiController # public class HelloWorldController : ApiController { [HttpGet] [Route(&amp;quot;echo/{message}&amp;quot;)] public IHttpActionResult Echo(string message) { return Ok(new{ hello: message }); } [HttpGet] [Route(&amp;quot;echo/{digits:int}&amp;quot;)] public IHttpActionResult Echo(int digits) { return Ok(new{ hello: digits }); } executing GET /echo/foo</description>
    </item>
    
    <item>
      <title>Configure a Web API application to respond with prettyformatted JSON data by defualt</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/configure-a-web-api-application-to-respond-with-prettyformatted-json-data-by-defualt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/configure-a-web-api-application-to-respond-with-prettyformatted-json-data-by-defualt/</guid>
      <description>Default JSON formatting: Efficiency at the cost of readability # Lets say you have a simple ApiController like this:
[HttpGet] [Route(&amp;quot;test&amp;quot;)] public dynamic Test() { dynamic obj = new ExpandoObject(); obj.prop1 = &amp;quot;some string&amp;quot;; obj.prop2 = 11; obj.prop3 = &amp;quot;another string&amp;quot;; return obj; } The resulting JSON representation of this object will look like this:
{&amp;quot;prop1&amp;quot;:&amp;quot;some string&amp;quot;,&amp;quot;prop2&amp;quot;:11,&amp;quot;prop3&amp;quot;:&amp;quot;another string&amp;quot;} This is probably fine for simple responses like this, but imagine if you have a large/complex object sent as the response:</description>
    </item>
    
    <item>
      <title>OData with Asp.net Web API</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/odata-with-aspnet-web-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/odata-with-aspnet-web-api/</guid>
      <description>Install the OData Packages # From the Tools menu, select NuGet Package Manager &amp;gt; Package Manager Console. In the Package Manager Console window, type:
Install-Package Microsoft.AspNet.Odata This command installs the latest OData NuGet packages.
Enable Entity Framework # For this tutorial, we&amp;rsquo;ll use Entity Framework (EF) Code First to create the back-end database.
Web API OData does not require EF. Use any data-access layer that can translate database entities into models.</description>
    </item>
    
    <item>
      <title>Caching</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/caching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/caching/</guid>
      <description>Caching is the process of storing data somewhere for the future requests, in our case we can avoid the unwanted hit to database to get the data if we cache the data somewhere, this way we can make sure that the data is served in a faster manner.
System.Runtime.Caching (MemoryCache) # Import the namespace System.Runtime.Caching(Make sure that you have added System.Runtime.Caching DLL to your project reference).
Create an instance of MemoryCache class.</description>
    </item>
    
    <item>
      <title>Attribute Routing in WebAPI</title>
      <link>https://www.wikiod.com/asp-dotnet-web-api/attribute-routing-in-webapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/asp-dotnet-web-api/attribute-routing-in-webapi/</guid>
      <description>As the name suggests, this uses attributes to route. This gives the user more control over the URI&amp;rsquo;s in the WebAPI. For example, you can describe hierarchies of the resource. However, the earlier &amp;lsquo;Conventional Routing&amp;rsquo; is fully supported. Users can have a mixture of both too.
Syntax # [RoutePrefix(&amp;ldquo;api/books&amp;rdquo;)] - for controller class [Route(&amp;ldquo;getById&amp;rdquo;)] - for actions [Route(&amp;quot;~/api/authors/{authorId:int}/books&amp;quot;)] - for overriding route prefix Parameters # Parameter Name Details RoutePrefix attribute to the controller class.</description>
    </item>
    
  </channel>
</rss>
