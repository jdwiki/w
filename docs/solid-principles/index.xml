<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>solid-principles Tutorial on </title>
    <link>https://www.wikiod.com/docs/solid-principles/</link>
    <description>Recent content in solid-principles Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/solid-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with solid-principles</title>
      <link>https://www.wikiod.com/solid-principles/getting-started-with-solid-principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/solid-principles/getting-started-with-solid-principles/</guid>
      <description>Liskov Substitution Principle # Why to use LSP
Scenario: Suppose we have 3 databases (Mortgage Customers, Current Accounts Customers and Savings Account Customers) that provide customer data and we need customer details for given customer&amp;rsquo;s last name. Now we may get more than 1 customer detail from those 3 databases against given last name.
Implementation
BUSINESS MODEL LAYER:
public class Customer { // customer detail properties... } DATA ACCESS LAYER:</description>
    </item>
    
    <item>
      <title>Open Closed Principle (OCP)</title>
      <link>https://www.wikiod.com/solid-principles/open-closed-principle-ocp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/solid-principles/open-closed-principle-ocp/</guid>
      <description>Software entities (class, modules, functions etc) should be open for extension but closed for modification.
Open Closed Principle C# # Here, we try to explain OCP using codebase. First we&amp;rsquo;ll show a scenario that violate OCP and then we&amp;rsquo;ll remove that violation.
Area Calculation (OCP violation Code) :
public class Rectangle{ public double Width {get; set;} public double Height {get; set;} } public class Circle{ public double Radious {get; set;} } public double getArea (object[] shapes){ double totalArea = 0; foreach(var shape in shapes){ if(shape is Rectangle){ Rectangle rectangle = (Rectangle)shape; totalArea += rectangle.</description>
    </item>
    
    <item>
      <title>Dependency Inversion Principle (DIP)</title>
      <link>https://www.wikiod.com/solid-principles/dependency-inversion-principle-dip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/solid-principles/dependency-inversion-principle-dip/</guid>
      <description>The principle basically says, Class should depend on abstractions (e.g interface, abstract classes), not specific details (implementations). That means, You should let the caller create the dependencies instead of letting the class itself create the dependencies.
Dependency Inversion Principle C# # To understand Dependency Inversion Principle (DIP) we need to clear concept about Inversion Of Control(IOC) and Dependency Injection(DI). So here we discuss all about the terms with Dependency Inversion Principle (DIP).</description>
    </item>
    
    <item>
      <title>Single Responsibility Principle (SRP)</title>
      <link>https://www.wikiod.com/solid-principles/single-responsibility-principle-srp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/solid-principles/single-responsibility-principle-srp/</guid>
      <description>There should never be more than one reason for change anything in software entities (class, function, file etc). A class, function, file etc should have only one reason to change.
Just because you can, doesn&amp;rsquo;t mean you should.
Single Responsibility Principle C# # Let&amp;rsquo;s go through the problem first. Have a look on the code below:
public class BankAccount { public BankAccount() {} public string AccountNumber { get; set; } public decimal AccountBalance { get; set; } public decimal CalculateInterest() { // Code to calculate Interest } } Here, BankAccount class contains the properties of account and also calculate the interest of account.</description>
    </item>
    
    <item>
      <title>Interface Segregation Principle (ISP)</title>
      <link>https://www.wikiod.com/solid-principles/interface-segregation-principle-isp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/solid-principles/interface-segregation-principle-isp/</guid>
      <description>The principle states that no client should be forced to depend on methods that it doesn&amp;rsquo;t use. A client should never be forced to implement an interface that it doesn&amp;rsquo;t use or client shouldn&amp;rsquo;t be forced to depend on methods that they don&amp;rsquo;t use.
Interface Segregation Principle C# # Here we give an example of ISP violation and then refactor that violation. Without talking unnecessary things let&amp;rsquo;s jump into the code.</description>
    </item>
    
  </channel>
</rss>
