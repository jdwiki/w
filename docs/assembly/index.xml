<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Assembly Language Tutorial on </title>
    <link>https://www.wikiod.com/docs/assembly/</link>
    <description>Recent content in Assembly Language Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Assembly Language</title>
      <link>https://www.wikiod.com/assembly/getting-started-with-assembly-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/getting-started-with-assembly-language/</guid>
      <description>Introduction # Assembly language is a human readable form of machine language or machine code which is the actual sequence of bits and bytes on which the processor logic operates. It is generally easier for humans to read and program in mnemonics than binary, octal or hex, so humans typically write code in assembly language and then use one or more programs to convert it into the machine language format understood by the processor.</description>
    </item>
    
    <item>
      <title>Registers</title>
      <link>https://www.wikiod.com/assembly/registers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/registers/</guid>
      <description>What are Registers?
The processor can operate upon numeric values (numbers), but these have to be stored somewhere first. The data are stored mostly in memory, or inside the instruction opcode (which is stored usually in memory too), or in special on-chip memory placed directly in processor, which is called register.
To work with value in register, you don&amp;rsquo;t need to address it by address, but special mnemonic &amp;ldquo;names&amp;rdquo; are used, like for example ax on x86, or A on Z80, or r0 on ARM.</description>
    </item>
    
    <item>
      <title>The Stack</title>
      <link>https://www.wikiod.com/assembly/the-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/the-stack/</guid>
      <description>The stack of computers is like a stack of books. PUSH adds one to the top and POP takes the uppermost away. Like in real life the stack cannot be endless, so it has maximum size. The stack can be used for sorting algorithms, to handle a bigger amount of data or to safe values of registers while doing another operation.
Zilog Z80 Stack # The register sp is used as stack pointer, pointing to the last stored value into stack (&amp;ldquo;top&amp;rdquo; of stack).</description>
    </item>
    
    <item>
      <title>Linux elf64 examples not using glibc</title>
      <link>https://www.wikiod.com/assembly/linux-elf64-examples-not-using-glibc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/linux-elf64-examples-not-using-glibc/</guid>
      <description>User Interface # I would venture to say that 80% of the processing that goes on in modern computing systems does not require user interaction, such as kernel code for Linux, OSX and Windows. For those that do, there are two fundamentals which are interactivity via keyboard (pointing devices) and console. This example and others in my series are oriented around text based console (VT100 emulation) and keyboard.
In and of itself, this example is very simple, but it is an essential building block toward more complex algorithms.</description>
    </item>
    
    <item>
      <title>Flow Control</title>
      <link>https://www.wikiod.com/assembly/flow-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/flow-control/</guid>
      <description>Every piece of non-trivial software needs flow-control structures to divert program flow according to conditions.
Assembly being the lowest-level programming language provides only primitives for control structures. Typically, machine operations affect flags in the CPU, and conditional branches/jumps implement the flow control. In assembly, all higher-level control structures need to be constructed from such primitives.
FOR &amp;hellip; NEXT in Z80 Assembly # The Z80 has a specific instruction to implement loop counts: DJNZstanding for &amp;ldquo;decrement B register and jump if not zero&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Interrupts</title>
      <link>https://www.wikiod.com/assembly/interrupts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/assembly/interrupts/</guid>
      <description>Why do we need Interrupts
Lets imagine: Our computer is connected to a keypad. We want to enter something. When we press the key nothing happens because the computer is dealing with different things and doesnt notice that we want something from him. We need Interrupts!
Interrupts are triggered by software (INT 80h) or hardware (keypress), they behave like a Call (they jump to a specific location, execute code and jump back again).</description>
    </item>
    
  </channel>
</rss>
