<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>common-lisp Tutorial on </title>
    <link>https://www.wikiod.com/docs/common-lisp/</link>
    <description>Recent content in common-lisp Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with common-lisp</title>
      <link>https://www.wikiod.com/common-lisp/getting-started-with-common-lisp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/getting-started-with-common-lisp/</guid>
      <description>Common Lisp Learning Resources # Online Books
These are books that are freely accessible online.
Practical Common Lisp by Peter Seibel is a good introduction to CL for experienced programmers, which tries to highlight from the very beginning what makes CL different to other languages. Common Lisp: A Gentle Introduction to Symbolic Computation by David S. Touretzky is a good introduction for people new to programming. Common Lisp: An interactive approach by Stuart C.</description>
    </item>
    
    <item>
      <title>ASDF - Another System Definition Facility</title>
      <link>https://www.wikiod.com/common-lisp/asdf---another-system-definition-facility/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/asdf---another-system-definition-facility/</guid>
      <description>ASDF - Another System Definition Facility
ASDF is a tool for specifying how systems of Common Lisp software are made up of components (sub-systems and files), and how to operate on these components in the right order so that they can be compiled, loaded, tested, etc.
Simple ASDF system with a flat directory structure # Consider this simple project with a flat directory structure:
example |-- example.asd |-- functions.lisp |-- main.</description>
    </item>
    
    <item>
      <title>ANSI Common Lisp, the language standard and its documentation</title>
      <link>https://www.wikiod.com/common-lisp/ansi-common-lisp-the-language-standard-and-its-documentation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/ansi-common-lisp-the-language-standard-and-its-documentation/</guid>
      <description>Common Lisp HyperSpec # Common Lisp has a standard, which was initially published in 1994 as an ANSI standard.
The Common Lisp HyperSpec, short CLHS, provided by LispWorks is an often used HTML documentation, which is derived from the standard document. The HyperSpec can also be downloaded and locally used.
Common Lisp development environments usually allow lookup of the HyperSpec documentation for Lisp symbols.
For GNU Emacs there is clhs.el. SLIME for GNU Emacs provides a version of hyperspec.</description>
    </item>
    
    <item>
      <title>macros</title>
      <link>https://www.wikiod.com/common-lisp/macros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/macros/</guid>
      <description>The Purpose of Macros # Macros are intended for generating code, transforming code and providing new notations. These new notations can be more suited to better express the program, for example by providing domain-level constructs or entire new embedded languages.
Macros can make source code more self-explanatory, but debugging can be made more difficult. As a rule of thumb, one should not use macros when a regular function will do. When you do use them, avoid the usual pitfalls, try to stick to the commonly used patterns and naming conventions.</description>
    </item>
    
    <item>
      <title>CLOS - the Common Lisp Object System</title>
      <link>https://www.wikiod.com/common-lisp/clos---the-common-lisp-object-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/clos---the-common-lisp-object-system/</guid>
      <description>Mixins and Interfaces # Common Lisp does not have interfaces in the sense that some languages (e.g., Java) do, and there is less need for that type of interface given that Common Lisp supports multiple inheritance and generic functions. However, the same type of patterns can be realized easily using mixin classes. This example shows the specification of a collection interface with several corresponding generic functions.
;; Specification of the COLLECTION &amp;quot;interface&amp;quot; (defclass collection () () (:documentation &amp;quot;A collection mixin.</description>
    </item>
    
    <item>
      <title>Working with SLIME</title>
      <link>https://www.wikiod.com/common-lisp/working-with-slime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/working-with-slime/</guid>
      <description>Using REPL # CL-USER&amp;gt; (+ 2 3) 5 CL-USER&amp;gt; (sin 1.5) 0.997495 CL-USER&amp;gt; (mapcar (lambda (x) (+ x 2)) &#39;(1 2 3)) (3 4 5) The result that is printed after evaluation is not only a string: there is full-on Lisp object behind it which can be inspected by right-clicking on it and choosing Inspect.
Multi-line input is also possible: use C-j to put new line. Enter-key will cause the entered form to be evaluated and if the form is not finished, will likely cause an error:</description>
    </item>
    
    <item>
      <title>format</title>
      <link>https://www.wikiod.com/common-lisp/format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/format/</guid>
      <description>Parameters # Lambda-List (format DESTINATION CONTROL-STRING &amp;amp;REST FORMAT-ARGUMENTS) DESTINATION the thing to write to. This can be an output stream, t (shorthand for *standard-output*), or nil (which creates a string to write to) CONTROL-STRING the template string. It might be a primitive string, or it might contain tilde-prefixed command directives that specify, and somehow transform additional arguments. FORMAT-ARGUMENTS potential additional arguments required by the given CONTROL-STRING. The CLHS documentation for FORMAT directives can be found in Section 22.</description>
    </item>
    
    <item>
      <title>LOOP, a Common Lisp macro for iteration</title>
      <link>https://www.wikiod.com/common-lisp/loop-a-common-lisp-macro-for-iteration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/loop-a-common-lisp-macro-for-iteration/</guid>
      <description>Parallel Iteration # Multiple FOR clauses are allowed in a LOOP. The loop finishes when the first of these clauses finishes:
(loop for a in &#39;(1 2 3 4 5) for b in &#39;(a b c) collect (list a b)) ;; Evaluates to: ((1 a) (2 b) (3 c)) Other clauses that determine if the loop should continue can be combined:
(loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) collect a) ;; Evaluates to: (1 2 3) (loop for a in &#39;(1 2 3 4 5 6 7) while (&amp;lt; a 4) repeat 1 collect a) ;; Evaluates to: (1) Determine which list is longer, cutting off iteration as soon as the answer is known:</description>
    </item>
    
    <item>
      <title>Cons cells and lists</title>
      <link>https://www.wikiod.com/common-lisp/cons-cells-and-lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/cons-cells-and-lists/</guid>
      <description>What is a cons cell? # A cons cell, also known as a dotted pair (because of its printed representation), is simply a pair of two objects. A cons cell is created by the function cons, and elements in the pair are extracted using the functions car and cdr.
(cons &amp;quot;a&amp;quot; 4) For instance, this returns a pair whose first element (which can be extracted with car) is &amp;quot;a&amp;quot;, and whose second element (which can be extracted with cdr), is 4.</description>
    </item>
    
    <item>
      <title>sequence - how to split a sequence</title>
      <link>https://www.wikiod.com/common-lisp/sequence---how-to-split-a-sequence/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/common-lisp/sequence---how-to-split-a-sequence/</guid>
      <description>Syntax # split regex target-string &amp;amp;key start end limit with-registers-p omit-unmatched-p sharedp =&amp;gt; list lispworks:split-sequence separator-bag sequence &amp;amp;key start end test key coalesce-separators =&amp;gt; sequences split-sequence delimiter sequence &amp;amp;key start end from-end count remove-empty-subseqs test test-not key =&amp;gt; list of subsequences Split strings using regular expressions # The library CL-PPCRE provides the function split which allows us to split strings in substrings that match a regular expression, discarding the parts of the string that do not.</description>
    </item>
    
  </channel>
</rss>
