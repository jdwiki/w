<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embarcadero Delphi Tutorial on </title>
    <link>https://www.wikiod.com/docs/delphi/</link>
    <description>Recent content in Embarcadero Delphi Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/delphi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Embarcadero Delphi</title>
      <link>https://www.wikiod.com/delphi/getting-started-with-embarcadero-delphi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/getting-started-with-embarcadero-delphi/</guid>
      <description>Hello World # This program, saved to a file named HelloWorld.dpr, compiles to a console application that prints &amp;ldquo;Hello World&amp;rdquo; to the console:
program HelloWorld; {$APPTYPE CONSOLE} begin WriteLn(&#39;Hello World&#39;); end. Show &amp;lsquo;Hello World&amp;rsquo; using the VCL # This progam uses VCL, the default UI components library of Delphi, to print &amp;ldquo;Hello World&amp;rdquo; into a message box. The VCL wrapps most of the commonly used WinAPI components. This way, they can be used much easier, e.</description>
    </item>
    
    <item>
      <title>Use of try, except, and finally</title>
      <link>https://www.wikiod.com/delphi/use-of-try-except-and-finally/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/use-of-try-except-and-finally/</guid>
      <description>Syntax # Try-except: try [statements] except [[[on E:ExceptionType do statement]] [else statement] | [statements] end;
Try-finally: try [statements] finally [statements] end;
Exception-safe return of a new object # When a function returns an object (as opposed to using one that&amp;rsquo;s passed in by the caller), be careful an exception doesn&amp;rsquo;t cause the object to leak.
function MakeStrings: TStrings; begin // Create a new object before entering the try-block. Result := TStringList.</description>
    </item>
    
    <item>
      <title>Running a thread while keeping GUI responsive</title>
      <link>https://www.wikiod.com/delphi/running-a-thread-while-keeping-gui-responsive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/running-a-thread-while-keeping-gui-responsive/</guid>
      <description>Responsive GUI using threads for background work and PostMessage to report back from the threads # Keeping a GUI responsive while running a lengthy process requires either some very elaborate &amp;ldquo;callbacks&amp;rdquo; to allow the GUI to process its message queue, or the use of (background) (worker) threads.
Kicking off any number of threads to do some work usually isn&amp;rsquo;t a problem. The fun starts when you want to make the GUI show intermediate and final results or report on the progress.</description>
    </item>
    
    <item>
      <title>Strings</title>
      <link>https://www.wikiod.com/delphi/strings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/strings/</guid>
      <description>String types # Delphi has the following string types (in order of popularity):
Type Maximum length Minimum size Description string 2GB 16 bytes A managed string. An alias for AnsiString through Delphi 2007, and an alias for UnicodeString as of Delphi 2009. UnicodeString 2GB 16 bytes A managed string in UTF-16 format. AnsiString 2GB 16 bytes A managed string in pre-Unicode ANSI format. As of Delphi 2009, it carries an explicit code-page indicator.</description>
    </item>
    
    <item>
      <title>Time intervals measurement</title>
      <link>https://www.wikiod.com/delphi/time-intervals-measurement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/time-intervals-measurement/</guid>
      <description>Using Windows API GetTickCount # The Windows API GetTickCount function returns the number of milliseconds since the system (computer) was started. The simplest example follows:
var Start, Stop, ElapsedMilliseconds: cardinal; begin Start := GetTickCount; // do something that requires measurement Stop := GetTickCount; ElapsedMillseconds := Stop - Start; end; Note that GetTickCount returns 32-bit DWORD so it wraps every 49.7 days. To avoid wrapping, you may either use GetTickCount64 (available since Windows Vista) or special routines to calculate tick difference:</description>
    </item>
    
    <item>
      <title>Generics</title>
      <link>https://www.wikiod.com/delphi/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/generics/</guid>
      <description>Sort a dynamic array via generic TArray.Sort # uses System.Generics.Collections, { TArray } System.Generics.Defaults; { TComparer&amp;lt;T&amp;gt; } var StringArray: TArray&amp;lt;string&amp;gt;; { Also works with &amp;quot;array of string&amp;quot; } ... { Sorts the array case insensitive } TArray.Sort&amp;lt;string&amp;gt;(StringArray, TComparer&amp;lt;string&amp;gt;.Construct( function (const A, B: string): Integer begin Result := string.CompareText(A, B); end )); Simple usage of TList # var List: TList&amp;lt;Integer&amp;gt;; ... List := TList&amp;lt;Integer&amp;gt;.Create; { Create List } try List.Add(100); { Add Items } List.</description>
    </item>
    
    <item>
      <title>For Loops</title>
      <link>https://www.wikiod.com/delphi/for-loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/for-loops/</guid>
      <description>Syntax # for OrdinalVariable := LowerOrdinalValue to UpperOrdinalValue do begin {loop-body} end;
for OrdinalVariable := UpperOrdinalValue downto LowerOrdinalValue do begin {loop-body} end;
for EnumerableVariable in Collection do begin {loop-body} end;
Delphi&amp;rsquo;s for-loop syntax does not provide anything to change step amount from 1 to any other value.
When looping with variable ordinal values, e.g. local variables of type Integer, the upper and lower values will be determined only once. Changes to such variables will have no effect on the loops iteration count.</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>https://www.wikiod.com/delphi/interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/interfaces/</guid>
      <description>Interfaces are used to describe the needed information and the expected output of methods and classes, without providing information of the explicit implementation.
Classes can implement interfaces, and interfaces can inherit from each other. If a class is implementing an interface, this means all functions and procedures exposed by the interface exist in the class.
A special aspect of interfaces in delphi is that instances of interfaces have a lifetime management based on reference counting.</description>
    </item>
    
    <item>
      <title>Retrieving updated TDataSet data in a background thread</title>
      <link>https://www.wikiod.com/delphi/retrieving-updated-tdataset-data-in-a-background-thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/retrieving-updated-tdataset-data-in-a-background-thread/</guid>
      <description>This FireDAC example, and the others I&amp;rsquo;m planning to submit, will avoid the use of native calls to asynchronously open the dataset.
FireDAC example # The code sample below shows one way to retrieve records from an MSSql Server in a background thread using FireDAC. Tested for Delphi 10 Seattle
As written:
The thread retrieves data using its own TFDConnection and TFDQuery and transfers the data to the form&amp;rsquo;s FDQuery in a call to Sychronize().</description>
    </item>
    
    <item>
      <title>Running other programs</title>
      <link>https://www.wikiod.com/delphi/running-other-programs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/delphi/running-other-programs/</guid>
      <description>CreateProcess # Following function encapsulates code for using CreateProcess Windows API for launching other programs.
It is configurable and can wait until calling process finishes or return immediately.
Parameters:
FileName - full path to executable
Params - command line parameters or use empty string
Folder - working folder for called program - if empty path will be extracted from FileName
WaitUntilTerminated - if true function will wait for process to finish execution</description>
    </item>
    
  </channel>
</rss>
