<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm Tutorial on </title>
    <link>https://www.wikiod.com/docs/algorithm/</link>
    <description>Recent content in algorithm Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with algorithm</title>
      <link>https://www.wikiod.com/algorithm/getting-started-with-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/getting-started-with-algorithm/</guid>
      <description>A sample algorithmic problem # An algorithmic problem is specified by describing the complete set of instances it must work on and of its output after running on one of these instances. This distinction, between a problem and an instance of a problem, is fundamental. The algorithmic problem known as sorting is defined as follows: [Skiena:2008:ADM:1410219]
Problem: Sorting Input: A sequence of n keys, a_1, a_2, ..., a_n. Output: The reordering of the input sequence such that a&#39;_1 &amp;lt;= a&#39;_2 &amp;lt;= .</description>
    </item>
    
    <item>
      <title>Algorithm Complexity</title>
      <link>https://www.wikiod.com/algorithm/algorithm-complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/algorithm-complexity/</guid>
      <description>All algorithms are a list of steps to solve a problem. Each step has dependencies on some set of previous steps, or the start of the algorithm. A small problem might look like the following:
This structure is called a directed acyclic graph, or DAG for short. The links between each node in the graph represent dependencies in the order of operations, and there are no cycles in the graph.</description>
    </item>
    
    <item>
      <title>Big-O Notation</title>
      <link>https://www.wikiod.com/algorithm/big-o-notation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/big-o-notation/</guid>
      <description>Definition
The Big-O notation is at its heart a mathematical notation, used to compare the rate of convergence of functions. Let n -&amp;gt; f(n) and n -&amp;gt; g(n) be functions defined over the natural numbers. Then we say that f = O(g) if and only if f(n)/g(n) is bounded when n approaches infinity. In other words, f = O(g) if and only if there exists a constant A, such that for all n, f(n)/g(n) &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>Graph</title>
      <link>https://www.wikiod.com/algorithm/graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/graph/</guid>
      <description>A graph is a collection of points and lines connecting some (possibly empty) subset of them. The points of a graph are called graph vertices, &amp;ldquo;nodes&amp;rdquo; or simply &amp;ldquo;points.&amp;rdquo; Similarly, the lines connecting the vertices of a graph are called graph edges, &amp;ldquo;arcs&amp;rdquo; or &amp;ldquo;lines.&amp;rdquo;
A graph G can be defined as a pair (V,E), where V is a set of vertices, and E is a set of edges between the vertices E ⊆ {(u,v) | u, v ∈ V}.</description>
    </item>
    
    <item>
      <title>Binary Search Trees</title>
      <link>https://www.wikiod.com/algorithm/binary-search-trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/binary-search-trees/</guid>
      <description>Binary tree is a tree that each node in it has maximum of two children. Binary search tree (BST) is a binary tree which its elements positioned in special order. In each BST all values(i.e key) in left sub tree are less than values in right sub tree.
Binary Search Tree - Insertion (Python) # This is a simple implementation of Binary Search Tree Insertion using Python.
An example is shown below:</description>
    </item>
    
    <item>
      <title>Dijkstra’s Algorithm</title>
      <link>https://www.wikiod.com/algorithm/dijkstras-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/dijkstras-algorithm/</guid>
      <description>Dijkstra&amp;rsquo;s Shortest Path Algorithm # Before proceeding, it is recommended to have a brief idea about Adjacency Matrix and BFS
Dijkstra&amp;rsquo;s algorithm is known as single-source shortest path algorithm. It is used for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by Edsger W. Dijkstra in 1956 and published three years later.
We can find shortest path using Breadth First Search (BFS) searching algorithm.</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://www.wikiod.com/algorithm/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/merge-sort/</guid>
      <description>Merge Sort Basics # Merge Sort is a divide-and-conquer algorithm. It divides the input list of length n in half successively until there are n lists of size 1. Then, pairs of lists are merged together with the smaller first element among the pair of lists being added in each step. Through successive merging and through comparison of first elements, the sorted list is built.
An example:
Time Complexity: T(n) = 2T(n/2) + Θ(n)</description>
    </item>
    
    <item>
      <title>Dynamic Time Warping</title>
      <link>https://www.wikiod.com/algorithm/dynamic-time-warping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/dynamic-time-warping/</guid>
      <description>Introduction To Dynamic Time Warping # Dynamic Time Warping(DTW) is an algorithm for measuring similarity between two temporal sequences which may vary in speed. For instance, similarities in walking could be detected using DTW, even if one person was walking faster than the other, or if there were accelerations and decelerations during the course of an observation. It can be used to match a sample voice command with others command, even if the person talks faster or slower than the prerecorded sample voice.</description>
    </item>
    
    <item>
      <title>Bellman–Ford Algorithm</title>
      <link>https://www.wikiod.com/algorithm/bellmanford-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/bellmanford-algorithm/</guid>
      <description>Given a directed graph G, we often want to find the shortest distance from a given node A to rest of the nodes in the graph. Dijkstra algorithm is the most famous algorithm for finding the shortest path, however it works only if edge weights of the given graph are non-negative. Bellman-Ford however aims to find the shortest path from a given node (if one exists) even if some of the weights are negative.</description>
    </item>
    
    <item>
      <title>Substring Search</title>
      <link>https://www.wikiod.com/algorithm/substring-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/algorithm/substring-search/</guid>
      <description>Introduction To Knuth-Morris-Pratt (KMP) Algorithm # Suppose that we have a text and a pattern. We need to determine if the pattern exists in the text or not. For example:
+-------+---+---+---+---+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | +-------+---+---+---+---+---+---+---+---+ | Text | a | b | c | b | c | g | l | x | +-------+---+---+---+---+---+---+---+---+ +---------+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | +---------+---+---+---+---+ | Pattern | b | c | g | l | +---------+---+---+---+---+ This pattern does exist in the text.</description>
    </item>
    
  </channel>
</rss>
