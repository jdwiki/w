<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mfc Tutorial on </title>
    <link>https://www.wikiod.com/docs/mfc/</link>
    <description>Recent content in mfc Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/mfc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with mfc</title>
      <link>https://www.wikiod.com/mfc/getting-started-with-mfc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/mfc/getting-started-with-mfc/</guid>
      <description>A basic MFC program # // Include the MFC header: // (you do not need to and should not include the standard Windows headers, e.g. // Windows.h) #include &amp;lt;AfxWin.h&amp;gt; // MFC core and standard components // The following header defines resource constants, such as dialog and control IDs: #include &amp;quot;resource.h&amp;quot; // The basic element of an MFC application is a class that inherits from CWinApp. class CMyApp : public CWinApp { // This gets called as the application gets initialized.</description>
    </item>
    
    <item>
      <title>Dockable control bars (panes)</title>
      <link>https://www.wikiod.com/mfc/dockable-control-bars-panes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/mfc/dockable-control-bars-panes/</guid>
      <description>Almost all MFC applications have toolbar and status bar - special types of the control bar that docked to top and bottom part of application main frame. But often application logic requires more the information bars docked to some side of frame, for example it may be properties bar or classes bar, preview bar, output bar and many others. Classic MFC have good solution only for toolbars and others controls that not dynamically resizable.</description>
    </item>
    
    <item>
      <title>Migrating ISAPI MFC extension (C&#43;&#43;) VS2005 DLL project to VS2015.</title>
      <link>https://www.wikiod.com/mfc/migrating-isapi-mfc-extension-c-vs2005-dll-project-to-vs2015/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/mfc/migrating-isapi-mfc-extension-c-vs2005-dll-project-to-vs2015/</guid>
      <description>You may have seen several websites that will show how to create an ISAPI extension project but none of them will demonstrate how to migrate the existing legacy ISAPI extension (VS2005) project to VS2015. I had faced similar issue while I was working on one of such requirement. This article demonstrates the experimental waythat I had took to solve my issue.
I was working on a migration task where I came across a project.</description>
    </item>
    
    <item>
      <title>Multithreading</title>
      <link>https://www.wikiod.com/mfc/multithreading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/mfc/multithreading/</guid>
      <description>MFC supports worker threads and gui threads (threads with message loops). See https://msdn.microsoft.com/en-us/library/975t8ks0.aspx for more documentation.
Simple AfxBeginThread Worker Thread Example # This example shows a call of AfxBeginThread that starts the worker thread and an example worker thread procedure for that thread.
// example simple thread procedure. UINT __cdecl threadProc(LPVOID rawInput) { // convert it to the correct data type. It&#39;s common to pass entire structures this way. int* input = (int*)rawInput; // TODO: Add your worker code.</description>
    </item>
    
  </channel>
</rss>
