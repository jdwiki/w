<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dynamic-programming Tutorial on </title>
    <link>https://www.wikiod.com/docs/dynamic-programming/</link>
    <description>Recent content in dynamic-programming Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with dynamic-programming</title>
      <link>https://www.wikiod.com/dynamic-programming/getting-started-with-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/getting-started-with-dynamic-programming/</guid>
      <description>Introduction To Dynamic Programming # Dynamic programming solves problems by combining the solutions to subproblems. It can be analogous to divide-and-conquer method, where problem is partitioned into disjoint subproblems, subproblems are recursively solved and then combined to find the solution of the original problem. In contrast, dynamic programming applies when the subproblems overlap - that is, when subproblems share subsubproblems. In this context, a divide-and-conquer algorithm does more work than necessary, repeatedly solving the common subsubproblems.</description>
    </item>
    
    <item>
      <title>Coin Changing Problem</title>
      <link>https://www.wikiod.com/dynamic-programming/coin-changing-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/coin-changing-problem/</guid>
      <description>Number of Ways to Get Total # Given coins of different denominations and a total, in how many ways can we combine these coins to get the total? Let&amp;rsquo;s say we have coins = {1, 2, 3} and a total = 5, we can get the total in 5 ways:
1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 2 3 The problem is closely related to knapsack problem.</description>
    </item>
    
    <item>
      <title>Solving Graph Problems Using Dynamic Programming</title>
      <link>https://www.wikiod.com/dynamic-programming/solving-graph-problems-using-dynamic-programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/solving-graph-problems-using-dynamic-programming/</guid>
      <description>Floyd-Warshall Algorithm # Minimum Vertex Cover # Minimum Vertex Cover is a classic graph problem. Let&amp;rsquo;s say, in a city we have a few roads connecting a few points. Let&amp;rsquo;s represent the roads using edges and the points using nodes. Let&amp;rsquo;s take two example graphs:
We want to set watchmen on some points. A watchman can guard all the roads connected to the point. The problem is, what is the minimum number of watchmen needed to cover all the roads?</description>
    </item>
    
    <item>
      <title>Weighted Activity Selection</title>
      <link>https://www.wikiod.com/dynamic-programming/weighted-activity-selection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/weighted-activity-selection/</guid>
      <description>Weighted Job Scheduling Algorithm # Weighted Job Scheduling Algorithm can also be denoted as Weighted Activity Selection Algorithm.
The problem is, given certain jobs with their start time and end time, and a profit you make when you finish the job, what is the maximum profit you can make given no two jobs can be executed in parallel?
This one looks like Activity Selection using Greedy Algorithm, but there&amp;rsquo;s an added twist.</description>
    </item>
    
    <item>
      <title>Knapsack Problem</title>
      <link>https://www.wikiod.com/dynamic-programming/knapsack-problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/knapsack-problem/</guid>
      <description>The knapsack problem or rucksack problem is a problem in combinatorial optimization. Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by fixed-size knapsack and must fill it with the most valuable items.</description>
    </item>
    
    <item>
      <title>Subsequence Related Algorithms</title>
      <link>https://www.wikiod.com/dynamic-programming/subsequence-related-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/subsequence-related-algorithms/</guid>
      <description>Longest Increasing Subsequence # The task is to find the length of the longest subsequence in a given array of integers such that all elements of the subsequence are sorted in ascending order. For example, the length of the longest increasing subsequence(LIS) for {15, 27, 14, 38, 26, 55, 46, 65, 85} is 6 and the longest increasing subsequence is {15, 27, 38, 55, 65, 85}. Again for {3, 4, -1, 0, 6, 2, 3} length of LIS is 4 and the subsequence is {-1, 0, 2, 3}.</description>
    </item>
    
    <item>
      <title>Dynamic Time Warping</title>
      <link>https://www.wikiod.com/dynamic-programming/dynamic-time-warping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/dynamic-time-warping/</guid>
      <description>Introduction To Dynamic Time Warping # Dynamic Time Warping(DTW) is an algorithm for measuring similarity between two temporal sequences which may vary in speed. For instance, similarities in walking could be detected using DTW, even if one person was walking faster than the other, or if there were accelerations and decelerations during the course of an observation. It can be used to match a sample voice command with others command, even if the person talks faster or slower than the prerecorded sample voice.</description>
    </item>
    
    <item>
      <title>Matrix Chain Multiplication</title>
      <link>https://www.wikiod.com/dynamic-programming/matrix-chain-multiplication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/matrix-chain-multiplication/</guid>
      <description>Recursive Solution # Matrix chain multiplication is an optimization problem that can be solved using dynamic programming. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices. The problem is not actually to perform the multiplications, but merely to decide the sequence of the matrix multiplications involved.
Let&amp;rsquo;s say we have two matrices A1 and A2 of dimension m * n and p * q.</description>
    </item>
    
    <item>
      <title>Rod Cutting</title>
      <link>https://www.wikiod.com/dynamic-programming/rod-cutting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dynamic-programming/rod-cutting/</guid>
      <description>Cutting the Rod to get the maximum profit # Given a rod of length n inches and an array of length m of prices that contains prices of all pieces of size smaller than n. We have to find the maximum value obtainable by cutting up the rod and selling the pieces. For example, if length of the rod is 8 and the values of different pieces are given as following, then the maximum obtainable value is 22.</description>
    </item>
    
  </channel>
</rss>
