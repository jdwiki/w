<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elixir Language Tutorial on </title>
    <link>https://www.wikiod.com/docs/elixir/</link>
    <description>Recent content in Elixir Language Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/elixir/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Elixir Language</title>
      <link>https://www.wikiod.com/elixir/getting-started-with-elixir-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/getting-started-with-elixir-language/</guid>
      <description>Hello World # For installation instructions on elixir check here, it describes instructions related to different platforms.
Elixir is a programming language that is created using erlang, and uses erlang&amp;rsquo;s BEAM runtime (like JVM for java).
We can use elixir in two modes: interactive shell iex or directly running using elixir command.
Place the following in a file named hello.exs:
IO.puts &amp;quot;Hello world!&amp;quot; From the command line, type the following command to execute the Elixir source file:</description>
    </item>
    
    <item>
      <title>IEx Console Tips &amp; Tricks</title>
      <link>https://www.wikiod.com/elixir/iex-console-tips--tricks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/iex-console-tips--tricks/</guid>
      <description>Get value from last command with v # iex(1)&amp;gt; 1 + 1 2 iex(2)&amp;gt; v 2 iex(3)&amp;gt; 1 + v 3 See also: https://www.wikiod.com/elixir/iex-console-tips&amp;ndash;tricks#Get the value of a previous command with v
Persistent history # By default, user input history in IEx do not persist across different sessions.
erlang-history adds history support to both the Erlang shell and IEx:
git clone git@github.com:ferd/erlang-history.git cd erlang-history sudo make install You can now access your previous inputs using the up and down arrow keys, even across different IEx sessions.</description>
    </item>
    
    <item>
      <title>Pattern matching</title>
      <link>https://www.wikiod.com/elixir/pattern-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/pattern-matching/</guid>
      <description>Pattern matching on a list # You can also pattern match on Elixir Data Structures such as Lists.
Lists
Matching on a list is quite simple.
[head | tail] = [1,2,3,4,5] # head == 1 # tail == [2,3,4,5] This works by matching the first (or more) elements in the list to the left hand side of the | (pipe) and the rest of the list to the right hand side variable of the |.</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://www.wikiod.com/elixir/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/functions/</guid>
      <description>Anonymous Functions # In Elixir, a common practice is to use anonymous functions. Creating an anonymous function is simple:
iex(1)&amp;gt; my_func = fn x -&amp;gt; x * 2 end #Function&amp;lt;6.52032458/1 in :erl_eval.expr/5&amp;gt; The general syntax is:
fn args -&amp;gt; output end For readability, you may put parenthesis around the arguments:
iex(2)&amp;gt; my_func = fn (x, y) -&amp;gt; x*y end #Function&amp;lt;12.52032458/2 in :erl_eval.expr/5&amp;gt; To invoke an anonymous function, call it by the assigned name and add .</description>
    </item>
    
    <item>
      <title>Lists</title>
      <link>https://www.wikiod.com/elixir/lists/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/lists/</guid>
      <description>Syntax # [] [1, 2, 3, 4] [1, 2] ++ [3, 4] # -&amp;gt; [1,2,3,4] hd([1, 2, 3, 4]) # -&amp;gt; 1 tl([1, 2, 3, 4]) # -&amp;gt; [2,3,4] [head | tail] [1 | [2, 3, 4]] # -&amp;gt; [1,2,3,4] [1 | [2 | [3 | [4 | []]]]] -&amp;gt; [1,2,3,4] &amp;lsquo;hello&amp;rsquo; = [?h, ?e, ?l, ?l, ?o] keyword_list = [a: 123, b: 456, c: 789] keyword_list[:a] # -&amp;gt; 123 Keyword Lists # Keyword lists are lists where each item in the list is a tuple of an atom followed by a value.</description>
    </item>
    
    <item>
      <title>Basic .gitignore for elixir program</title>
      <link>https://www.wikiod.com/elixir/basic-gitignore-for-elixir-program/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/basic-gitignore-for-elixir-program/</guid>
      <description>Note that the /rel folder may not be needed in your .gitignore file. This is generated if you are using a release management tool such as exrm
Example # ### Elixir ### /_build /cover /deps erl_crash.dump *.ez ### Erlang ### .eunit deps *.beam *.plt ebin rel/example_project .concrete/DEV_MODE .rebar ## Phoenix application /_build /db /deps /*.ez erl_crash.dump /node_modules /priv/static/ /config/prod.secret.exs /rel ## Standalone elixir application /_build /cover /deps erl_crash.dump *.ez /rel ## Auto-generated .</description>
    </item>
    
    <item>
      <title>Operators</title>
      <link>https://www.wikiod.com/elixir/operators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/operators/</guid>
      <description>The Pipe Operator # The Pipe Operator |&amp;gt; takes the result of an expression on the left and feeds it as the first parameter to a function on the right.
expression |&amp;gt; function Use the Pipe Operator to chain expressions together and to visually document the flow of a series of functions.
Consider the following:
Oven.bake(Ingredients.Mix([:flour, :cocoa, :sugar, :milk, :eggs, :butter]), :temperature) In the example, Oven.bake comes before Ingredients.mix, but it is executed last.</description>
    </item>
    
    <item>
      <title>Nodes</title>
      <link>https://www.wikiod.com/elixir/nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/nodes/</guid>
      <description>Connecting nodes on the same machine # Start two named nodes in two terminal windows:
&amp;gt;iex --name bob@127.0.0.1 iex(bob@127.0.0.1)&amp;gt; &amp;gt;iex --name frank@127.0.0.1 iex(frank@127.0.0.1)&amp;gt; Connect two nodes by instructing one node to connect:
iex(bob@127.0.0.1)&amp;gt; Node.connect :&amp;quot;frank@127.0.0.1&amp;quot; true The two nodes are now connected and aware of each other:
iex(bob@127.0.0.1)&amp;gt; Node.list [:&amp;quot;frank@127.0.0.1&amp;quot;] iex(frank@127.0.0.1)&amp;gt; Node.list [:&amp;quot;bob@127.0.0.1&amp;quot;] You can execute code on other nodes:
iex(bob@127.0.0.1)&amp;gt; greet = fn() -&amp;gt; IO.puts(&amp;quot;Hello from #{inspect(Node.self)}&amp;quot;) end iex(bob@127.0.0.1)&amp;gt; Node.</description>
    </item>
    
    <item>
      <title>Sigils</title>
      <link>https://www.wikiod.com/elixir/sigils/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/sigils/</guid>
      <description>Custom sigils # Custom sigils can be made by creating a method sigil_X where X is the letter you want to use (this can only be a single letter).
defmodule Sigils do def sigil_j(string, options) do # Split on the letter p, or do something more useful String.split string, &amp;quot;p&amp;quot; end # Use this sigil in this module, or import it to use it elsewhere end The options argument is a binary of the arguments given at the end of the sigil, for example:</description>
    </item>
    
    <item>
      <title>Built-in types</title>
      <link>https://www.wikiod.com/elixir/built-in-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/elixir/built-in-types/</guid>
      <description>Numbers # Elixir comes with integers and floating point numbers. An integer literal can be written in decimal, binary, octal and hexadecimal formats.
iex&amp;gt; x = 291 291 iex&amp;gt; x = 0b100100011 291 iex&amp;gt; x = 0o443 291 iex&amp;gt; x = 0x123 291 As Elixir uses bignum arithmetic, the range of integer is only limited by the available memory on the system.
Floating point numbers are double precision and follows IEEE-754 specification.</description>
    </item>
    
  </channel>
</rss>
