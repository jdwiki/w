<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C# Language Tutorial on </title>
    <link>https://www.wikiod.com/docs/csharp/</link>
    <description>Recent content in C# Language Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with C# Language</title>
      <link>https://www.wikiod.com/csharp/getting-started-with-c-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/getting-started-with-c-language/</guid>
      <description>Creating a new console application (Visual Studio) # Open Visual Studio
In the toolbar, go to File â†’ New Project
Select the Console Application project type
Open the file Program.cs in the Solution Explorer
Add the following code to Main():
public class Program { public static void Main() { // Prints a message to the console. System.Console.WriteLine(&amp;ldquo;Hello, World!&amp;rdquo;);
/* Wait for the user to press a key. This is a common way to prevent the console window from terminating and disappearing before the programmer can see the contents of the window, when the application is run via Start from within VS.</description>
    </item>
    
    <item>
      <title>C# 6.0 Features</title>
      <link>https://www.wikiod.com/csharp/c-60-features/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/c-60-features/</guid>
      <description>This sixth iteration of the C# language is provided by the Roslyn compiler. This compiler came out with version 4.6 of the .NET Framework, however it can generate code in a backward compatible manner to allow targeting earlier framework versions. C# version 6 code can be compiled in a fully backwards compatible manner to .NET 4.0. It can also be used for earlier frameworks, however some features that require additional framework support may not function correctly.</description>
    </item>
    
    <item>
      <title>C# 7.0 Features</title>
      <link>https://www.wikiod.com/csharp/c-70-features/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/c-70-features/</guid>
      <description>C# 7.0 is the seventh version of C#. This version contains some new features: language support for Tuples, local functions, out var declarations, digit separators, binary literals, pattern matching, throw expressions, ref return and ref local and extended expression bodied members list.
Official reference: What&amp;rsquo;s new in C# 7
Language support for Tuples # Basics # A tuple is an ordered, finite list of elements. Tuples are commonly used in programming as a means to work with one single entity collectively instead of individually working with each of the tuple&amp;rsquo;s elements, and to represent individual rows (ie.</description>
    </item>
    
    <item>
      <title>Extension Methods</title>
      <link>https://www.wikiod.com/csharp/extension-methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/extension-methods/</guid>
      <description>Syntax # public static ReturnType MyExtensionMethod(this TargetType target) public static ReturnType MyExtensionMethod(this TargetType target, TArg1 arg1, &amp;hellip;) Parameters # Parameter Details this The first parameter of an extension method should always be preceded by the this keyword, followed by the identifier with which to refer to the &amp;ldquo;current&amp;rdquo; instance of the object you are extending Extension methods are syntactic sugar that allow static methods to be invoked on object instances as if they were a member of the type itself.</description>
    </item>
    
    <item>
      <title>LINQ Queries</title>
      <link>https://www.wikiod.com/csharp/linq-queries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/linq-queries/</guid>
      <description>LINQ is an acronym which stands for Language INtegrated Query. It is a concept which integrates a query language by offering a consistent model for working with data across various kinds of data sources and formats; you use the same basic coding patterns to query and transform data in XML documents, SQL databases, ADO.NET Datasets, .NET collections, and any other format for which a LINQ provider is available.
Syntax # Query syntax :</description>
    </item>
    
    <item>
      <title>Keywords</title>
      <link>https://www.wikiod.com/csharp/keywords/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/keywords/</guid>
      <description>Keywords are predefined, reserved identifiers with special meaning to the compiler. They cannot be used as identifiers in your program without the @ prefix. For example @if is a legal identifier but not the keyword if.
C# has a predefined collection of &amp;ldquo;keywords&amp;rdquo; (or reserved words) which each have a special function. These words can not be used as identifiers (names for variables, methods, classes, etc.) unless prefixed with @.</description>
    </item>
    
    <item>
      <title>Yield Keyword</title>
      <link>https://www.wikiod.com/csharp/yield-keyword/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/yield-keyword/</guid>
      <description>When you use the yield keyword in a statement, you indicate that the method, operator, or get accessor in which it appears is an iterator. Using yield to define an iterator removes the need for an explicit extra class (the class that holds the state for an enumeration) when you implement the IEnumerable and IEnumerator pattern for a custom collection type.
Syntax # yield return [TYPE] yield break Putting the yield keyword in a method with the return type of IEnumerable, IEnumerable&amp;lt;T&amp;gt;, IEnumerator, or IEnumerator&amp;lt;T&amp;gt; tells the compiler to generate an implementation of the return type (IEnumerable or IEnumerator) that, when looped over, runs the method up to each &amp;ldquo;yield&amp;rdquo; to get each result.</description>
    </item>
    
    <item>
      <title>Using Statement</title>
      <link>https://www.wikiod.com/csharp/using-statement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/using-statement/</guid>
      <description>Provides a convenient syntax that ensures the correct use of IDisposable objects.
Syntax # using (disposable) { } using (IDisposable disposable = new MyDisposable()) { } The object in the using statement must implement the IDisposable interface.
using(var obj = new MyObject()) { } class MyObject : IDisposable { public void Dispose() { // Cleanup } } More complete examples for IDisposable implementation can be found at the MSDN docs.</description>
    </item>
    
    <item>
      <title>Exception Handling</title>
      <link>https://www.wikiod.com/csharp/exception-handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/exception-handling/</guid>
      <description>Creating Custom Exceptions # You are allowed to implement custom exceptions that can be thrown just like any other exception. This makes sense when you want to make your exceptions distinguishable from other errors during runtime.
In this example we will create a custom exception for clear handling of problems the application may have while parsing a complex input.
Creating Custom Exception Class # To create a custom exception create a sub-class of Exception:</description>
    </item>
    
    <item>
      <title>Async-Await</title>
      <link>https://www.wikiod.com/csharp/async-await/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/csharp/async-await/</guid>
      <description>In C#, a method declared async won&amp;rsquo;t block within a synchronous process, in case of you&amp;rsquo;re using I/O based operations (e.g. web access, working with files, &amp;hellip;). The result of such async marked methods may be awaited via the use of the awaitkeyword.
An async method can return void, Task or Task&amp;lt;T&amp;gt;.
The return type Task will wait for the method to finish and the result will be void. Task&amp;lt;T&amp;gt; will return a value from type T after the method completes.</description>
    </item>
    
  </channel>
</rss>
