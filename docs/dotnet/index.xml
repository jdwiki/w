<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.NET Framework Tutorial on </title>
    <link>https://www.wikiod.com/docs/dotnet/</link>
    <description>Recent content in .NET Framework Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/dotnet/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with .NET Framework</title>
      <link>https://www.wikiod.com/dotnet/getting-started-with-net-framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/getting-started-with-net-framework/</guid>
      <description>Hello World in C# # using System; class Program { // The Main() function is the first function to be executed in a program static void Main() { // Write the string &amp;quot;Hello World to the standard out Console.WriteLine(&amp;quot;Hello World&amp;quot;); } } Console.WriteLine has several overloads. In this case, the string &amp;ldquo;Hello World&amp;rdquo; is the parameter, and it will output the &amp;ldquo;Hello World&amp;rdquo; to the standard out stream during execution. Other overloads may call the .</description>
    </item>
    
    <item>
      <title>LINQ</title>
      <link>https://www.wikiod.com/dotnet/linq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/linq/</guid>
      <description>LINQ (Language Integrated Query) is an expression that retrieves data from a data source. LINQ simplifies this situation by offering a consistent model for working with data across various kinds of data sources and formats. In a LINQ query, you are always working with objects. You use the same basic coding patterns to query and transform data in XML documents, SQL databases, ADO.NET Datasets, .NET collections, and any other format for which a provider is available.</description>
    </item>
    
    <item>
      <title>JSON Serialization</title>
      <link>https://www.wikiod.com/dotnet/json-serialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/json-serialization/</guid>
      <description>JavaScriptSerializer vs Json.NET
The JavaScriptSerializer class was introducted in .NET 3.5 and is used internally by .NET&amp;rsquo;s asynchronous communication layer for AJAX-enabled applications. It can be used to work with JSON in managed code.
Despite the existence of the JavaScriptSerializer class, Microsoft recommends using the open source Json.NET library for serialization and deserialization. Json.NET offers better performance and a friendlier interface for mapping JSON to custom classes (a custom JavaScriptConverter object would be needed to accomplish the same with JavaScriptSerializer).</description>
    </item>
    
    <item>
      <title>Task Parallel Library (TPL)</title>
      <link>https://www.wikiod.com/dotnet/task-parallel-library-tpl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/task-parallel-library-tpl/</guid>
      <description>Purpose And Use Cases # The purpose of the Task Parallel Library is to simplify the process of writing and maintaining multithreaded and parallel code.
Some Use Cases*:
Keeping a UI responsive by running background work on separate task Distributing workload Allowing a client application to send and receive requests at the same time (rest, TCP/UDP, ect) Reading and/or writing multiple files at once *Code should be considered on a case by case basis for multithreading.</description>
    </item>
    
    <item>
      <title>Exceptions</title>
      <link>https://www.wikiod.com/dotnet/exceptions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/exceptions/</guid>
      <description>Related:
MSDN: Exceptions and Exception Handling (C# Programming Guide) MSDN: Handling and Throwing Exceptions MSDN: CA1031: Do not catch general exception types MSDN: try-catch (C# Reference) Catching and rethrowing caught exceptions # When you want to catch an exception and do something, but you can&amp;rsquo;t continue execution of the current block of code because of the exception, you may want to rethrow the exception to the next exception handler in the call stack.</description>
    </item>
    
    <item>
      <title>DateTime parsing</title>
      <link>https://www.wikiod.com/dotnet/datetime-parsing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/datetime-parsing/</guid>
      <description>ParseExact # var dateString = &amp;quot;2015-11-24&amp;quot;; var date = DateTime.ParseExact(dateString, &amp;quot;yyyy-MM-dd&amp;quot;, null); Console.WriteLine(date); 11/24/2015 12:00:00 AM
Note that passing CultureInfo.CurrentCulture as the third parameter is identical to passing null. Or, you can pass a specific culture.
Format Strings
Input string can be in any format that matches the format string
var date = DateTime.ParseExact(&amp;quot;24|201511&amp;quot;, &amp;quot;dd|yyyyMM&amp;quot;, null); Console.WriteLine(date); 11/24/2015 12:00:00 AM
Any characters that are not format specifiers are treated as literals</description>
    </item>
    
    <item>
      <title>Dictionaries</title>
      <link>https://www.wikiod.com/dotnet/dictionaries/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/dictionaries/</guid>
      <description>Initializing a Dictionary with a Collection Initializer # // Translates to `dict.Add(1, &amp;quot;First&amp;quot;)` etc. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { { 1, &amp;quot;First&amp;quot; }, { 2, &amp;quot;Second&amp;quot; }, { 3, &amp;quot;Third&amp;quot; } }; // Translates to `dict[1] = &amp;quot;First&amp;quot;` etc. // Works in C# 6.0. var dict = new Dictionary&amp;lt;int, string&amp;gt;() { [1] = &amp;quot;First&amp;quot;, [2] = &amp;quot;Second&amp;quot;, [3] = &amp;quot;Third&amp;quot; }; Adding to a Dictionary # Dictionary&amp;lt;int, string&amp;gt; dict = new Dictionary&amp;lt;int, string&amp;gt;(); dict.</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://www.wikiod.com/dotnet/dependency-injection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/dependency-injection/</guid>
      <description>Problems Solved By Dependency Injection
If we didn&amp;rsquo;t use dependency injection, the Greeter class might look more like this:
public class ControlFreakGreeter { public void Greet() { var greetingProvider = new SqlGreetingProvider( ConfigurationManager.ConnectionStrings[&amp;quot;myConnectionString&amp;quot;].ConnectionString); var greeting = greetingProvider.GetGreeting(); Console.WriteLine(greeting); } } It&amp;rsquo;s a &amp;ldquo;control freak&amp;rdquo; because it controls creating the class that provides the greeting, it controls where the SQL connection string comes from, and it controls the output.
Using dependency injection, the Greeter class relinquishes those responsibilities in favor of a single responsibility, writing a greeting provided to it.</description>
    </item>
    
    <item>
      <title>ADO.NET</title>
      <link>https://www.wikiod.com/dotnet/adonet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/adonet/</guid>
      <description>ADO(ActiveX Data Objects).Net is a tool provided by Microsoft which provides access to data sources such as SQL Server, Oracle, and XML through its components. .Net front-end applications can retrieve, create, and manipulate data, once they are connected to a data source through ADO.Net with appropriate privileges.
ADO.Net provides a connection-less architecture. It is a secure approach to interact with a database, since, the connection doesn&amp;rsquo;t have to be maintained during the entire session.</description>
    </item>
    
    <item>
      <title>HTTP clients</title>
      <link>https://www.wikiod.com/dotnet/http-clients/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/dotnet/http-clients/</guid>
      <description>The currently relevant HTTP/1.1 RFCs are:
7230: Message Syntax and Routing 7231: Semantics and Content 7232: Conditional Requests 7233: Range Requests 7234: Caching 7235: Authenticaion 7239: Forwarded HTTP Extension 7240: Prefer Header for HTTP There&amp;rsquo;s also the following informational RFCs:
7236: Authentication Scheme Registrations 7237: Method Registrations And the experimental RFC:
7238: The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect) Related protocols:
4918: HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV) 4791: Calendaring Extensions to WebDAV (CalDAV) Reading GET response as string using System.</description>
    </item>
    
  </channel>
</rss>
