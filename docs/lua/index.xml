<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lua Tutorial on </title>
    <link>https://www.wikiod.com/docs/lua/</link>
    <description>Recent content in Lua Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/lua/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Lua</title>
      <link>https://www.wikiod.com/lua/getting-started-with-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/getting-started-with-lua/</guid>
      <description>Comments # Single-line comments in Lua start with -- and continue until the end of line:
-- this is single line comment -- need another line -- huh? Block comments start with --[[ and end with ]]:
--[[ This is block comment. So, it can go on... and on... and on.... ]] Block comments use the same style of delimiters as long strings; any number of equal signs can be added between the brackets to delimit a comment:</description>
    </item>
    
    <item>
      <title>Pattern matching</title>
      <link>https://www.wikiod.com/lua/pattern-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/pattern-matching/</guid>
      <description>Syntax # string.find(str, pattern [, init [, plain]]) &amp;ndash; Returns start and end index of match in str
string.match(str, pattern [, index]) &amp;ndash; Matches a pattern once (starting at index)
string.gmatch(str, pattern) &amp;ndash; Returns a function that iterates through all matches in str
string.gsub(str, pattern, repl [, n]) &amp;ndash; Replaces substrings (up to a max of n times)
. represents all characters
%a represents all letters
%l represents all lowercase letters</description>
    </item>
    
    <item>
      <title>Sets</title>
      <link>https://www.wikiod.com/lua/sets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/sets/</guid>
      <description>Using a Table as a Set # Create a set # local set = {} -- empty set Create a set with elements by setting their value to true:
local set = {pear=true, plum=true} -- or initialize by adding the value of a variable: local fruit = &#39;orange&#39; local other_set = {[fruit] = true} -- adds &#39;orange&#39; Add a member to the set # add a member by setting its value to true</description>
    </item>
    
    <item>
      <title>Tables</title>
      <link>https://www.wikiod.com/lua/tables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/tables/</guid>
      <description>Syntax # ipairs(numeric_table) &amp;ndash; Lua table with numeric indices iterator pairs(input_table) &amp;ndash; generic Lua table iterator key, value = next(input_table, input_key) &amp;ndash; Lua table value selector table.insert(input_table, [position], value) &amp;ndash; insert specified value into the input table removed_value = table.remove(input_table, [position]) &amp;ndash; pop last or remove value specified by position Tables are the only built-in data structure available in Lua. This is either elegant simplicity or confusing, depending on how you look at it.</description>
    </item>
    
    <item>
      <title>Booleans in Lua</title>
      <link>https://www.wikiod.com/lua/booleans-in-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/booleans-in-lua/</guid>
      <description>Booleans, truth, and falsity are straightforward in Lua. To review:
There is a boolean type with exactly two values: true and false. In a conditional context (if, elseif, while, until), a boolean is not required. Any expression can be used. In a conditional context, false and nil count as false, and everything else counts as true. Although 3 already implies this: if you&amp;rsquo;re coming from other languages, remember that 0 and the empty string count as true in conditional contexts in Lua.</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://www.wikiod.com/lua/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/functions/</guid>
      <description>Syntax # funcname = function(paramA, paramB, &amp;hellip;) body; return exprlist end &amp;ndash; a simple function function funcname(paramA, paramB, &amp;hellip;) body; return exprlist end &amp;ndash; shorthand for above local funcname = function(paramA, paramB, &amp;hellip;) body; return exprlist end &amp;ndash; a lambda local funcname; funcname = function(paramA, paramB, &amp;hellip;) body; return exprlist end &amp;ndash; lambda that can do recursive calls local function funcname(paramA, paramB, &amp;hellip;) body; return exprlist end &amp;ndash; shorthand for above funcname(paramA, paramB, &amp;hellip;) &amp;ndash; call a function local var = var or &amp;ldquo;Default&amp;rdquo; &amp;ndash; a default parameter return nil, &amp;ldquo;error messages&amp;rdquo; &amp;ndash; standard way to abort with an error Functions are usually set with function a(b,c) .</description>
    </item>
    
    <item>
      <title>Error Handling</title>
      <link>https://www.wikiod.com/lua/error-handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/error-handling/</guid>
      <description>Handling errors in Lua # Assuming we have the following function:
function foo(tab) return tab.a end -- Script execution errors out w/ a stacktrace when tab is not a table Let&amp;rsquo;s improve it a bit
function foo(tab) if type(tab) ~= &amp;quot;table&amp;quot; then error(&amp;quot;Argument 1 is not a table!&amp;quot;, 2) end return tab.a end -- This gives us more information, but script will still error out If we don&amp;rsquo;t want a function to crash a program even in case of an error, it is standard in lua to do the following:</description>
    </item>
    
    <item>
      <title>Introduction to Lua C API</title>
      <link>https://www.wikiod.com/lua/introduction-to-lua-c-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/introduction-to-lua-c-api/</guid>
      <description>Syntax # lua_State *L = lua_open(); // Create a new VM state; Lua 5.0 lua_State *L = luaL_newstate(); // Create a new VM state; Lua 5.1+ int luaL_dofile(lua_State *L, const char *filename); // Run a lua script with the given filename using the specified lua_State void luaL_openlibs(lua_State *L); // Load all standard libraries into the specified lua_State void lua_close(lua_State *L); // Close VM state and release any resources inside void lua_call(lua_State *L, int nargs, int nresults); // Call the luavalue at index -(nargs + 1) Lua as well provides a proper C API to it&amp;rsquo;s Virtual Machine.</description>
    </item>
    
    <item>
      <title>Metatables</title>
      <link>https://www.wikiod.com/lua/metatables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/metatables/</guid>
      <description>Syntax # [[local] mt = ]getmetatable(t) &amp;ndash;&amp;gt; retrieve associated metatable for &amp;lsquo;t&amp;rsquo; [[local] t = ]setmetatable(t, mt) &amp;ndash;&amp;gt; set the metatable for &amp;lsquo;t&amp;rsquo; to &amp;lsquo;mt&amp;rsquo; and returns &amp;lsquo;t&amp;rsquo; Parameters # Parameter Details t Variable referring to a lua table; can also be a table literal. mt Table to use as a metatable; can have zero or more metamethod fields set. There are some metamethods not mentioned here. For the full list and their usage, see the corresponding entry in the lua manual.</description>
    </item>
    
    <item>
      <title>Iterators</title>
      <link>https://www.wikiod.com/lua/iterators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/lua/iterators/</guid>
      <description>Stateful Iterators # Stateful iterators carry some additional information about the current state of the iterator.
Using Tables # The addition state can be packed into the generic for loop&amp;rsquo;s invariant state.
local function chars_iter(t, i) local i = i + 1 if i &amp;lt;= t.len then return i, t.s:sub(i, i) end end local function chars(s) -- the iterators state local t = { s = s, -- the subject len = #s -- cached length } return chars_iter, t, 0 end for i, c in chars &#39;abcde&#39; do print(i, c) --&amp;gt; 1 a, 2 b, 3 c, 4 d, 5 e end Using Closures # Additional state can be wrapped within a function closure.</description>
    </item>
    
  </channel>
</rss>
