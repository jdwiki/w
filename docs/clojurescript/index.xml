<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clojurescript Tutorial on </title>
    <link>https://www.wikiod.com/docs/clojurescript/</link>
    <description>Recent content in clojurescript Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with clojurescript</title>
      <link>https://www.wikiod.com/clojurescript/getting-started-with-clojurescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/getting-started-with-clojurescript/</guid>
      <description>Installation or Setup # Leiningen # Note: If you&amp;rsquo;re going to use Leiningen, you first need to download and install JDK 6 or newer.
The easiest way to get started with Clojure is to download and install Leiningen, the de facto standard tool to manage Clojure projects.
Linux: # curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein &amp;gt; ~/bin/lein export PATH=$PATH:~/bin chmod 755 ~/bin/lein lein OS X: # Follow Linux steps above or
Install with [Homebrew]:</description>
    </item>
    
    <item>
      <title>Getting Started with Reagent</title>
      <link>https://www.wikiod.com/clojurescript/getting-started-with-reagent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/getting-started-with-reagent/</guid>
      <description>Reagent is a library that implements elements of React.js into ClojureScript, like the creations of custom &amp;ldquo;tags&amp;rdquo;, which is implemented in Reagent through functions.
UI using Reagent and Hiccup # Reagent is an interface between ClojureScript and react. It allows you to define efficient React components using nothing but plain ClojureScript functions and data, that describe your UI using a Hiccup-like syntax.
Example:-
(defn sample-component [] [:div [:p &amp;quot;I am a component!</description>
    </item>
    
    <item>
      <title>Figwheel</title>
      <link>https://www.wikiod.com/clojurescript/figwheel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/figwheel/</guid>
      <description>Figwheel automatically rebuilds your clojurescript code when source files change and reloads code in browser. Reload works without refreshing page and you can preserve some of app&amp;rsquo;s state between reloads by using defonce.
It is alternative to REPL-based development (although it includes REPL too). Instead of re-evaling changed functions in REPL, it reloads all code, and you can use println to see result of expression evaluation in browser&amp;rsquo;s js console.</description>
    </item>
    
    <item>
      <title>lein-cljsbuild</title>
      <link>https://www.wikiod.com/clojurescript/lein-cljsbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/lein-cljsbuild/</guid>
      <description>More details on parameters for lein-clsjbuild can be found in their example project.
ClojureScript dev and production build # Add a :cljsbuild node like the following to your project.clj file.
:cljsbuild { :builds { ;;Different target goals should have different names. ;;We have the dev build here :dev { ;;The ClojureScript code should reside in these directories :source-paths [&amp;quot;src-cljs&amp;quot;] :compiler { ;;This is the target output file ;;This will include none of the goog code.</description>
    </item>
    
    <item>
      <title>JavaScript Events</title>
      <link>https://www.wikiod.com/clojurescript/javascript-events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/javascript-events/</guid>
      <description>Syntax # (goog.events dom-element event-type event-handler-function) ;;Creates a Google Closure event listener (.addEventListener dom-element load-event) ;;Creates normal JavaScript event listener. Can be browser specific. All Closure event names can be found in their documentation on the EventType enum.
Adding Event to Button Using Closure Library # (ns so-doc.events (:require [goog.dom :as dom] [goog.events :as events])) (defn handle-click [event] ;an event object is passed to all events (js/alert &amp;quot;button pressed&amp;quot;)) (events/listen (dom/getElement &amp;quot;button&amp;quot;); This is the dom element the event comes from (.</description>
    </item>
    
    <item>
      <title>State Management with re-frame (httpsgithub.comDay8re-frame)</title>
      <link>https://www.wikiod.com/clojurescript/state-management-with-re-frame-httpsgithubcomday8re-frame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/clojurescript/state-management-with-re-frame-httpsgithubcomday8re-frame/</guid>
      <description>It starts to become difficult when we think clojurescript as a functionally pure language, that holds state for it UI components. It is simply, not possible.
However, it is possible to separate out individual components as well as their states. We can do it by storing data/state in reagent/atom. But when there are lots of states and lots of dependencies, things quickly become confusing and we start to wish for a out of the box solution for our state management.</description>
    </item>
    
  </channel>
</rss>
