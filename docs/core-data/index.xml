<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>core-data Tutorial on </title>
    <link>https://www.wikiod.com/docs/core-data/</link>
    <description>Recent content in core-data Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/core-data/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with core-data</title>
      <link>https://www.wikiod.com/core-data/getting-started-with-core-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/getting-started-with-core-data/</guid>
      <description>Creating Your First Model # Select the .xcdatamodeld file. You will notice you have no entities. You will have to create one yourself. At the bottom of Xcode you will notice a button that says &amp;ldquo;Add Entity&amp;rdquo; click it and you will have a new entity for you to work with on the project. In this step there are a few points to mention. First is that you changed your entity name here the entity is given the name Person.</description>
    </item>
    
    <item>
      <title>Core Data Stack</title>
      <link>https://www.wikiod.com/core-data/core-data-stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/core-data-stack/</guid>
      <description>This is an implementation of the Core Data Stack which is initially placed in the AppDelegate file if the project is created with Core Data when project is created. These functions can also implemented in separate class for CoreDataStack.swift. One of the major functions is to get the NSManagedObjectContext.
Objective-C # - (NSManagedObjectContext *)managedObjectContext {...} Swift 2 # lazy var managedObjectContext: NSManagedObjectContext = {...} Swift 3 # lazy var persistentContainer: NSPersistentContainer = {.</description>
    </item>
    
    <item>
      <title>Creating an Core Data Model</title>
      <link>https://www.wikiod.com/core-data/creating-an-core-data-model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/creating-an-core-data-model/</guid>
      <description>Attribute types include: Undefined, Integer 16, Integer 32, Integer 64, Decimal, Double, Float, String, Boolean, Date, Binary, Data, or Transformable
When defining an Entity as abstract you won&amp;rsquo;t be creating any instances of that entity. For example a Person would be abstract and a Employee or Customer would be a concrete subentities.
Transient attributes are properties that you define as part of the model, but which are not saved to the persistent store as part of an entity instanceâ€™s data.</description>
    </item>
    
    <item>
      <title>Using Predicates</title>
      <link>https://www.wikiod.com/core-data/using-predicates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/using-predicates/</guid>
      <description>Matching an exact string # let fetchRequest = NSFetchRequest(entityName: &amp;quot;Foo&amp;quot;) var thePredicate: NSPredicate? thePredicate = NSPredicate(format: &amp;quot;message == &#39;example&#39;&amp;quot;) The entity Foo has a message string attribute
Substitutions # Rather than passing a static string as a predicate&amp;rsquo;s criteria. It is possible to substitute values by using format specifiers. There are five format specifiers:
%K is a var arg substitution for a key path. %@ is a var arg substitution for an object value-often a string, number, date, or an array.</description>
    </item>
    
    <item>
      <title>NSFetchedResultsController</title>
      <link>https://www.wikiod.com/core-data/nsfetchedresultscontroller/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/nsfetchedresultscontroller/</guid>
      <description>NSFetchedResultsController is a connection between core-data table (entity in core-data, table in sqlite) and UITableView. UITableView can be attached to any core-data entity using NSFetchedResultsController and UITableView will be updated as and when core-data updates that entity/table.
NSFetchedResultsController for UITableView # class ConversationsTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { private var fetchedResultsController: NSFetchedResultsController&amp;lt;Conversation&amp;gt;! override func viewDidLoad() { super.viewDidLoad() initializeFetchedResultsController() } private func initializeFetchedResultsController() { let request = NSFetchRequest&amp;lt;Conversation&amp;gt;(entityName: &amp;quot;Conversation&amp;quot;) let timeSort = NSSortDescriptor(key: &amp;quot;lastMessageTime&amp;quot;, ascending: false) request.</description>
    </item>
    
    <item>
      <title>Sort Descriptors</title>
      <link>https://www.wikiod.com/core-data/sort-descriptors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/core-data/sort-descriptors/</guid>
      <description>Ordering Data Returned By Fetch Requests # Set the NSFetchRequest property sortDescriptors to determine how data is returned.
let fetchRequest = NSFetchRequest(entityName: &amp;quot;NAME_OF_ENTITY&amp;quot;) let sortDescriptor = NSSortDescriptor(key: &amp;quot;NAME_OF_ATTRIBUTE&amp;quot;, ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] Multiple Sort Descriptors # You can also set multiple sort descriptors, to sort by one attribute within another. For example, return all entries ordered by date, and by name within each date:
let fetchRequest = NSFetchRequest(entityName: &amp;quot;NAME_OF_ENTITY&amp;quot;) let sortDescriptor1 = NSSortDescriptor(key: &amp;quot;name&amp;quot;, ascending: true) let sortDescriptor2 = NSSortDescriptor(key: &amp;quot;date&amp;quot;, ascending: true) fetchRequest.</description>
    </item>
    
  </channel>
</rss>
