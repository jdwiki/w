<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Intel x86 Assembly Language &amp; Microarchitecture Tutorial on </title>
    <link>https://www.wikiod.com/docs/x86/</link>
    <description>Recent content in Intel x86 Assembly Language &amp; Microarchitecture Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/x86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with Intel x86 Assembly Language &amp; Microarchitecture</title>
      <link>https://www.wikiod.com/x86/getting-started-with-intel-x86-assembly-language--microarchitecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/getting-started-with-intel-x86-assembly-language--microarchitecture/</guid>
      <description>x86 Linux Hello World Example # This is a basic Hello World program in NASM assembly for 32-bit x86 Linux, using system calls directly (without any libc function calls). It&amp;rsquo;s a lot to take in, but over time it will become understandable. Lines starting with a semicolon(;) are comments.
If you don&amp;rsquo;t already know low-level Unix systems programming, you might want to just write functions in asm and call them from C or C++ programs.</description>
    </item>
    
    <item>
      <title>Calling Conventions</title>
      <link>https://www.wikiod.com/x86/calling-conventions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/calling-conventions/</guid>
      <description>Resources # Overviews/comparisons: Agner Fog&amp;rsquo;s nice calling convention guide. Also, x86 ABIs (wikipedia): calling conventions for functions, including x86-64 Windows and System V (Linux).
SystemV x86-64 ABI (official standard). Used by all OSes but Windows. (This github wiki page, kept up to date by H.J. Lu, has links to 32bit, 64bit, and x32. Also links to the official forum for ABI maintainers/contributors.) Also note that clang/gcc sign/zero extend narrow args to 32bit, even though the ABI as written doesn&amp;rsquo;t require it.</description>
    </item>
    
    <item>
      <title>Multiprocessor management</title>
      <link>https://www.wikiod.com/x86/multiprocessor-management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/multiprocessor-management/</guid>
      <description>Parameters # LAPIC register Address (Relative to APIC BASE) Local APIC ID Register +20h Spurious Interrupt Vector Register +0f0h Interrupt Command Register (ICR); bits 0-31 +300h Interrupt Command Register (ICR); bits 32-63 +310h In order to access the LAPIC registers a segment must be able to reach the address range starting at APIC Base (in IA32_APIC_BASE).
This address is relocatable and can theoretically be set to point somewhere in the lower memory, thus making the range addressable in real mode.</description>
    </item>
    
    <item>
      <title>Register Fundamentals</title>
      <link>https://www.wikiod.com/x86/register-fundamentals/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/register-fundamentals/</guid>
      <description>16-bit Registers # When Intel defined the original 8086, it was a 16-bit processor with a 20-bit address bus (see below). They defined 8 general-purpose 16-bit registers - but gave them specific roles for certain instructions:
AX The Accumulator register.
Many opcodes either assumed this register, or were faster if it was specified. DX The Data register.
This was sometimes combined as the high 16 bits of a 32-bit value with AX - for example, as the result of a multiply.</description>
    </item>
    
    <item>
      <title>Assemblers</title>
      <link>https://www.wikiod.com/x86/assemblers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/assemblers/</guid>
      <description>Netwide Assembler - NASM # NASM is by far the most ported assembler for the x86 architecture - it&amp;rsquo;s available for practically every Operating System based on the x86 (even being included with MacOS), and is available as a cross-platform assembler on other platforms.
This assembler uses Intel syntax, but it is different from others because it focuses heavily on its own &amp;ldquo;macro&amp;rdquo; language - this permits the programmer to build up more complex expressions using simpler definitions, allowing new &amp;ldquo;instructions&amp;rdquo; to be created.</description>
    </item>
    
    <item>
      <title>System Call Mechanisms</title>
      <link>https://www.wikiod.com/x86/system-call-mechanisms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/system-call-mechanisms/</guid>
      <description>BIOS calls # How to interact with the BIOS # The Basic Input/Output System, or BIOS, is what controls the computer before any operating system runs. To access services provided by the BIOS, assembly code uses interrupts. An interrupt takes the form of
int &amp;lt;interrupt&amp;gt; ; interrupt must be a literal number, not in a register or memory The interrupt number must be between 0 and 255 (0x00 - 0xFF), inclusive.</description>
    </item>
    
    <item>
      <title>Optimization</title>
      <link>https://www.wikiod.com/x86/optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/optimization/</guid>
      <description>The x86 family has been around for a long time, and as such there are many tricks and techniques that have been discovered and developed that are public knowledge - or maybe not so public.
Most of these tricks take advantage of the fact that many instructions effectively do the same thing - but different versions are quicker, or save memory, or don&amp;rsquo;t affect the Flags.
Herein are a number of tricks that have been discovered.</description>
    </item>
    
    <item>
      <title>Real vs Protected modes</title>
      <link>https://www.wikiod.com/x86/real-vs-protected-modes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/real-vs-protected-modes/</guid>
      <description>Real Mode # When Intel designed the original x86, the 8086 (and 8088 derivative), they included Segmentation to allow the 16-bit processor to access more than 16 bits worth of address. They did this by making the 16-bit addresses be relative to a given 16-bit Segment Register, of which they defined four: Code Segment (CS), Data Segment (DS), Extra Segment (ES) and Stack Segment (SS).
Most instructions implied which Segment Register to use: instructions were fecthed from the Code Segment, PUSH and POP implied the Stack Segment, and simple data references implied the Data Segment - although this could be overridden to access memory in any of the other Segments.</description>
    </item>
    
    <item>
      <title>Control Flow</title>
      <link>https://www.wikiod.com/x86/control-flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/control-flow/</guid>
      <description>Testing conditions # In order to use a conditional jump a condition must be tested. Testing a condition here refers only to the act of checking the flags, the actual jumping is described under [Conditional jumps](https://www.wikiod.com/x86/control-flow#Conditional jumps).
x86 tests conditions by relying on the EFLAGS register, which holds a set of flags that each instruction can potentially set.
Arithmetic instructions, like sub or add, and logical instructions, like xor or and, obviously &amp;ldquo;set the flags&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Paging - Virtual Addressing and Memory</title>
      <link>https://www.wikiod.com/x86/paging---virtual-addressing-and-memory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/x86/paging---virtual-addressing-and-memory/</guid>
      <description>Introduction # History # The first computers # Early computers had a block of memory that the programmer put code and data into, and the CPU executed within this environment. Given that the computers then were very expensive, it was unfortunate that it would do one job, stop and wait for the next job to be loaded into it, and then process that one.
Multi-user, multi-processing # So computers quickly became more sophisticated and supported multiple users and/or programs simultaneously - but that&amp;rsquo;s when problems started to arise with the simple &amp;ldquo;one block of memory&amp;rdquo; idea.</description>
    </item>
    
  </channel>
</rss>
