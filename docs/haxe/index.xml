<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haxe Tutorial on </title>
    <link>https://www.wikiod.com/docs/haxe/</link>
    <description>Recent content in haxe Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/haxe/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with haxe</title>
      <link>https://www.wikiod.com/haxe/getting-started-with-haxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/getting-started-with-haxe/</guid>
      <description>Hello World # Requirements # A version of the Haxe toolkit must be installed Haxe must be present in your system path Command line must be accessible Code # Navigate to a desired project directory and create a Test.hx source file with the following content:
class Test { static function main() { trace(&amp;quot;Hello world&amp;quot;); } } Haxe source files are called modules. A module should define a type (abstract, class, enum, interface, or typedef) with the same identifier as the module name - in this case the Test class.</description>
    </item>
    
    <item>
      <title>Enums</title>
      <link>https://www.wikiod.com/haxe/enums/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/enums/</guid>
      <description>Syntax # enum identifier { constructors } Capturing enum values # Values passed as enum constructor arguments can be captured into variables by use of pattern matching.
Assume the following enum:
enum Color { RGB(r : Int, g : Int, b : Int); HSV(h : Int, s : Float, v : Float); } The red channel value can be captured as follows:
var color = Color.RGB(255, 127, 0); var red = switch (color) { // Match the Color.</description>
    </item>
    
    <item>
      <title>Loops</title>
      <link>https://www.wikiod.com/haxe/loops/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/loops/</guid>
      <description>Syntax # for (variable identifier in iterating collection) { expression } while (condition) { expression } do { expression } while (condition); break; continue; For # For-loops iterate over an iterating collection. An iterating collection is any class which structurally unifies with Iterator&amp;lt;T&amp;gt; or Iterable&amp;lt;T&amp;gt; types from the Haxe standard library.
A for-loop which logs numbers in range 0 to 10 (exclusive) can be written as follows:
for (i in 0.</description>
    </item>
    
    <item>
      <title>Pattern matching</title>
      <link>https://www.wikiod.com/haxe/pattern-matching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/pattern-matching/</guid>
      <description>Pattern matching is the process of branching depending on provided patterns. All pattern matching is done within a switch expression, and individual case expressions represent the patterns.
The fundamental rules of pattern matching are:
patterns will always be matched from top to bottom; the topmost pattern that matches the input value has its expression executed; a _ pattern matches anything, so case _: is equal to default:. When all possible cases are handled, the catch-all _ pattern or default case is not required.</description>
    </item>
    
    <item>
      <title>Abstracts</title>
      <link>https://www.wikiod.com/haxe/abstracts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/abstracts/</guid>
      <description>Syntax # abstract identifier(underyling type) { &amp;hellip; } abstract identifier(underlying type) from typeA from typeB &amp;hellip; to typeA to typeB { &amp;hellip; } An abstract type is a compile-time type which resolves to the underlying type at run-time. This means that thee abstract type does not exist in the source code generated by the Haxe compiler. In its stead are placed the underlying type, or types defined for implicit casting.</description>
    </item>
    
    <item>
      <title>Branching</title>
      <link>https://www.wikiod.com/haxe/branching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/haxe/branching/</guid>
      <description>Syntax # if (condition) { &amp;hellip; } if (condition) { &amp;hellip; } else { &amp;hellip; } if (condition) { &amp;hellip; } else if (condition) { &amp;hellip; } else { &amp;hellip; } // Braces are optional for single line statements
if (condition) &amp;hellip; else if (condition) &amp;hellip; else &amp;hellip; switch (expression) { case pattern: &amp;hellip; default: &amp;hellip; } condition ? expression if true : expression if false; All branching expressions make it possible to return evaluated expressions.</description>
    </item>
    
  </channel>
</rss>
