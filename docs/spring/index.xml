<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spring Tutorial on </title>
    <link>https://www.wikiod.com/docs/spring/</link>
    <description>Recent content in spring Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with spring</title>
      <link>https://www.wikiod.com/spring/getting-started-with-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/getting-started-with-spring/</guid>
      <description>Setup (XML Configuration) # Steps to create Hello Spring:
Investigate Spring Boot to see if that would better suit your needs. Have a project set up with the correct dependencies. It is recommended that you are using Maven or Gradle. create a POJO class, e.g. Employee.java create a XML file where you can define your class and variables. e.g beans.xml create your main class e.g. Customer.java Include spring-beans (and its transitive dependencies!</description>
    </item>
    
    <item>
      <title>Bean scopes</title>
      <link>https://www.wikiod.com/spring/bean-scopes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/bean-scopes/</guid>
      <description>Additional scopes in web-aware contexts # There are several scopes that are available only in a web-aware application context:
request - new bean instance is created per HTTP request session - new bean instance is created per HTTP session application - new bean instance is created per ServletContext globalSession - new bean instance is created per global session in Portlet environment (in Servlet environment global session scope is equal to session scope) websocket - new bean instance is created per WebSocket session No additional setup is required to declare and access web-scoped beans in Spring Web MVC environment.</description>
    </item>
    
    <item>
      <title>Creating and using beans</title>
      <link>https://www.wikiod.com/spring/creating-and-using-beans/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/creating-and-using-beans/</guid>
      <description>Autowiring all beans of a specific type # If you&amp;rsquo;ve got multiple implementations of the same interface, Spring can autowire them all into a collection object. I&amp;rsquo;m going to use an example using a Validator pattern1
Foo Class:
public class Foo { private String name; private String emailAddress; private String errorMessage; /** Getters &amp;amp; Setters omitted **/ } Interface:
public interface FooValidator { public Foo validate(Foo foo); } Name Validator Class:</description>
    </item>
    
    <item>
      <title>ApplicationContext Configuration</title>
      <link>https://www.wikiod.com/spring/applicationcontext-configuration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/applicationcontext-configuration/</guid>
      <description>Spring has made it so that configuring an ApplicationContext is extremely flexible. There are numerous ways to apply each type of configuration, and they can all be mixed and matched together nicely.
Java configuration is a form of explicit configuration. A @Configuration annotated class is used to specify the beans that will be a part of the ApplicationContext, as well as define and wire the dependencies of each bean.
Xml configuration is a form of explicit configuration.</description>
    </item>
    
    <item>
      <title>Spring Core</title>
      <link>https://www.wikiod.com/spring/spring-core/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/spring-core/</guid>
      <description>Introduction to Spring Core # Spring is a vast framework, so the Spring framework has been divided in several modules which makes spring lightweight. Some important modules are:
Spring Core Spring AOP Spring JDBC Spring Transaction Spring ORM Spring MVC All the modules of Spring are independent of each other except Spring Core. As Spring core is the base module, so in all module we have to use Spring Core</description>
    </item>
    
    <item>
      <title>Task Execution and Scheduling</title>
      <link>https://www.wikiod.com/spring/task-execution-and-scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/task-execution-and-scheduling/</guid>
      <description>Cron expression # A Cron expression consists of six sequential fields -
second, minute, hour, day of month, month, day(s) of week and is declared as follows
@Scheduled(cron = &amp;quot;* * * * * *&amp;quot;) We can also set the timezone as -
@Scheduled(cron=&amp;quot;* * * * * *&amp;quot;, zone=&amp;quot;Europe/Istanbul&amp;quot;) Notes: -
syntax means example explanation ------------------------------------------------------------------------------------ * match any &amp;quot;* * * * * *&amp;quot; do always */x every x &amp;quot;*/5 * * * * *&amp;quot; do every five seconds ?</description>
    </item>
    
    <item>
      <title>Conditional bean registration in Spring</title>
      <link>https://www.wikiod.com/spring/conditional-bean-registration-in-spring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/conditional-bean-registration-in-spring/</guid>
      <description>Important point to note while using condition
The condition class is referred as direct class (not as spring bean) so it can&amp;rsquo;t use the @Value property injection i.e. no other spring beans can be injected within it. From java docs - Conditions must follow the same restrictions as BeanFactoryPostProcessor and take care to never interact with bean instances. The restrictions refereed here are A BeanFactoryPostProcessor may interact with and modify bean definitions, but never bean instances.</description>
    </item>
    
    <item>
      <title>Dependency Injection (DI) and Inversion of Control (IoC)</title>
      <link>https://www.wikiod.com/spring/dependency-injection-di-and-inversion-of-control-ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/dependency-injection-di-and-inversion-of-control-ioc/</guid>
      <description>The source code for large software applications is typically organized into multiple units. The definition of a unit normally varies by the programming language used. For example, code written in a procedural programming language (like C) is organized into functions or procedures. Similarly, code in an object-oriented programming language (like Java, Scala and C#) is organized into classes, interfaces and so on. These units of code organization can be thought of as individual units making up the overall software application.</description>
    </item>
    
    <item>
      <title>RestTemplate</title>
      <link>https://www.wikiod.com/spring/resttemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/resttemplate/</guid>
      <description>Downloading a Large File # The getForObject and getForEntity methods of RestTemplate load the entire response in memory. This is not suitable for downloading large files since it can cause out of memory exceptions. This example shows how to stream the response of a GET request.
RestTemplate restTemplate // = ...; // Optional Accept header RequestCallback requestCallback = request -&amp;gt; request.getHeaders() .setAccept(Arrays.asList(MediaType.APPLICATION_OCTET_STREAM, MediaType.ALL)); // Streams the response instead of loading it all in memory ResponseExtractor&amp;lt;Void&amp;gt; responseExtractor = response -&amp;gt; { // Here I write the response to a file but do what you like Path path = Paths.</description>
    </item>
    
    <item>
      <title>JdbcTemplate</title>
      <link>https://www.wikiod.com/spring/jdbctemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/spring/jdbctemplate/</guid>
      <description>The JdbcTemplate class executes SQL queries, update statements and stored procedure calls, performs iteration over ResultSets and extraction of returned parameter values. It also catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package.
Instances of the JdbcTemplate class are threadsafe once configured so it can be safely inject this shared reference into multiple DAOs.
Basic Query methods # Some of the queryFor* methods available in JdbcTemplate are useful for simple sql statements that perform CRUD operations.</description>
    </item>
    
  </channel>
</rss>
