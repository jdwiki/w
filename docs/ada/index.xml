<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ada Tutorial on </title>
    <link>https://www.wikiod.com/docs/ada/</link>
    <description>Recent content in ada Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/ada/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with ada</title>
      <link>https://www.wikiod.com/ada/getting-started-with-ada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/getting-started-with-ada/</guid>
      <description>Version # The standard Ada programming language is defined in the Ada Reference Manual. Interim version changes and release notes are discussed in the corresponding rationale documents. Implementations typically document their compliance with the standard in the form of a user guide and/or reference manual, for example.
Ada 2012
Ada 2012 Language Reference Manual Rationale for Ada 2012 Ada 2005
Ada 2005 Language Reference Manual [Rationale for Ada 2005][6] Ada 95</description>
    </item>
    
    <item>
      <title>Attribute Image</title>
      <link>https://www.wikiod.com/ada/attribute-image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/attribute-image/</guid>
      <description>Subtype attributes &#39;Image and &#39;Value will take, respectively, a scalar value and a string and they return, respectively, a string and a scalar value. The result of &#39;Image can be input to &#39;Value to get the original value. The converse is also true.
The __Scalar_Object__&#39;Image attribute can be used directly on objects (since Ada 2012-TC-1).
Syntax # function Scalar&amp;rsquo;Image (Argument : Scalar&amp;rsquo;Base) return String; function Discrete&amp;rsquo;Image (Argument : Discrete&amp;rsquo;Base) return String; function Integer&amp;rsquo;Image (Argument : Integer&amp;rsquo;Base) return String; function Enumeration&amp;rsquo;Image (Argument : Enumeration&amp;rsquo;Base) return String; function Real&amp;rsquo;Image (Argument : Real&amp;rsquo;Base) return String; function Numeric&amp;rsquo;Image (Argument : Numeric&amp;rsquo;Base) return String; function Scalar&amp;rsquo;Value (Argument : String) return Scalar&amp;rsquo;Base; function Discrete&amp;rsquo;Value (Argument : String) return Discrete&amp;rsquo;Base; function Integer&amp;rsquo;Value (Argument : String) return Integer&amp;rsquo;Base; function Enumeration&amp;rsquo;Value (Argument : String) return Enumeration&amp;rsquo;Base; function Real&amp;rsquo;Value (Argument : String) return Real&amp;rsquo;Base; function Scalar_Object&amp;lsquo;Image return String; Note that &#39;Image can incur implementation defined results (RM 3.</description>
    </item>
    
    <item>
      <title>Implementing the producer-consumer pattern</title>
      <link>https://www.wikiod.com/ada/implementing-the-producer-consumer-pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/implementing-the-producer-consumer-pattern/</guid>
      <description>A demonstration of how the producer-consumer pattern is implemented in Ada.
Syntax # function Scalar&amp;rsquo;Image (Argument : Scalar&amp;rsquo;Base) return String;
task Task_Name;
task Task_Name is Entries end;
task body Task_Name is Declarations begin Code end;
entry Entry_Name;
accept Entry_Name;
exit;
The examples should all ensure proper task termination.
Producer-Consumer pattern using the Ada Rendezvous mechanism # A synchronous producer-consumer solution ensures that the consumer reads every data item written by the producer exactly one time.</description>
    </item>
    
    <item>
      <title>Enumeration</title>
      <link>https://www.wikiod.com/ada/enumeration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/enumeration/</guid>
      <description>Syntax # function Enumeration&amp;rsquo;Image (Argument : Enumeration&amp;rsquo;Base) return String;
function Enumeration&amp;rsquo;Img return String; &amp;ndash; GNAT
function Enumeration&amp;rsquo;Val (Argument : Universal_Integer) return Enumeration&amp;rsquo;Base;
function Enumeration&amp;rsquo;Pos (Argument : Enumeration&amp;rsquo;Base) return Universal_Integer;
function Enumeration&amp;rsquo;Enum_Rep (Argument : Enumeration&amp;rsquo;Base) return Universal_Integer;
function Literal&amp;lsquo;Enum_Rep return Universal_Integer; &amp;ndash; GNAT
function Literal&amp;lsquo;Address return System.Address;
for Enumeration use (Literal_1 =&amp;gt; Universal_Integer, Literal_n =&amp;gt; Universal_Integer);
(Literal in Enumeration) return Boolean;
Iterating literals # A literal inside a enumeration is a discrete type so we can use attribute Image to find out which literal it is as text form.</description>
    </item>
    
    <item>
      <title>Files and IO streams</title>
      <link>https://www.wikiod.com/ada/files-and-io-streams/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/files-and-io-streams/</guid>
      <description>The Ada standard library provides for I/O of traditional files of text or binary data, as well as I/O of streamed files. Files of binary data will be sequences of values of a type, while stream files can be sequences of values of possibly different types.
To read and write elements of different types from/to stream files, Ada uses subprograms denoted by types&amp;rsquo; attributes, namely &#39;Read, &#39;Write, &#39;Input, and &#39;Output. The latter two will read and write array bounds, record discriminants, and type tags, in addition to the bare input and output that Read and &#39;Write will perform.</description>
    </item>
    
    <item>
      <title>Task</title>
      <link>https://www.wikiod.com/ada/task/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/task/</guid>
      <description>Syntax # task Task_Name; task Task_Name is Entries end; task body Task_Name is Declarations begin Code end; One simple task # with Ada.Text_IO; use Ada.Text_IO; procedure Main is task My_Task; task body My_Task is begin Put_Line (&amp;quot;Hello from My_Task&amp;quot;); end; begin Put_Line (&amp;quot;Hello from Main&amp;quot;); end; Result # The order of Put_Line can vary.
Hello from My_Task Hello from Main One simple task and one loop # with Ada.Text_IO; use Ada.</description>
    </item>
    
    <item>
      <title>package Ada.Text_IO</title>
      <link>https://www.wikiod.com/ada/package-adatext_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/package-adatext_io/</guid>
      <description>Package Ada.Text_IO is used for putting text or getting text from files or console.
Put_Line # Prints out string with a newline.
with Ada.Text_IO; procedure Put_Text is use Ada.Text_IO; S : String := &amp;quot;Hello&amp;quot;; begin Put_Line (&amp;quot;Hello&amp;quot;); Put_Line (Standard_Output, &amp;quot;Hello&amp;quot;); Put_Line (Standard_Error, &amp;quot;Hello error&amp;quot;); Put_Line (S &amp;amp; &amp;quot; World&amp;quot;); end; Result # Hello Hello Hello error Hello World </description>
    </item>
    
    <item>
      <title>Packages</title>
      <link>https://www.wikiod.com/ada/packages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/packages/</guid>
      <description>Syntax # with Package_Name_To_Include; package New_Package_Name renames Package_To_Rename; use Package_Name; package Parent_Name.Child_Name is Package provides:
Code encapsulation Separate compilation Hide procedures, functions, operators on private types Similarities or analogous in other languages:
C++ namespace Java packages More on Packages # In the Hello World, you were introduced to the package Ada.Text_IO, and how to use it in order to perform I/O operations within your program. Packages can be further manipulated to do many different things.</description>
    </item>
    
    <item>
      <title>Parameterized Types</title>
      <link>https://www.wikiod.com/ada/parameterized-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/parameterized-types/</guid>
      <description>All composite types other than arrays can have discriminants, which are components with special properties. Discriminants can be of a discrete type or an access type. In the latter case the access type can be a named access type or it can be anonymous. A discriminant of an anonymous access type is called an access discriminant by analogy with an access parameter.
Discriminated record types # In the case of a discriminated record type, some of the components are known as discriminants and the remaining components can depend upon these.</description>
    </item>
    
    <item>
      <title>Scalar Types</title>
      <link>https://www.wikiod.com/ada/scalar-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/ada/scalar-types/</guid>
      <description>In Ada&amp;rsquo;s hierarchy of types, elementary types have sets of logically indivisible values. Among these types are the access types (pointer types) and the scalar types. The scalar types can be categorised as enumeration, character, and numeric. These types form the subject of this topic. In addition to the sets of values, types have set of operations applicable to the respective scalars, such as successor, or &amp;quot;+&amp;quot;.
Syntax # type … is … Parameters # Ellipsis What … (1) to receive the type&amp;rsquo;s name … (2) to receive the type&amp;rsquo;s characteristics using keywords: delta, digits, range All scalar type definitions except enumeration and modular integers may include a range constraint.</description>
    </item>
    
  </channel>
</rss>
