<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>numpy Tutorial on </title>
    <link>https://www.wikiod.com/docs/numpy/</link>
    <description>Recent content in numpy Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/docs/numpy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Getting started with numpy</title>
      <link>https://www.wikiod.com/numpy/getting-started-with-numpy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/getting-started-with-numpy/</guid>
      <description>Basic Import # Import the numpy module to use any part of it.
import numpy as np Most examples will use np as shorthand for numpy. Assume &amp;ldquo;np&amp;rdquo; means &amp;ldquo;numpy&amp;rdquo; in code examples.
x = np.array([1,2,3,4]) Installation on Linux # NumPy is available in the default repositories of most popular Linux distributions and can be installed in the same way that packages in a Linux distribution are usually installed.
Some Linux distributions have different NumPy packages for Python 2.</description>
    </item>
    
    <item>
      <title>Arrays</title>
      <link>https://www.wikiod.com/numpy/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/arrays/</guid>
      <description>N-dimensional arrays or ndarrays are numpy&amp;rsquo;s core object used for storing items of the same data type. They provide an efficient data structure that is superior to ordinary Python&amp;rsquo;s arrays.
Whenever possible express operations on data in terms of arrays and vector operations. Vector operations execute much faster than equivalent for loops
Array Access # Slice syntax is i:j:k where i is the starting index (inclusive), j is the stopping index (exclusive) and k is the step size.</description>
    </item>
    
    <item>
      <title>numpy.dot</title>
      <link>https://www.wikiod.com/numpy/numpydot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/numpydot/</guid>
      <description>Syntax # numpy.dot(a, b, out=None) Parameters # Name Details a a numpy array b a numpy array out a numpy array numpy.dot
Returns the dot product of a and b. If a and b are both scalars or both 1-D arrays then a scalar is returned; otherwise an array is returned. If out is given, then it is returned.
Matrix multiplication # Matrix multiplication can be done in two equivalent ways with the dot function.</description>
    </item>
    
    <item>
      <title>Generating random data</title>
      <link>https://www.wikiod.com/numpy/generating-random-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/generating-random-data/</guid>
      <description>The random module of NumPy provides convenient methods for generating random data having the desired shape and distribution.
Here&amp;rsquo;s the official documentation.
Generating random numbers drawn from specific distributions # Draw samples from a normal (gaussian) distribution
# Generate 5 random numbers from a standard normal distribution # (mean = 0, standard deviation = 1) np.random.randn(5) # Out: array([-0.84423086, 0.70564081, -0.39878617, -0.82719653, -0.4157447 ]) # This result can also be achieved with the more general np.</description>
    </item>
    
    <item>
      <title>Linear algebra with np.linalg</title>
      <link>https://www.wikiod.com/numpy/linear-algebra-with-nplinalg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/linear-algebra-with-nplinalg/</guid>
      <description>As of version 1.8, several of the routines in np.linalg can operate on a &amp;lsquo;stack&amp;rsquo; of matrices. That is, the routine can calculate results for multiple matrices if they&amp;rsquo;re stacked together. For example, A here is interpreted as two stacked 3-by-3 matrices:
np.random.seed(123) A = np.random.rand(2,3,3) b = np.random.rand(2,3) x = np.linalg.solve(A, b) print np.dot(A[0,:,:], x[0,:]) # array([ 0.53155137, 0.53182759, 0.63440096]) print b[0,:] # array([ 0.53155137, 0.53182759, 0.63440096]) The official np docs specify this via parameter specifications like a : (.</description>
    </item>
    
    <item>
      <title>Simple Linear Regression</title>
      <link>https://www.wikiod.com/numpy/simple-linear-regression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/simple-linear-regression/</guid>
      <description>Fitting a line (or other function) to a set of data points.
Using np.polyfit # We create a dataset that we then fit with a straight line $f(x) = m x + c$.
npoints = 20 slope = 2 offset = 3 x = np.arange(npoints) y = slope * x + offset + np.random.normal(size=npoints) p = np.polyfit(x,y,1) # Last argument is degree of polynomial To see what we&amp;rsquo;ve done:
import matplotlib.</description>
    </item>
    
    <item>
      <title>numpy.cross</title>
      <link>https://www.wikiod.com/numpy/numpycross/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/numpycross/</guid>
      <description>Syntax # numpy.cross(a, b) # cross product of a and b (or vectors in a and b) numpy.cross(a, b, axisa=-1) #cross product of vectors in a with b, s.t. vectors in a are laid out along axis axisa numpy.cross(a, b, axisa=-1, axisb=-1, axisc=-1) # cross products of vectors in a and b, output vectors laid out along axis specified by axisc numpy.cross(a, b, axis=None) # cross products of vectors in a and b, vectors in a, b, and in output laid out along axis axis Parameters # Column Column a,b In simplest usage, a and b are two 2- or 3-element vectors.</description>
    </item>
    
    <item>
      <title>File IO with numpy</title>
      <link>https://www.wikiod.com/numpy/file-io-with-numpy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/file-io-with-numpy/</guid>
      <description>Loading numerical data from text files with consistent structure # The function np.loadtxt can be used to read csv-like files:
# File: # # Col_1 Col_2 # 1, 1 # 2, 4 # 3, 9 np.loadtxt(&#39;/path/to/dir/csvlike.txt&#39;, delimiter=&#39;,&#39;, comments=&#39;#&#39;) # Output: # array([[ 1., 1.], # [ 2., 4.], # [ 3., 9.]]) The same file could be read using a regular expression with np.fromregex:
np.fromregex(&#39;/path/to/dir/csvlike.txt&#39;, r&#39;(\d+),\s(\d+)&#39;, np.int64) # Output: # array([[1, 1], # [2, 4], # [3, 9]]) Saving and loading numpy arrays using binary files # x = np.</description>
    </item>
    
    <item>
      <title>subclassing ndarray</title>
      <link>https://www.wikiod.com/numpy/subclassing-ndarray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/subclassing-ndarray/</guid>
      <description>Syntax # def __array_prepare__(self, out_arr: ndarray, context: Tuple[ufunc, Tuple, int] = None) -&amp;gt; ndarray: # called on the way into a ufunc
def __array_wrap__(self, out_arr: ndarray, context: Tuple[ufunc, Tuple, int] = None) -&amp;gt; ndarray: # called on the way out of a ufunc
__array_priority__: int # used to determine which argument to invoke the above methods on when a ufunc is called
def __array_finalize__(self, obj: ndarray): # called whenever a new instance of this class comes into existence, even if this happens by routes other than __new__</description>
    </item>
    
    <item>
      <title>Boolean Indexing</title>
      <link>https://www.wikiod.com/numpy/boolean-indexing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/numpy/boolean-indexing/</guid>
      <description>Creating a boolean array # A boolean array can be created manually by using dtype=bool when creating the array. Values other than 0, None, False or empty strings are considered True.
import numpy as np bool_arr = np.array([1, 0.5, 0, None, &#39;a&#39;, &#39;&#39;, True, False], dtype=bool) print(bool_arr) # output: [ True True False False True False True False] Alternatively, numpy automatically creates a boolean array when comparisons are made between arrays and scalars or between arrays of the same shape.</description>
    </item>
    
  </channel>
</rss>
