<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial Django on </title>
    <link>https://www.wikiod.com/es/docs/django/</link>
    <description>Recent content in Tutorial Django on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/django/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con Django</title>
      <link>https://www.wikiod.com/es/django/comenzando-con-django/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/comenzando-con-django/</guid>
      <description>Inicio de un proyecto # Django es un framework de desarrollo web basado en Python. Django 1.11 (la última versión estable) requiere la instalación de Python 2.7, 3.4, 3.5 o 3.6. Suponiendo que pip esté disponible, la instalación es tan simple como ejecutar el siguiente comando. Tenga en cuenta que si omite la versión que se muestra a continuación, se instalará la última versión de django:
$ pip install django Para instalar una versión específica de Django, supongamos que la versión es Django 1.</description>
    </item>
    
    <item>
      <title>Comandos de gestión</title>
      <link>https://www.wikiod.com/es/django/comandos-de-gestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/comandos-de-gestion/</guid>
      <description>Los comandos de administración son scripts potentes y flexibles que pueden realizar acciones en su proyecto Django o en la base de datos subyacente. Además de varios comandos predeterminados, ¡es posible escribir los tuyos propios!
En comparación con las secuencias de comandos regulares de Python, el uso del marco de comandos de administración significa que parte del trabajo de configuración tedioso se realiza automáticamente detrás de escena.
Los comandos de administración se pueden llamar desde:</description>
    </item>
    
    <item>
      <title>Modelos</title>
      <link>https://www.wikiod.com/es/django/modelos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/modelos/</guid>
      <description>En el caso básico, un modelo es una clase de Python que se asigna a una sola tabla de base de datos. Los atributos de la clase se asignan a las columnas de la tabla y una instancia de la clase representa una fila en la tabla de la base de datos. Los modelos heredan de django.db.models.Model, que proporciona una rica API para agregar y filtrar resultados de la base de datos.</description>
    </item>
    
    <item>
      <title>software intermedio</title>
      <link>https://www.wikiod.com/es/django/software-intermedio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/software-intermedio/</guid>
      <description>El middleware en Django es un marco que permite que el código se conecte al procesamiento de respuesta/solicitud y altere la entrada o salida de Django.
El middleware debe agregarse a su lista settings.py MIDDLEWARE_CLASSES antes de que se incluya en la ejecución. La lista predeterminada que proporciona Django al crear un nuevo proyecto es la siguiente:
MIDDLEWARE_CLASSES = [ &#39;django.middleware.security.SecurityMiddleware&#39;, &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;django.middleware.common.CommonMiddleware&#39;, &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, &#39;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#39;, &#39;django.contrib.messages.middleware.MessageMiddleware&#39;, &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;, ] Todas estas son funciones que se ejecutarán en orden en cada solicitud (una vez antes de que llegue a su código de vista en views.</description>
    </item>
    
    <item>
      <title>Ajustes</title>
      <link>https://www.wikiod.com/es/django/ajustes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/ajustes/</guid>
      <description>Ocultar datos secretos usando un archivo JSON # Cuando se usa un VCS como Git o SVN, hay algunos datos secretos que nunca se deben versionar (ya sea que el repositorio sea público o privado).
Entre esos datos, encontrará la configuración SECRET_KEY y la contraseña de la base de datos.
Una práctica común para ocultar estas configuraciones del control de versiones es crear un archivo secrets.json en la raíz de su proyecto (gracias a &amp;ldquo;Two Scoops of Django&amp;rdquo; por la idea):</description>
    </item>
    
    <item>
      <title>Enrutamiento de URL</title>
      <link>https://www.wikiod.com/es/django/enrutamiento-de-url/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/enrutamiento-de-url/</guid>
      <description>Establecer el espacio de nombres de URL para una aplicación reutilizable (Django 1.9+) # Configure la URLconf de su aplicación para usar automáticamente un espacio de nombres de URL configurando el atributo app_name:
# In &amp;lt;myapp&amp;gt;/urls.py from django.conf.urls import url from .views import overview app_name = &#39;myapp&#39; urlpatterns = [ url(r&#39;^$&#39;, overview, name=&#39;overview&#39;), ] Esto establecerá el espacio de nombres de la aplicación en &#39;myapp&#39; cuando se incluye en la raíz URLconf &amp;gt;.</description>
    </item>
    
    <item>
      <title>Backends de autenticación</title>
      <link>https://www.wikiod.com/es/django/backends-de-autenticacion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/backends-de-autenticacion/</guid>
      <description>Servidor de autenticación de correo electrónico # La autenticación predeterminada de Django funciona en los campos nombre de usuario y contraseña. El backend de autenticación de correo electrónico autenticará a los usuarios en función del &amp;ldquo;correo electrónico&amp;rdquo; y la &amp;ldquo;contraseña&amp;rdquo;.
from django.contrib.auth import get_user_model class EmailBackend(object): &amp;quot;&amp;quot;&amp;quot; Custom Email Backend to perform authentication via email &amp;quot;&amp;quot;&amp;quot; def authenticate(self, username=None, password=None): user_model = get_user_model() try: user = user_model.objects.get(email=username) if user.check_password(password): # check valid password return user # return user to be authenticated except user_model.</description>
    </item>
    
    <item>
      <title>ArrayField un campo específico de PostgreSQL</title>
      <link>https://www.wikiod.com/es/django/arrayfield-un-campo-especifico-de-postgresql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/arrayfield-un-campo-especifico-de-postgresql/</guid>
      <description>Sintaxis # desde django.contrib.postgres.fields import ArrayField class ArrayField(base_field, size=Ninguno, **opciones) FooModel.objects.filter(array_field_name__contains=[objetos, a, comprobar]) FooModel.objects.filter(array_field_name__contained_by=[objetos, a, comprobar]) Tenga en cuenta que aunque el parámetro size se pasa a PostgreSQL, PostgreSQL no lo aplicará.
Al usar ArrayFields, se debe tener en cuenta esta palabra de advertencia de la documentación de matrices de Postgresql.
Consejo: las matrices no son conjuntos; la búsqueda de elementos de matriz específicos puede ser un signo de mal diseño de la base de datos.</description>
    </item>
    
    <item>
      <title>Plantillas</title>
      <link>https://www.wikiod.com/es/django/plantillas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/plantillas/</guid>
      <description>Evite que se llame a métodos confidenciales en plantillas # Cuando un objeto se expone al contexto de la plantilla, sus métodos sin argumentos están disponibles. Esto es útil cuando estas funciones son &amp;ldquo;getters&amp;rdquo;. Pero puede ser peligroso si estos métodos alteran algunos datos o tienen algunos efectos secundarios. Aunque es probable que confíe en el autor de la plantilla, es posible que no esté al tanto de los efectos secundarios de una función o que piense que llama al atributo incorrecto por error.</description>
    </item>
    
    <item>
      <title>conjuntos de consultas</title>
      <link>https://www.wikiod.com/es/django/conjuntos-de-consultas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/django/conjuntos-de-consultas/</guid>
      <description>Un Queryset es fundamentalmente una lista de objetos derivados de un Modelo, mediante una compilación de consultas a bases de datos.
Reducir el número de consultas en el campo ForeignKey (problema n+1) # Problema # Los conjuntos de consultas de Django se evalúan de forma perezosa. Por ejemplo:
# models.py: class Author(models.Model): name = models.CharField(max_length=100) class Book(models.Model): author = models.ForeignKey(Author, related_name=&#39;books&#39;) title = models.CharField(max_length=100) # views.py def myview(request): # Query the database books = Book.</description>
    </item>
    
  </channel>
</rss>
