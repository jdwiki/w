<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de algoritmos on </title>
    <link>https://www.wikiod.com/es/docs/algorithm/</link>
    <description>Recent content in Tutorial de algoritmos on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con el algoritmo</title>
      <link>https://www.wikiod.com/es/algorithm/comenzando-con-el-algoritmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/comenzando-con-el-algoritmo/</guid>
      <description>Un ejemplo de problema algorítmico # Un problema algorítmico se especifica describiendo el conjunto completo de instancias en las que debe funcionar y su salida después de ejecutarse en una de estas instancias. Esta distinción, entre un problema y una instancia de un problema, es fundamental. El problema algorítmico conocido como clasificación se define de la siguiente manera: [Skiena:2008:ADM:1410219]
Problema: Clasificación Entrada: Una secuencia de n teclas, a_1, a_2, ..., a_n.</description>
    </item>
    
    <item>
      <title>Complejidad del algoritmo</title>
      <link>https://www.wikiod.com/es/algorithm/complejidad-del-algoritmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/complejidad-del-algoritmo/</guid>
      <description>Todos los algoritmos son una lista de pasos para resolver un problema. Cada paso tiene dependencias en algún conjunto de pasos previos, o el inicio del algoritmo. Un pequeño problema podría parecerse al siguiente:
Esta estructura se llama gráfico acíclico dirigido, o DAG para abreviar. Los vínculos entre cada nodo del gráfico representan dependencias en el orden de las operaciones y no hay ciclos en el gráfico.
¿Cómo suceden las dependencias?</description>
    </item>
    
    <item>
      <title>Notación O grande</title>
      <link>https://www.wikiod.com/es/algorithm/notacion-o-grande/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/notacion-o-grande/</guid>
      <description>Definición
La notación Big-O es, en esencia, una notación matemática, utilizada para comparar la tasa de convergencia de funciones. Sean n -&amp;gt; f(n) y n -&amp;gt; g(n) funciones definidas sobre los números naturales. Entonces decimos que f = O(g) si y solo si f(n)/g(n) está acotado cuando n tiende a infinito. En otras palabras, f = O(g) si y sólo si existe una constante A, tal que para todo n, f(n)/g(n) &amp;lt;= A.</description>
    </item>
    
    <item>
      <title>Grafico</title>
      <link>https://www.wikiod.com/es/algorithm/grafico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/grafico/</guid>
      <description>Un gráfico es una colección de puntos y líneas que conectan algún subconjunto (posiblemente vacío) de ellos. Los puntos de un gráfico se denominan vértices del gráfico, &amp;ldquo;nodos&amp;rdquo; o simplemente &amp;ldquo;puntos&amp;rdquo;. De manera similar, las líneas que conectan los vértices de un gráfico se denominan bordes de gráfico, &amp;ldquo;arcos&amp;rdquo; o &amp;ldquo;líneas&amp;rdquo;.
Un grafo G se puede definir como un par (V,E), donde V es un conjunto de vértices y E es un conjunto de aristas entre los vértices E ⊆ {(u,v) | u, v ∈ V}.</description>
    </item>
    
    <item>
      <title>Árboles de búsqueda binarios</title>
      <link>https://www.wikiod.com/es/algorithm/arboles-de-busqueda-binarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/arboles-de-busqueda-binarios/</guid>
      <description>El árbol binario es un árbol en el que cada nodo tiene un máximo de dos hijos. El árbol de búsqueda binaria (BST) es un árbol binario cuyos elementos se colocan en un orden especial. En cada BST, todos los valores (es decir, clave) en el subárbol izquierdo son menores que los valores en el subárbol derecho.
Árbol de búsqueda binario - Inserción (Python) # Esta es una implementación simple de la inserción del árbol de búsqueda binaria usando Python.</description>
    </item>
    
    <item>
      <title>Algoritmo de Dijkstra</title>
      <link>https://www.wikiod.com/es/algorithm/algoritmo-de-dijkstra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/algoritmo-de-dijkstra/</guid>
      <description>Algoritmo de ruta más corta de Dijkstra # Antes de continuar, se recomienda tener una breve idea sobre Adjacency Matrix y BFS
Algoritmo de Dijkstra se conoce como algoritmo de ruta más corta de fuente única. Se utiliza para encontrar los caminos más cortos entre los nodos de un gráfico, que puede representar, por ejemplo, redes de carreteras. Fue concebido por Edsger W. Dijkstra en 1956 y publicado tres años después.</description>
    </item>
    
    <item>
      <title>Ordenar por fusión</title>
      <link>https://www.wikiod.com/es/algorithm/ordenar-por-fusion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/ordenar-por-fusion/</guid>
      <description>Conceptos básicos de ordenación por fusión # Merge Sort es un algoritmo de divide y vencerás. Divide la lista de entrada de longitud n por la mitad sucesivamente hasta que haya n listas de tamaño 1. Luego, los pares de listas se fusionan con el primer elemento más pequeño entre el par de listas que se agregan en cada paso. A través de la fusión sucesiva y la comparación de los primeros elementos, se construye la lista ordenada.</description>
    </item>
    
    <item>
      <title>Deformación dinámica del tiempo</title>
      <link>https://www.wikiod.com/es/algorithm/deformacion-dinamica-del-tiempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/deformacion-dinamica-del-tiempo/</guid>
      <description>Introducción a la deformación temporal dinámica # Dynamic Time Warping(DTW) es un algoritmo para medir la similitud entre dos secuencias temporales que pueden variar en velocidad. Por ejemplo, las similitudes al caminar podrían detectarse usando DTW, incluso si una persona caminaba más rápido que la otra, o si hubo aceleraciones y desaceleraciones durante el curso de una observación. Se puede usar para hacer coincidir un comando de voz de muestra con otro comando, incluso si la persona habla más rápido o más lento que la voz de muestra pregrabada.</description>
    </item>
    
    <item>
      <title>Algoritmo Bellman-Ford</title>
      <link>https://www.wikiod.com/es/algorithm/algoritmo-bellman-ford/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/algoritmo-bellman-ford/</guid>
      <description>Dado un gráfico dirigido G, a menudo queremos encontrar la distancia más corta desde un nodo dado A hasta el resto de los nodos en el gráfico. El algoritmo Dijkstra es el algoritmo más famoso para encontrar la ruta más corta, sin embargo, solo funciona si los pesos de los bordes del gráfico dado no son negativos. Sin embargo, Bellman-Ford tiene como objetivo encontrar la ruta más corta desde un nodo determinado (si existe) incluso si algunos de los pesos son negativos.</description>
    </item>
    
    <item>
      <title>Búsqueda de subcadenas</title>
      <link>https://www.wikiod.com/es/algorithm/busqueda-de-subcadenas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/algorithm/busqueda-de-subcadenas/</guid>
      <description>Introducción al algoritmo Knuth-Morris-Pratt (KMP) # Supongamos que tenemos un texto y un patrón. Necesitamos determinar si el patrón existe en el texto o no. Por ejemplo:
+-------+---+---+---+---+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | +-------+---+---+---+---+---+---+---+---+ | Text | a | b | c | b | c | g | l | x | +-------+---+---+---+---+---+---+---+---+ +---------+---+---+---+---+ | Index | 0 | 1 | 2 | 3 | +---------+---+---+---+---+ | Pattern | b | c | g | l | +---------+---+---+---+---+ Este patrón existe en el texto.</description>
    </item>
    
  </channel>
</rss>
