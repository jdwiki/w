<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de opencv on </title>
    <link>https://www.wikiod.com/es/docs/opencv/</link>
    <description>Recent content in Tutorial de opencv on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/opencv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con opencv</title>
      <link>https://www.wikiod.com/es/opencv/comenzando-con-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/comenzando-con-opencv/</guid>
      <description>Carga y muestra una imagen con OpenCV # Con este ejemplo, veremos cómo cargar una imagen en color desde el disco y mostrarla usando las funciones integradas de OpenCV. Podemos usar los enlaces C/C++, Python o Java para lograr esto.
En C++:
#include &amp;lt;opencv2/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui.hpp&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace cv; int main(int argc, char** argv) { // We&#39;ll start by loading an image from the drive Mat image = imread(&amp;quot;image.</description>
    </item>
    
    <item>
      <title>Contraste y Brillo en C&#43;&#43;</title>
      <link>https://www.wikiod.com/es/opencv/contraste-y-brillo-en-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/contraste-y-brillo-en-c-/</guid>
      <description>Sintaxis # void cv::Mat::convertTo(OutputArray m, int rtype,doble alfa = 1,doble beta = 0)const Parámetros # Parámetro Detalles metro matriz de salida; si no tiene un tamaño o tipo adecuado antes de la operación, se reasigna tipor tipo de matriz de salida deseada o, mejor dicho, la profundidad ya que el número de canales es el mismo que tiene la entrada; si rtype es negativo, la matriz de salida tendrá el mismo tipo que la entrada alfa factor de escala opcional.</description>
    </item>
    
    <item>
      <title>Acceso a píxeles</title>
      <link>https://www.wikiod.com/es/opencv/acceso-a-pixeles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/acceso-a-pixeles/</guid>
      <description>Tenga cuidado de ser consciente del tipo de cv::Mat con el que está tratando. Por ejemplo, si tiene un cv::Mat de tipo CV_8UC3, pero accede a él con image.at&amp;lt;uchar&amp;gt;(r,c) no ocurrirá ningún error, pero su programa tendrá un comportamiento inesperado.
Acceso eficiente a los píxeles usando el puntero cv::Mat::ptr # Si la eficiencia es importante, una forma rápida de iterar sobre píxeles en un objeto cv::Mat es usar su método ptr&amp;lt;T&amp;gt;(int r) para obtener un puntero al comienzo de la fila r (0 índice basado en).</description>
    </item>
    
    <item>
      <title>Detección de bordes</title>
      <link>https://www.wikiod.com/es/opencv/deteccion-de-bordes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/deteccion-de-bordes/</guid>
      <description>Sintaxis # bordes = cv2.Astuto(imagen, umbral1, umbral2[, bordes[, tamaño de apertura[, Gradiente L2]]]) void Canny(imagen de InputArray, bordes de OutputArray, umbral doble 1, umbral doble 2, int tamaño de apertura = 3, gradiente bool L2 = falso Parámetros # Parámetro Detalles imagen Imagen de entrada bordes Imagen de salida umbral1 Primer umbral para procedimiento de histéresis umbral2 Segundo umbral para procedimiento de histéresis apertureSize Tamaño de apertura para el operador Sobel L2gradient Indicador que indica si se debe utilizar un algoritmo más preciso para el degradado de la imagen Algoritmo astuto # El algoritmo de Canny es un detector de bordes más reciente diseñado como un problema de procesamiento de señales.</description>
    </item>
    
    <item>
      <title>Procesamiento de imágenes</title>
      <link>https://www.wikiod.com/es/opencv/procesamiento-de-imagenes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/procesamiento-de-imagenes/</guid>
      <description>Sintaxis # Sintaxis de desenfoque gaussiano C++: void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT ) Parámetros # Parámetros de Desenfoque gaussiano Detalles origen Imagen de entrada, la imagen puede tener cualquier cantidad de canales, que se procesan de forma independiente, pero la profundidad debe ser CV_8U, CV_16U, CV_16S, CV_32F o CV_64F. horario de verano Imagen de salida del mismo tamaño y tipo que src ktamaño Tamaño del núcleo gaussiano.</description>
    </item>
    
    <item>
      <title>Dibujar formas (línea, círculo, ..., etc.) en C&#43;&#43;</title>
      <link>https://www.wikiod.com/es/opencv/dibujar-formas-linea-circulo--etc-en-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/dibujar-formas-linea-circulo--etc-en-c-/</guid>
      <description>En OpenCV, se pueden dibujar numerosas formas, como punto, línea, círculo, &amp;hellip;, etc. Hay una opción para rellenar una forma. El siguiente código se explica por sí mismo y muestra cómo se dibujan las formas.
Muestra de formas de dibujo # #include &amp;lt;opencv2/core/core.hpp&amp;gt; #include &amp;lt;opencv2/highgui/highgui.hpp&amp;gt; #include &amp;lt;opencv2/imgproc.hpp&amp;gt; // drawing shapes #include &amp;lt;iostream&amp;gt; int main( int argc, char** argv ) { // First create a black image. cv::Mat image(500,500, CV_8UC3, cv::Scalar(0,0,0)); // Check if the image is created successfully.</description>
    </item>
    
    <item>
      <title>Crear un vídeo</title>
      <link>https://www.wikiod.com/es/opencv/crear-un-video/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/crear-un-video/</guid>
      <description>Cada vez que trabaje con transmisiones de video, es posible que desee guardar el resultado del procesamiento de imágenes en forma de un nuevo archivo de video. Para salidas de video simples, puede usar la clase VideoWriter incorporada de OpenCV, diseñada para esto. Es útil mirar algunos conceptos antes de usarlos. Estos conceptos son códec, es decir, decodificador y FourCC (código de cuatro caracteres).
Creando un video con OpenCV (Java) # VideoWriter videoWriter; videoWriter = new VideoWriter(outputFile, VideoWriter.</description>
    </item>
    
    <item>
      <title>Clasificadores en cascada</title>
      <link>https://www.wikiod.com/es/opencv/clasificadores-en-cascada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/clasificadores-en-cascada/</guid>
      <description>Uso de clasificadores en cascada para detectar rostros # pitón # Código # import numpy as np import cv2 #loading haarcascade classifiers for face and eye #You can find these cascade classifiers here #https://github.com/opencv/opencv/tree/master/data/haarcascades #or where you download opencv inside data/haarcascades face_cascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_default.xml&#39;) eye_cascade = cv2.CascadeClassifier(&#39;haarcascade_eye.xml&#39;) #loading the image img = cv2.imread(&#39;civil_war.jpg&#39;) #converting the image to gray scale gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #detecting face in the grayscale image faces = face_cascade.</description>
    </item>
    
    <item>
      <title>Mostrar imagen OpenCV</title>
      <link>https://www.wikiod.com/es/opencv/mostrar-imagen-opencv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/mostrar-imagen-opencv/</guid>
      <description>Lectura básica y visualización de una imagen # import cv2 image_path= #put your image path here #use imread() function to read image data to variable img. img = cv2.imread(image_path) #display image data in a new window with title &#39;I am an image display window&#39; cv2.imshow(&#39;I am an image display window&#39;,img) #wait until user hits any key on keyboard cv2.waitKey(0) #close any windows opened by opencv cv2.destroyAllWindows() Para controlar el tamaño de la ventana de visualización en la pantalla, agregue los siguientes comandos antes del comando cv2.</description>
    </item>
    
    <item>
      <title>Uso de clasificadores en cascada en Java</title>
      <link>https://www.wikiod.com/es/opencv/uso-de-clasificadores-en-cascada-en-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opencv/uso-de-clasificadores-en-cascada-en-java/</guid>
      <description>Sintaxis # CascadeClassifier cascada = new CascadeClassifier(&amp;ldquo;cascade.xml&amp;rdquo;); // Crea un clasificador en cascada a partir de cascade.xml Mat imagen = Imgcodecs.imread(&amp;ldquo;imagen.png&amp;rdquo;); // Convierte image.png en un objeto Mat (Matrix) Detecciones de MatOfRect = new MatOfRect(); // Crea un archivo MatOfRect (matriz de rectángulos) vacío, utilizado como salida para nuestras clases de detección detecciones.toArray(); // Devuelve una matriz de objetos Rect que se pueden iterar Imgproc.rectangle(imagen, nuevo Punto(rect.x, rect.y), nuevo Punto(rect.x + rect.</description>
    </item>
    
  </channel>
</rss>
