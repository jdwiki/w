<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de subprocesos múltiples on </title>
    <link>https://www.wikiod.com/es/docs/multithreading/</link>
    <description>Recent content in Tutorial de subprocesos múltiples on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/multithreading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con subprocesos múltiples</title>
      <link>https://www.wikiod.com/es/multithreading/primeros-pasos-con-subprocesos-multiples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/multithreading/primeros-pasos-con-subprocesos-multiples/</guid>
      <description>Interbloqueos # Un interbloqueo ocurre cuando cada miembro de un grupo de dos o más subprocesos debe esperar a que uno de los otros miembros haga algo (por ejemplo, para liberar un bloqueo) antes de que pueda continuar. Sin intervención, los hilos esperarán para siempre.
Un ejemplo de pseudocódigo de un diseño propenso a interbloqueos es:
thread_1 { acquire(A) ... acquire(B) ... release(A, B) } thread_2 { acquire(B) ... acquire(A) .</description>
    </item>
    
    <item>
      <title>Ejecutores</title>
      <link>https://www.wikiod.com/es/multithreading/ejecutores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/multithreading/ejecutores/</guid>
      <description>Sintaxis # Ejecutor de grupo de subprocesos
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidad TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidad TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, controlador RejectedExecutionHandler)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidad TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, Fábrica de hilos Fábrica de hilos)
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, unidad TimeUnit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, manejador RejectedExecutionHandler)
Executors.callable(PrivilegedAction&amp;lt;?&amp;gt; acción)
Executors.callable(PrivilegedExceptionAction&amp;lt;?&amp;gt; acción)
Executors.callable (tarea ejecutable)
Executors.callable(Tarea ejecutable, resultado T)</description>
    </item>
    
    <item>
      <title>Semáforos y mutexes</title>
      <link>https://www.wikiod.com/es/multithreading/semaforos-y-mutexes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/multithreading/semaforos-y-mutexes/</guid>
      <description>Los semáforos y los mutexes son controles de concurrencia que se utilizan para sincronizar el acceso de varios subprocesos a los recursos compartidos.
Semáforo # Aquí hay una explicación brillante de [esta pregunta de Stackoverflow] (https://stackoverflow.com/questions/34519/what-is-a-semaphore):
Piense en los semáforos como gorilas en un club nocturno. Hay un dedicado número de personas permitidas en el club a la vez. si el club es full no se permite la entrada a nadie, pero tan pronto como una persona sale podría entrar otra persona.</description>
    </item>
    
  </channel>
</rss>
