<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de libgdx on </title>
    <link>https://www.wikiod.com/es/docs/libgdx/</link>
    <description>Recent content in Tutorial de libgdx on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/libgdx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con libgdx</title>
      <link>https://www.wikiod.com/es/libgdx/primeros-pasos-con-libgdx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/primeros-pasos-con-libgdx/</guid>
      <description>Instalación o configuración # LibGDX tiene una configuración bastante simple, con la ayuda de un programa Java simple. Puede encontrar la descarga aquí. Cuando inicie la aplicación, se verá así: Nota: esta captura de pantalla se tomó en Linux y muestra una ruta que difiere de una instalación de Windows. Sin embargo, el formulario es el mismo en cualquier sistema operativo compatible con esta aplicación de configuración
Cuadros de entrada # En el cuadro de entrada &amp;ldquo;Nombre&amp;rdquo;, está el nombre del juego para tu proyecto.</description>
    </item>
    
    <item>
      <title>Sistema de entidades de Ashley</title>
      <link>https://www.wikiod.com/es/libgdx/sistema-de-entidades-de-ashley/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/sistema-de-entidades-de-ashley/</guid>
      <description>Ashley Entity System es una biblioteca de Entity System que se administra bajo la organización LibGDX y es adecuada para el desarrollo de juegos. Depende de las clases de utilidades de LibGDX, pero se puede usar con otros marcos de juegos de Java que no se basen en LibGDX con algo de trabajo.
Los sistemas de entidades proporcionan una forma diferente de administrar los datos y la funcionalidad para grandes conjuntos de objetos sin tener que enriquecer las clases de objetos con la herencia.</description>
    </item>
    
    <item>
      <title>Compatibilidad con múltiples resoluciones</title>
      <link>https://www.wikiod.com/es/libgdx/compatibilidad-con-multiples-resoluciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/compatibilidad-con-multiples-resoluciones/</guid>
      <description>Ventanas # Para admitir múltiples resoluciones y relaciones de aspecto, Libgdx utiliza los llamados Viewports. Hay algunos tipos de &amp;lsquo;ventanas gráficas&amp;rsquo; que usan diferentes estrategias para manejar múltiples resoluciones y relaciones de aspecto. Un Viewport usa una Cámara debajo del capó y administra su viewportHeight y viewportWidth. Opcionalmente, puede asignar a Viewport una Cámara en su constructor; de lo contrario, utilizará una OrthographicCamera de forma predeterminada:
private Viewport viewport; private Camera camera; public void create() { camera = new PerspectiveCamera(); viewport = new FitViewport(8f, 4.</description>
    </item>
    
    <item>
      <title>Moviendo a los actores en el camino con velocidad constante</title>
      <link>https://www.wikiod.com/es/libgdx/moviendo-a-los-actores-en-el-camino-con-velocidad-constante/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/moviendo-a-los-actores-en-el-camino-con-velocidad-constante/</guid>
      <description>Movimiento simple entre dos ubicaciones # Para esto, la mejor solución es usar acciones. Para agregar una nueva acción a un actor en Scene2D simplemente llame:
Action action = Actions.moveTo(x,y,duration); actorObject.addAction(action); Donde xey es la ubicación del objetivo y la duración es la velocidad de este movimiento en segundos (&amp;ldquo;flotador&amp;rdquo;).
Si desea detener esta acción (y el actor por ella) puede hacerlo llamando a:
actorObject.removeAction(action); o puede eliminar todas las acciones llamando a:</description>
    </item>
    
    <item>
      <title>Caja2D</title>
      <link>https://www.wikiod.com/es/libgdx/caja2d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/caja2d/</guid>
      <description>Crear cuerpos Box2D a partir de un mapa en mosaico # Los objetos creados dentro de un mapa en mosaico (.tmx), se pueden cargar simplemente como cuerpos en un mundo Box2D usando la clase Libgdx MapObject de la siguiente manera:
public void buildBuildingsBodies(TiledMap tiledMap, World world, String layer){ MapObjects objects = tiledMap.getLayers().get(layer).getObjects(); for (MapObject object: objects) { Rectangle rectangle = ((RectangleMapObject)object).getRectangle(); //create a dynamic within the world body (also can be KinematicBody or StaticBody BodyDef bodyDef = new BodyDef(); bodyDef.</description>
    </item>
    
    <item>
      <title>Ciclo vital</title>
      <link>https://www.wikiod.com/es/libgdx/ciclo-vital/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/libgdx/ciclo-vital/</guid>
      <description>Crear # Este método se llama una vez cuando se inicia la aplicación. En este método, los recursos deben cargarse y las variables deben inicializarse.
Prestar # El método se llama cada fotograma y se utiliza para mostrar lo que sea necesario mostrar. También se utiliza para actualizar cualquier variable/clase que deba actualizarse, como una cámara.
Desechar # Este método se llama cuando se destruye la aplicación y se usa para liberar recursos, por ejemplo, Textures o SpriteBatch.</description>
    </item>
    
  </channel>
</rss>
