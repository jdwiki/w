<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de lenguaje Elm on </title>
    <link>https://www.wikiod.com/es/docs/elm/</link>
    <description>Recent content in Tutorial de lenguaje Elm on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/elm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Elm Language</title>
      <link>https://www.wikiod.com/es/elm/primeros-pasos-con-elm-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/primeros-pasos-con-elm-language/</guid>
      <description>Instalación # Para comenzar el desarrollo con Elm, debe instalar un conjunto de herramientas llamado elm-platform.
Incluye: elm-make, elm-reactor, elm-repl y elm-package.
Todas estas herramientas están disponibles a través de CLI, en otras palabras, puede usarlas desde su terminal.
Elija uno de los siguientes métodos para instalar Elm:
Usando el instalador # Descargue el instalador del sitio web oficial y siga el asistente de instalación.
Usando npm # Puede usar Node Package Manager para instalar la plataforma Elm.</description>
    </item>
    
    <item>
      <title>Puertos (interoperabilidad JS)</title>
      <link>https://www.wikiod.com/es/elm/puertos-interoperabilidad-js/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/puertos-interoperabilidad-js/</guid>
      <description>Sintaxis # Elm (recepción): nombre de la función del puerto: (valor -&amp;gt; mensaje) -&amp;gt; Submensaje JS (envío): app.ports.functionName.send(valor) Elm (enviando): port functionName : args -&amp;gt; Cmd msg JS (recepción): app.ports.functionName.subscribe(function(args) { &amp;hellip; }); Consulte http://guide.elm-lang.org/interop/javascript.html de The Elm Guide para ayudar a comprender estos ejemplos.
Extrovertido # Los puertos salientes se utilizan como Comandos, que devuelve desde su función de actualización.
Lado de olmo # Definir puerto de salida:
port output : () -&amp;gt; Cmd msg En este ejemplo, enviamos una Tupla vacía, solo para activar una suscripción en el lado de JavaScript.</description>
    </item>
    
    <item>
      <title>La arquitectura del olmo</title>
      <link>https://www.wikiod.com/es/elm/la-arquitectura-del-olmo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/la-arquitectura-del-olmo/</guid>
      <description>La forma recomendada de estructurar sus aplicaciones se denomina &amp;rsquo;la arquitectura Elm&#39;.
El programa más simple consta de un registro modelo que almacena todos los datos que pueden actualizarse, un tipo de unión Msg que define las formas en que su programa actualiza esos datos, una función update que toma el modelo y un Msg y devuelve un nuevo modelo, y una función ver que toma un modelo y devuelve el HTML que mostrará su página.</description>
    </item>
    
    <item>
      <title>Listas e iteraciones</title>
      <link>https://www.wikiod.com/es/elm/listas-e-iteraciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/listas-e-iteraciones/</guid>
      <description>La Lista (lista enlazada) brilla en acceso secuencial:
acceder al primer elemento anteponiendo al principio de la lista eliminar del principio de la lista Por otro lado, no es ideal para acceso aleatorio (es decir, obtener el elemento n-ésimo) y recorrido en orden inverso, y es posible que tenga mejor suerte (y rendimiento) con la estructura de datos Array.
Creando una lista por rango # Antes de 0.18.0, puede crear rangos como este:</description>
    </item>
    
    <item>
      <title>depuración</title>
      <link>https://www.wikiod.com/es/elm/depuracion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/depuracion/</guid>
      <description>Sintaxis # Debug.log &amp;ldquo;etiqueta&amp;rdquo; anyValue Debug.log toma dos parámetros, una String para etiquetar la salida de depuración en la consola (para que sepa de dónde proviene/a qué corresponde el mensaje) y un valor de cualquier tipo. Debug.log ejecuta el efecto secundario de registrar la etiqueta y el valor en la consola de JavaScript, y luego devuelve el valor. La implementación en JS podría ser algo como:
function log (tag, value){ console.</description>
    </item>
    
    <item>
      <title>Tipos, variables de tipo y constructores de tipo</title>
      <link>https://www.wikiod.com/es/elm/tipos-variables-de-tipo-y-constructores-de-tipo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/tipos-variables-de-tipo-y-constructores-de-tipo/</guid>
      <description>¡Juega con estos conceptos tú mismo para dominarlos realmente! El elm-repl (ver la Introducción al REPL) es probablemente un buen lugar para jugar con el código anterior. También puedes jugar con elm-repl en línea.
Mejorar la seguridad de tipos usando nuevos tipos # Los tipos de alias reducen la repetición y mejoran la legibilidad, pero no son más seguros para los tipos que el propio tipo con alias. Considera lo siguiente:</description>
    </item>
    
    <item>
      <title>Funciones y Aplicación Parcial</title>
      <link>https://www.wikiod.com/es/elm/funciones-y-aplicacion-parcial/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/funciones-y-aplicacion-parcial/</guid>
      <description>Sintaxis # &amp;ndash; definir una función sin argumentos tiene el mismo aspecto que simplemente definir un valor idioma = &amp;ldquo;olmo&amp;rdquo; &amp;ndash; llamar a una función sin argumentos indicando su nombre idioma &amp;ndash; los parámetros están separados por espacios y siguen el nombre de la función suma x y = x + y &amp;ndash; llamar a una función de la misma manera sumar 5 2 &amp;ndash; aplicar parcialmente una función proporcionando solo algunos de sus parámetros incremento = sumar 1 &amp;ndash; utilice el operador |&amp;gt; para pasar la expresión de la izquierda a la función de la derecha diez = 9 |&amp;gt; incremento &amp;ndash; el &amp;lt;| operador pasa la expresión de la derecha a la función de la izquierda incremento &amp;lt;| sumar 5 4 &amp;ndash; encadenar/componer dos funciones junto con el operador &amp;raquo; hacia atrásYell = String.</description>
    </item>
    
    <item>
      <title>Json.Decodificar</title>
      <link>https://www.wikiod.com/es/elm/jsondecodificar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/jsondecodificar/</guid>
      <description>Json.Decode expone dos funciones para decodificar una carga útil, la primera es decodeValue que intenta decodificar un Json.Encode.Value, la segunda es decodeString que intenta decodificar una cadena JSON. Ambas funciones toman 2 parámetros, un decodificador y una cadena Json.Encode.Value o Json.
Pre-decodifica un campo y decodifica el resto dependiendo de ese valor decodificado # Los siguientes ejemplos se pueden probar en https://ellie-app.com/m9vmQ8NcMc/0.
import Html exposing (..) import Json.Decode payload = &amp;quot;&amp;quot;&amp;quot; [ { &amp;quot;bark&amp;quot;: true, &amp;quot;tag&amp;quot;: &amp;quot;dog&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Zap&amp;quot;, &amp;quot;playful&amp;quot;: true } , { &amp;quot;whiskers&amp;quot;: true, &amp;quot;tag&amp;quot; : &amp;quot;cat&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Felix&amp;quot; } , {&amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;, &amp;quot;tag&amp;quot;: &amp;quot;tomato&amp;quot;} ] &amp;quot;&amp;quot;&amp;quot; -- OUR MODELS type alias Dog = { bark: Bool , name: String , playful: Bool } type alias Cat = { whiskers: Bool , name: String } -- OUR DIFFERENT ANIMALS type Animal = DogAnimal Dog | CatAnimal Cat | NoAnimal main = Json.</description>
    </item>
    
    <item>
      <title>Recolección de Tuplas de Datos, Registros y Diccionarios</title>
      <link>https://www.wikiod.com/es/elm/recoleccion-de-tuplas-de-datos-registros-y-diccionarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/recoleccion-de-tuplas-de-datos-registros-y-diccionarios/</guid>
      <description>Diccionarios # Los diccionarios se implementan en una biblioteca central Dict.
Un diccionario que asigna claves únicas a valores. Las claves pueden ser cualquiera tipo comparable. Esto incluye Int, Float, Time, Char, String y tuplas o listas de tipos comparables.
Las operaciones de inserción, eliminación y consulta toman tiempo O(log n).
A diferencia de las Tuplas y los Registros, los Diccionarios pueden cambiar su estructura, es decir, es posible agregar y quitar claves.</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/elm/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/elm/la-coincidencia-de-patrones/</guid>
      <description>Argumento deconstruido de tipo único # type ProjectIdType = ProjectId String getProject : ProjectIdType -&amp;gt; Cmd Msg getProject (ProjectId id) = Http.get &amp;lt;| &amp;quot;/projects/&amp;quot; ++ id Argumentos de función # type Dog = Dog String dogName1 dog = case dog of Dog name -&amp;gt; name dogName2 (Dog name) -&amp;gt; name dogName1 y dogName2 son equivalentes. Tenga en cuenta que esto solo funciona para ADT que tienen un solo constructor.
type alias Pet = { name: String , weight: Float } render : Pet -&amp;gt; String render ({name, weight} as pet) = (findPetEmoji pet) ++ &amp;quot; &amp;quot; ++ name ++ &amp;quot; weighs &amp;quot; ++ (toString weight) findPetEmoji : Pet -&amp;gt; String findPetEmoji pet = Debug.</description>
    </item>
    
  </channel>
</rss>
