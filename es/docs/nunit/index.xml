<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nunidad Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/nunit/</link>
    <description>Recent content in nunidad Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/nunit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con nunit</title>
      <link>https://www.wikiod.com/es/nunit/primeros-pasos-con-nunit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/nunit/primeros-pasos-con-nunit/</guid>
      <description>Por qué no puedes usar Assert.Equals # Alguna vez se preguntó por qué no puede usar Assert.Equals() tanto para Nunit como para MSTest. Si no lo ha hecho, tal vez para empezar deba tener en cuenta que no puede usar este método. En su lugar, usaría Assert.AreEqual() para comparar la igualdad de dos objetos.
La razón aquí es muy simple. Como cualquier clase, la clase Assert hereda de System.Object que tiene un método Equals virtual público destinado a verificar si un objeto dado es igual al objeto actual.</description>
    </item>
    
    <item>
      <title>Escriba una restricción personalizada para el modelo de restricción</title>
      <link>https://www.wikiod.com/es/nunit/escriba-una-restriccion-personalizada-para-el-modelo-de-restriccion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/nunit/escriba-una-restriccion-personalizada-para-el-modelo-de-restriccion/</guid>
      <description>Coincide con un número entero aproximadamente # Supongamos que queremos escribir una restricción que coincida con un número, pero aproximadamente. Digamos que se supone que debes tener &amp;lsquo;95&amp;rsquo; personas en una encuesta, pero &amp;lsquo;93&amp;rsquo; o &amp;lsquo;96&amp;rsquo; también servirán. Podemos escribir una restricción personalizada de la forma:
public class AlmostEqualToConstraint : Constraint { readonly int _expected; readonly double _expectedMin; readonly double _expectedMax; readonly int _percentageTolerance; public AlmostEqualToConstraint(int expected, int percentageTolerance) { _expected = expected; _expectedMin = expected * (1 - (double)percentageTolerance / 100); _expectedMax = expected * (1 + (double)percentageTolerance / 100); _percentageTolerance = percentageTolerance; Description = $&amp;quot;AlmostEqualTo {expected} with a tolerance of {percentageTolerance}%&amp;quot;; } public override ConstraintResult ApplyTo&amp;lt;TActual&amp;gt;(TActual actual) { if (typeof(TActual) !</description>
    </item>
    
    <item>
      <title>Afirmaciones fluidas</title>
      <link>https://www.wikiod.com/es/nunit/afirmaciones-fluidas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/nunit/afirmaciones-fluidas/</guid>
      <description>El formulario Assert.That() de NUnit admite el uso de restricciones como su segundo parámetro. Todas las restricciones provistas de fábrica por NUnit están disponibles a través de las clases estáticas Is, Has y Does. Las restricciones se pueden combinar en expresiones fluidas utilizando los métodos incorporados Y, O y Con. Las expresiones se pueden expandir convenientemente usando los muchos métodos en ConstraintExpression, como AtMost y Contains.
Uso de restricciones avanzadas # Las aserciones grandes y fluidas se vuelven más difíciles de leer, pero cuando se combinan con clases que tienen buenas implementaciones de ToString(), pueden generar mensajes de error muy útiles.</description>
    </item>
    
    <item>
      <title>Ejecución de pruebas y ciclo de vida</title>
      <link>https://www.wikiod.com/es/nunit/ejecucion-de-pruebas-y-ciclo-de-vida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/nunit/ejecucion-de-pruebas-y-ciclo-de-vida/</guid>
      <description>Ejecutar pruebas en un orden dado # Normalmente, sus pruebas deben crearse de tal manera que el orden de ejecución no sea una preocupación. Sin embargo, siempre habrá un caso límite en el que necesite romper esa regla.
El único escenario con el que me encontré fue con R.NET en el que, en un proceso determinado, solo puede inicializar un R Engine y, una vez desechado, no puede reiniciarlo. Una de mis pruebas tuvo que ver con la eliminación del motor y si esta prueba se ejecutara antes que cualquier otra prueba, fallarían.</description>
    </item>
    
    <item>
      <title>Atributos</title>
      <link>https://www.wikiod.com/es/nunit/atributos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/nunit/atributos/</guid>
      <description>La versión 1 de NUnit usó el enfoque clásico para identificar pruebas basadas en convenciones de nomenclatura y herencia. Desde la versión 2.0 en adelante, NUnit ha utilizado atributos personalizados para este propósito.
Debido a que los accesorios de prueba de NUnit no se heredan de una clase de marco, el desarrollador puede usar la herencia de otras formas. Y debido a que no existe una convención arbitraria para nombrar las pruebas, la elección de los nombres puede estar completamente orientada a comunicar el propósito de la prueba.</description>
    </item>
    
  </channel>
</rss>
