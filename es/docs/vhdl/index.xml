<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial vhdl on </title>
    <link>https://www.wikiod.com/es/docs/vhdl/</link>
    <description>Recent content in Tutorial vhdl on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/vhdl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con vhdl</title>
      <link>https://www.wikiod.com/es/vhdl/comenzando-con-vhdl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/comenzando-con-vhdl/</guid>
      <description>Señales frente a variables, una breve descripción de la semántica de simulación de VHDL # Este ejemplo trata uno de los aspectos más fundamentales del lenguaje VHDL: la semántica de simulación. Está destinado a principiantes de VHDL y presenta una vista simplificada donde se han omitido muchos detalles (procesos pospuestos, interfaz de procedimiento de VHDL, variables compartidas&amp;hellip;) Los lectores interesados ​​en la semántica completa real deben consultar el Manual de referencia del lenguaje (LRM).</description>
    </item>
    
    <item>
      <title>Diseño de hardware digital utilizando VHDL en pocas palabras</title>
      <link>https://www.wikiod.com/es/vhdl/diseno-de-hardware-digital-utilizando-vhdl-en-pocas-palabras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/diseno-de-hardware-digital-utilizando-vhdl-en-pocas-palabras/</guid>
      <description>En este tema proponemos un método simple para diseñar correctamente circuitos digitales simples con VHDL. El método se basa en diagramas de bloques gráficos y en un principio fácil de recordar:
Piense primero en el hardware, luego codifique VHDL
Está destinado a principiantes en el diseño de hardware digital utilizando VHDL, con una comprensión limitada de la semántica de síntesis del lenguaje.
El diseño de hardware digital con VHDL es simple, incluso para principiantes, pero hay algunas cosas importantes que debe saber y un pequeño conjunto de reglas que obedecer.</description>
    </item>
    
    <item>
      <title>tipos protegidos</title>
      <link>https://www.wikiod.com/es/vhdl/tipos-protegidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/tipos-protegidos/</guid>
      <description>Antes de VHDL 1993, dos procesos simultáneos solo podían comunicarse con señales. Gracias a la semántica de simulación del lenguaje que actualiza las señales solo entre pasos de simulación, el resultado de una simulación era determinista: no dependía del orden elegido por el programador de simulación para ejecutar los procesos.
[De hecho, esto no es 100% cierto. Los procesos también podrían comunicarse mediante la entrada/salida de archivos. Pero si un diseñador estaba comprometiendo el determinismo al usar archivos, en realidad no podría ser un error.</description>
    </item>
    
    <item>
      <title>Esperar</title>
      <link>https://www.wikiod.com/es/vhdl/esperar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/esperar/</guid>
      <description>Sintaxis # esperar [en SEÑAL1[, SEÑAL2[&amp;hellip;]]] [hasta CONDICIÓN] [para TIMEOUT]; Espere; &amp;ndash; Eterna espera esperar en s1, s2; &amp;ndash; Espere hasta que cambien las señales s1 o s2 (o ambas) esperar hasta s1 = 15; &amp;ndash; Espere hasta que la señal s1 cambie y su nuevo valor sea 15 esperar hasta s1 = 15 por 10 ns; &amp;ndash; Espere hasta que la señal s1 cambie y su nuevo valor sea 15 por un máximo de 10 ns Esperar hasta la condición # Es posible omitir las cláusulas on &amp;lt;sensitivity_list&amp;gt; y for &amp;lt;timeout&amp;gt;, como en:</description>
    </item>
    
    <item>
      <title>Funciones de resolución, tipos no resueltos y resueltos</title>
      <link>https://www.wikiod.com/es/vhdl/funciones-de-resolucion-tipos-no-resueltos-y-resueltos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/funciones-de-resolucion-tipos-no-resueltos-y-resueltos/</guid>
      <description>Los tipos de VHDL pueden ser no resueltos o resueltos. El tipo bit declarado por el paquete std.standard, por ejemplo, no está resuelto, mientras que el tipo std_logic declarado por el paquete ieee.std_logic_1164 está resuelto.
Una señal cuyo tipo no está resuelto no puede ser impulsada (asignada) por más de un proceso VHDL, mientras que una señal cuyo tipo está resuelto sí puede.
El uso de tipos resueltos debe reservarse para situaciones en las que la intención es realmente modelar un cable de hardware (o un conjunto de cables) controlado por más de un circuito de hardware.</description>
    </item>
    
    <item>
      <title>D-Flip-Flops (DFF) y pestillos</title>
      <link>https://www.wikiod.com/es/vhdl/d-flip-flops-dff-y-pestillos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/d-flip-flops-dff-y-pestillos/</guid>
      <description>D-Flip-Flops (DFF) y pestillos son elementos de memoria. Un DFF muestrea su entrada en uno u otro borde de su reloj (no en ambos) mientras que un latch es transparente en un nivel de su habilitación y memorización en el otro. La siguiente figura ilustra la diferencia:
Modelar DFF o latches en VHDL es fácil, pero hay algunos aspectos importantes que deben tenerse en cuenta:
Las diferencias entre los modelos VHDL de DFF y latches.</description>
    </item>
    
    <item>
      <title>Análisis de tiempo estático ¿qué significa cuando un diseño falla en el tiempo?</title>
      <link>https://www.wikiod.com/es/vhdl/analisis-de-tiempo-estatico-que-significa-cuando-un-diseno-falla-en-el-tiempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/analisis-de-tiempo-estatico-que-significa-cuando-un-diseno-falla-en-el-tiempo/</guid>
      <description>¿Qué es el tiempo? # El concepto de temporización está más relacionado con la física de los flip flops que con VHDL, pero es un concepto importante que cualquier diseñador que utilice VHDL para crear hardware debería conocer.
Cuando diseñamos hardware digital, normalmente creamos lógica síncrona. Esto significa que nuestros datos viajan de flip-flop a flip-flop, posiblemente con alguna lógica combinatoria entre ellos. El diagrama más básico de lógica síncrona que incorpora una función combinatoria se muestra a continuación:</description>
    </item>
    
    <item>
      <title>Comentarios</title>
      <link>https://www.wikiod.com/es/vhdl/comentarios/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/comentarios/</guid>
      <description>Cualquier lenguaje de programación decente admite comentarios. En VHDL son especialmente importantes porque comprender un código VHDL, incluso moderadamente sofisticado, suele ser un desafío.
Comentarios de una sola línea # Un comentario de una sola línea comienza con dos guiones (--) y se extiende hasta el final de la línea. Ejemplo :
-- This process models the state register process(clock, aresetn) begin if aresetn = &#39;0&#39; then -- Active low, asynchronous reset state &amp;lt;= IDLE; elsif rising_edge(clock) then -- Synchronized on the rising edge of the clock state &amp;lt;= next_state; end if; end process; Comentarios delimitados # A partir de VHDL 2008, un comentario también puede extenderse en varias líneas.</description>
    </item>
    
    <item>
      <title>Recuerdos</title>
      <link>https://www.wikiod.com/es/vhdl/recuerdos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/recuerdos/</guid>
      <description>Esto cubre las memorias de un solo puerto y de dos puertos.
Sintaxis # Tipo de memoria para ancho y profundidad constante.
type MEMORY_TYPE is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0); Tipo de memoria para profundidad variable y ancho constante.
type MEMORY_TYPE is array (natural range &amp;lt;&amp;gt;) of std_logic_vector(WIDTH-1 downto 0); Registro de turnos # Un registro de desplazamiento de longitud genérica. Con serial in y serial out.</description>
    </item>
    
    <item>
      <title>literales</title>
      <link>https://www.wikiod.com/es/vhdl/literales/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/vhdl/literales/</guid>
      <description>Esto tiene cómo especificar constantes, llamadas literales en VHDL
Literales numéricos # 16#A8# -- hex 2#100# -- binary 2#1000_1001_1111_0000 -- long number, adding (optional) _ (one or more) for readability 1234 -- decimal Literal enumerado # type state_t is (START, READING, WRITING); -- user-defined enumerated type </description>
    </item>
    
  </channel>
</rss>
