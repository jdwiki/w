<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorial abierto on </title>
    <link>https://www.wikiod.com/es/docs/opengl/</link>
    <description>Recent content in tutorial abierto on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/opengl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con opengl</title>
      <link>https://www.wikiod.com/es/opengl/comenzando-con-opengl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/comenzando-con-opengl/</guid>
      <description>Configuración manual de OpenGL en Windows # Código de ejemplo completo incluido al final
Componentes de Windows para OpenGL WGL WGL (se puede pronunciar wiggle) significa &amp;ldquo;Windows-GL&amp;rdquo;, como en &amp;ldquo;una interfaz entre Windows y OpenGL&amp;rdquo;, un conjunto de funciones de la API de Windows para comunicarse con OpenGL. Las funciones WGL tienen un prefijo wgl y sus tokens tienen un prefijo WGL_.
La versión predeterminada de OpenGL admitida en los sistemas de Microsoft es 1.</description>
    </item>
    
    <item>
      <title>Texturizado</title>
      <link>https://www.wikiod.com/es/opengl/texturizado/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/texturizado/</guid>
      <description>Conceptos básicos de texturizado # Una textura es una forma de almacenamiento de datos que permite un acceso conveniente no solo a entradas de datos particulares, sino también a puntos de muestra que mezclan (interpolan) varias entradas juntas.
En OpenGL, las texturas se pueden usar para muchas cosas, pero lo más común es asignar una imagen a un polígono (por ejemplo, un triángulo). Para mapear la textura a un triángulo (u otro polígono) tenemos que decirle a cada vértice a qué parte de la textura corresponde.</description>
    </item>
    
    <item>
      <title>Encapsular objetos OpenGL con C&#43;&#43; RAII</title>
      <link>https://www.wikiod.com/es/opengl/encapsular-objetos-opengl-con-c-raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/encapsular-objetos-opengl-con-c-raii/</guid>
      <description>Ejemplos de varias formas de hacer que los objetos OpenGL funcionen con C++ RAII.
La encapsulación RAII de objetos OpenGL tiene peligros. Lo más inevitable es que los objetos OpenGL estén asociados con el contexto OpenGL que los creó. Por lo tanto, la destrucción de un objeto C++ RAII debe realizarse en un contexto OpenGL que comparte la propiedad del objeto OpenGL administrado por ese objeto C++.
Esto también significa que si se destruyen todos los contextos que poseen el objeto, cualquier objeto OpenGL encapsulado en RAII existente intentará destruir los objetos que ya no existen.</description>
    </item>
    
    <item>
      <title>matemáticas 3d</title>
      <link>https://www.wikiod.com/es/opengl/matematicas-3d/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/matematicas-3d/</guid>
      <description>Introducción a las matrices # Cuando está programando en OpenGL o cualquier otra API de gráficos, chocará con una pared de ladrillos cuando no sea tan bueno en matemáticas. Aquí explicaré con un código de ejemplo cómo puede lograr movimiento/escalado y muchas otras cosas geniales con su objeto 3D.
Tomemos un caso de la vida real&amp;hellip; Ha creado un cubo impresionante (tridimensional) en OpenGL y desea moverlo en cualquier dirección.</description>
    </item>
    
    <item>
      <title>Iluminación básica</title>
      <link>https://www.wikiod.com/es/opengl/iluminacion-basica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/iluminacion-basica/</guid>
      <description>Modelo de iluminación Phong # NOTA: Este ejemplo es WIP, se actualizará con diagramas, imágenes, más ejemplos, etc.
¿Qué es Phong?
Phong es un modelo de luz muy básico, pero de aspecto real, para superficies que consta de tres partes: iluminación ambiental, difusa y especular.
Iluminación ambiental:
La iluminación ambiental es la más simple de las tres partes para entender y calcular. La iluminación ambiental es luz que inunda la escena e ilumina el objeto de manera uniforme en todas las direcciones.</description>
    </item>
    
    <item>
      <title>sombreadores</title>
      <link>https://www.wikiod.com/es/opengl/sombreadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/sombreadores/</guid>
      <description>Sintaxis # #version version_number // Qué versión de GLSL estamos usando void main() { /* Código */ } // Función principal de Shader en nombre de tipo; // Especifica un parámetro de entrada - GLSL 1.30 escriba el nombre; // Especifica un parámetro de salida - GLSL 1.30 nombre del tipo de entrada y salida; // Parámetro para entrada y salida - GLSL 1.30 Parámetros # Parámetro Detalles tipo El tipo de parámetro, tiene que ser un tipo integrado de GLSL.</description>
    </item>
    
    <item>
      <title>Carga y compilación de sombreadores</title>
      <link>https://www.wikiod.com/es/opengl/carga-y-compilacion-de-sombreadores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/carga-y-compilacion-de-sombreadores/</guid>
      <description>Estos ejemplos demuestran varias formas de cargar y compilar shaders. Todos los ejemplos deben incluir el código de manejo de errores.
Los objetos Shader, creados a partir de glCreateShader, no hacen mucho. Contienen el código compilado para una sola etapa, pero ni siquiera tienen que contener el código compilado completo para esa etapa. En muchos sentidos, funcionan como archivos de objetos C y C++.
Los objetos de programa contienen el programa vinculado final.</description>
    </item>
    
    <item>
      <title>Vista y proyección OGL</title>
      <link>https://www.wikiod.com/es/opengl/vista-y-proyeccion-ogl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/vista-y-proyeccion-ogl/</guid>
      <description>Acerca de la matriz de modelo, la matriz de vista, la proyección ortográfica y en perspectiva
Implementar una cámara en OGL 4.0 GLSL 400 # Si queremos mirar una escena como si la hubiéramos fotografiado con una cámara, primero debemos definir algunas cosas:
La posición desde la que se ve la escena, la posición del ojo pos. El punto que miramos en la escena (target). It is also common to define the direction in which we look.</description>
    </item>
    
    <item>
      <title>Búferes de fotogramas</title>
      <link>https://www.wikiod.com/es/opengl/buferes-de-fotogramas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/buferes-de-fotogramas/</guid>
      <description>Conceptos básicos de los búferes de fotogramas # Framebuffer es un tipo de búfer que almacena valores de color, profundidad e información de plantilla de píxeles en la memoria. Cuando dibujas algo en OpenGL, la salida se almacena en el búfer de fotogramas predeterminado y luego ves los valores de color de este búfer en la pantalla. También puede crear su propio búfer de fotogramas que se puede usar para muchos efectos geniales de posprocesamiento, como escala de grises, desenfoque, profundidad de campo, distorsiones, reflejos&amp;hellip;</description>
    </item>
    
    <item>
      <title>Uso de VAO</title>
      <link>https://www.wikiod.com/es/opengl/uso-de-vao/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/opengl/uso-de-vao/</guid>
      <description>El Vertex Array Object almacena cómo opengl debe interpretar un conjunto de VBO.
En esencia, le permitirá evitar llamar a glVertexAttribPointer cada vez que desee generar una nueva malla.
Si no quiere lidiar con VAO, simplemente puede crear uno y vincularlo durante la inicialización del programa y pretender que no existen.
Sintaxis # void glEnableVertexAttribArray​(GLuint attribIndex);
void glDisableVertexAttribArray​(GLuint attribIndex);
void glVertexAttribPointer(GLuint attribIndex, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);</description>
    </item>
    
  </channel>
</rss>
