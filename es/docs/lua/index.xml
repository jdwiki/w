<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial Lua on </title>
    <link>https://www.wikiod.com/es/docs/lua/</link>
    <description>Recent content in Tutorial Lua on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/lua/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Empezando con Lua</title>
      <link>https://www.wikiod.com/es/lua/empezando-con-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/empezando-con-lua/</guid>
      <description>Comentarios # Los comentarios de una sola línea en Lua comienzan con -- y continúan hasta el final de la línea:
-- this is single line comment -- need another line -- huh? Los comentarios en bloque comienzan con --[[ y terminan con ]]:
--[[ This is block comment. So, it can go on... and on... and on.... ]] Los comentarios de bloque usan el mismo estilo de delimitadores que las cadenas largas; Se puede agregar cualquier número de signos de igual entre los corchetes para delimitar un comentario:</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/lua/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/la-coincidencia-de-patrones/</guid>
      <description>Sintaxis # string.find(str, pattern [, init [, plain]]) &amp;ndash; Devuelve el índice inicial y final de la coincidencia en str
string.match(str, patrón [, índice]) &amp;ndash; Coincide con un patrón una vez (comenzando en el índice)
string.gmatch(str, pattern) &amp;ndash; Devuelve una función que itera a través de todas las coincidencias en str
string.gsub(str, pattern, repl [, n]) &amp;ndash; Reemplaza subcadenas (hasta un máximo de n veces)
. representa todos los caracteres</description>
    </item>
    
    <item>
      <title>Conjuntos</title>
      <link>https://www.wikiod.com/es/lua/conjuntos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/conjuntos/</guid>
      <description>Uso de una tabla como conjunto # Crear un conjunto # local set = {} -- empty set Cree un conjunto con elementos estableciendo su valor en true:
local set = {pear=true, plum=true} -- or initialize by adding the value of a variable: local fruit = &#39;orange&#39; local other_set = {[fruit] = true} -- adds &#39;orange&#39; Agregar un miembro al conjunto # agregue un miembro estableciendo su valor en true</description>
    </item>
    
    <item>
      <title>Mesas</title>
      <link>https://www.wikiod.com/es/lua/mesas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/mesas/</guid>
      <description>Sintaxis # ipairs(numeric_table) &amp;ndash; tabla Lua con iterador de índices numéricos pairs(input_table) &amp;ndash; iterador de tabla Lua genérico clave, valor = siguiente (tabla_de_entrada, clave_de_entrada) &amp;ndash; Selector de valor de la tabla Lua table.insert(input_table, [position], value) &amp;ndash; inserta el valor especificado en la tabla de entrada valor_eliminado = tabla.remove(tabla_de_entrada, [posición]) &amp;ndash; muestra el último o elimina el valor especificado por la posición Las tablas son la única estructura de datos integrada disponible en Lua.</description>
    </item>
    
    <item>
      <title>Booleanos en Lua</title>
      <link>https://www.wikiod.com/es/lua/booleanos-en-lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/booleanos-en-lua/</guid>
      <description>Los valores booleanos, la verdad y la falsedad son sencillos en Lua. Para revisar:
Hay un tipo booleano con exactamente dos valores: verdadero y falso. En un contexto condicional (if, elseif, while, hasta), no se requiere un valor booleano. Se puede utilizar cualquier expresión. En un contexto condicional, falso y nil cuentan como falso, y todo lo demás cuenta como verdadero. Aunque 3 ya implica esto: si vienes de otros idiomas, recuerda que 0 y la cadena vacía cuentan como verdaderos en contextos condicionales en Lua.</description>
    </item>
    
    <item>
      <title>Funciones</title>
      <link>https://www.wikiod.com/es/lua/funciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/funciones/</guid>
      <description>Sintaxis # nombrefunción = función(paramA, paramB, &amp;hellip;) cuerpo; return exprlist end &amp;ndash; una función simple function funcname(paramA, paramB, &amp;hellip;) cuerpo; return exprlist end &amp;ndash; abreviatura de arriba local nombrefunción = función(paramA, paramB, &amp;hellip;) cuerpo; return exprlist end &amp;ndash; una lambda local nombre de función; nombrefunción = función(paramA, paramB, &amp;hellip;) cuerpo; return exprlist end &amp;ndash; lambda que puede hacer llamadas recursivas función local funcname(paramA, paramB, &amp;hellip;) cuerpo; return exprlist end &amp;ndash; abreviatura de arriba nombrefunc(paramA, paramB, &amp;hellip;) &amp;ndash; llamar a una función local var = var o &amp;ldquo;Predeterminado&amp;rdquo; &amp;ndash; un parámetro predeterminado devuelve nil, &amp;ldquo;mensajes de error&amp;rdquo; &amp;ndash; forma estándar de abortar con un error Las funciones generalmente se configuran con function a(b,c) .</description>
    </item>
    
    <item>
      <title>Manejo de errores</title>
      <link>https://www.wikiod.com/es/lua/manejo-de-errores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/manejo-de-errores/</guid>
      <description>Manejo de errores en Lua # Suponiendo que tenemos la siguiente función:
function foo(tab) return tab.a end -- Script execution errors out w/ a stacktrace when tab is not a table vamos a mejorarlo un poco
function foo(tab) if type(tab) ~= &amp;quot;table&amp;quot; then error(&amp;quot;Argument 1 is not a table!&amp;quot;, 2) end return tab.a end -- This gives us more information, but script will still error out Si no queremos que una función bloquee un programa incluso en caso de error, es estándar en lua hacer lo siguiente:</description>
    </item>
    
    <item>
      <title>Introducción a la API de Lua C</title>
      <link>https://www.wikiod.com/es/lua/introduccion-a-la-api-de-lua-c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/introduccion-a-la-api-de-lua-c/</guid>
      <description>Sintaxis # estado_lua *L = lua_open(); // Crear un nuevo estado de VM; Lúa 5.0 dos_Estado *L = dosL_nuevoestado(); // Crear un nuevo estado de VM; Dos 5.1+ int luaL_dofile(lua_State *L, const char *nombre de archivo); // Ejecutar un script lua con el nombre de archivo dado usando el lua_State especificado anular luaL_openlibs(lua_State *L); // Cargar todas las bibliotecas estándar en el lua_State especificado void lua_close(lua_State *L); // Cerrar el estado de la VM y liberar cualquier recurso interno void lua_call(lua_State *L, int nargs, int nresults); // Llamar al luavalue en el índice -(nargs + 1) Lua también proporciona una API C adecuada para su máquina virtual.</description>
    </item>
    
    <item>
      <title>Metatablas</title>
      <link>https://www.wikiod.com/es/lua/metatablas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/metatablas/</guid>
      <description>Sintaxis # [[local] mt = ]getmetatable(t) &amp;ndash;&amp;gt; recuperar la metatabla asociada para &amp;lsquo;t&amp;rsquo; [[local] t = ]setmetatable(t, mt) &amp;ndash;&amp;gt; establece la metatabla para &amp;lsquo;t&amp;rsquo; en &amp;lsquo;mt&amp;rsquo; y devuelve &amp;lsquo;t&amp;rsquo; Parámetros # Parámetro Detalles t Variable referente a una tabla lua; también puede ser un literal de tabla. mt Tabla para usar como metatabla; puede tener cero o más campos de metamétodo establecidos. Hay algunos metamétodos que no se mencionan aquí. Para ver la lista completa y su uso, consulte la entrada correspondiente en el lua manual.</description>
    </item>
    
    <item>
      <title>Argumentos Variádicos</title>
      <link>https://www.wikiod.com/es/lua/argumentos-variadicos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/lua/argumentos-variadicos/</guid>
      <description>Varargs, como se les conoce comúnmente, permiten que las funciones tomen un número arbitrario de argumentos sin especificación. Todos los argumentos dados a dicha función se empaquetan en una sola estructura conocida como lista vararg; que se escribe como ... en lua. Hay métodos básicos para extraer el número de argumentos dados y el valor de esos argumentos usando la función select(), pero los patrones de uso más avanzados pueden aprovechar la estructura para su utilidad completa.</description>
    </item>
    
  </channel>
</rss>
