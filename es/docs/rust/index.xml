<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de óxido on </title>
    <link>https://www.wikiod.com/es/docs/rust/</link>
    <description>Recent content in Tutorial de óxido on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Rust</title>
      <link>https://www.wikiod.com/es/rust/primeros-pasos-con-rust/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/primeros-pasos-con-rust/</guid>
      <description>Uso avanzado de println! # println! (y su hermano, [print!](https://doc.rust-lang. org/std/macro.print!.html)) proporciona un mecanismo conveniente para producir e imprimir texto que contiene datos dinámicos, similar a la familia de funciones printf que se encuentra en muchos otros lenguajes. Su primer argumento es una cadena de formato, que dicta cómo deben imprimirse los otros argumentos como texto. La cadena de formato puede contener marcadores de posición (dentro de {}) para especificar que debe ocurrir una sustitución:</description>
    </item>
    
    <item>
      <title>Serde</title>
      <link>https://www.wikiod.com/es/rust/serde/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/serde/</guid>
      <description>Serde es un marco popular de serialización y deserialización para Rust, que se utiliza para convertir datos serializados (p. ej., JSON y XML) en estructuras de Rust y viceversa.
Serde admite muchos formatos, incluidos: JSON, YAML, TOML, BSON, Pickle y XML.
Estructura ↔ JSON # principal.rs # extern crate serde; extern crate serde_json; // Import this crate to derive the Serialize and Deserialize traits. #[macro_use] extern crate serde_derive; #[derive(Serialize, Deserialize, Debug)] struct Point { x: i32, y: i32, } fn main() { let point = Point { x: 1, y: 2 }; // Convert the Point to a packed JSON string.</description>
    </item>
    
    <item>
      <title>Rasgos</title>
      <link>https://www.wikiod.com/es/rust/rasgos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/rasgos/</guid>
      <description>Los rasgos son una forma de describir un &amp;lsquo;contrato&amp;rsquo; que debe implementar una &amp;rsquo;estructura&amp;rsquo;. Los rasgos normalmente definen firmas de métodos, pero también pueden proporcionar implementaciones basadas en otros métodos del rasgo, siempre que los límites del rasgo lo permitan.
Para aquellos familiarizados con la programación orientada a objetos, los rasgos pueden considerarse como interfaces con algunas diferencias sutiles.
Sintaxis # rasgo Rasgo { fn método(&amp;hellip;) -&amp;gt; ReturnType; &amp;hellip; }</description>
    </item>
    
    <item>
      <title>Bucles</title>
      <link>https://www.wikiod.com/es/rust/bucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/bucles/</guid>
      <description>Sintaxis # bucle { bloque } // bucle infinito
while condición { bloqueo }
while let patrón = expr { bloque }
para patrón en expr { bloque } // expr debe implementar IntoIterator
continuar // salta al final del cuerpo del ciclo, comenzando una nueva iteración si es necesario
romper // detener el ciclo
&amp;lsquo;etiqueta: bucle { bloque }
&amp;lsquo;etiqueta: while condición { bloqueo }
&amp;lsquo;etiqueta: while let patrón = expr { bloque }</description>
    </item>
    
    <item>
      <title>Guía de estilo de óxido</title>
      <link>https://www.wikiod.com/es/rust/guia-de-estilo-de-oxido/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/guia-de-estilo-de-oxido/</guid>
      <description>Aunque no existe una guía de estilo oficial de Rust, los siguientes ejemplos muestran las convenciones adoptadas por la mayoría de los proyectos de Rust. Seguir estas convenciones alineará el estilo de su proyecto con el de la biblioteca estándar, lo que facilitará que las personas vean la lógica en su código.
Las pautas de estilo oficiales de Rust estaban disponibles en el repositorio rust-lang/rust en GitHub, pero se han eliminado recientemente, a la espera de la migración al repositorio rust-lang-nursery/fmt-rfcs.</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/rust/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/la-coincidencia-de-patrones/</guid>
      <description>Sintaxis # _ // patrón comodín, coincide con cualquier cosa¹ ident // patrón de vinculación, coincide con cualquier cosa y lo vincula a ident¹ ident @ pat // igual que arriba, pero permite hacer coincidir aún más lo que está enlazado ref ident // patrón de vinculación, coincide con cualquier cosa y lo vincula a una referencia ident¹ ref mut ident // patrón de vinculación, coincide con cualquier cosa y lo vincula a una referencia mutable ident¹ &amp;amp;pat // coincide con una referencia (pat por lo tanto no es una referencia sino el árbitro)¹ &amp;amp;mut pat // igual que arriba con una referencia mutable¹ CONST // coincide con una constante nombrada Estructura { campo1, campo2 } // coincide y deconstruye un valor de estructura, vea a continuación la nota sobre campos¹ EnumVariant // coincide con una variante de enumeración EnumVariant(pat1, pat2) // coincide con una variante de enumeración y los parámetros correspondientes EnumVariant(pat1, pat2, .</description>
    </item>
    
    <item>
      <title>vidas</title>
      <link>https://www.wikiod.com/es/rust/vidas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/vidas/</guid>
      <description>Sintaxis # función fn&amp;lt;&amp;lsquo;a&amp;gt;(x: &amp;amp;&amp;lsquo;a Tipo)
struct Estructura&amp;lt;&amp;lsquo;a&amp;gt; { x: &amp;amp;&amp;lsquo;a Tipo }
enum Enum&amp;lt;&amp;lsquo;a&amp;gt; { Variante(&amp;amp;&amp;lsquo;a Tipo) }
impl&amp;lt;&amp;lsquo;a&amp;gt; Struct&amp;lt;&amp;lsquo;a&amp;gt; { fn x&amp;lt;&amp;lsquo;a&amp;gt;(&amp;amp;self) -&amp;gt; &amp;amp;&amp;lsquo;a Type { self.x } }
impl&amp;lt;&amp;lsquo;a&amp;gt; Rasgo&amp;lt;&amp;lsquo;a&amp;gt; para Tipo
rasgo impl&amp;lt;&amp;lsquo;a&amp;gt; para Tipo&amp;lt;&amp;lsquo;a&amp;gt;
función fn&amp;lt;F&amp;gt;(f: F) donde para&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Tipo)
struct Struct&amp;lt;F&amp;gt; donde para&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Tipo) { x: F }
enum Enum&amp;lt;F&amp;gt; donde para&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Tipo) { Variant(F) }
impl&amp;lt;F&amp;gt; Struct&amp;lt;F&amp;gt; donde para&amp;lt;&#39;a&amp;gt; F: FnOnce(&amp;amp;&#39;a Type) { fn x(&amp;amp;self) -&amp;gt; &amp;amp;F { &amp;amp;self.</description>
    </item>
    
    <item>
      <title>ES de archivos</title>
      <link>https://www.wikiod.com/es/rust/es-de-archivos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/es-de-archivos/</guid>
      <description>Leer un archivo como un todo como una cadena # use std::fs::File; use std::io::Read; fn main() { let filename = &amp;quot;src/main.rs&amp;quot;; // Open the file in read-only mode. match File::open(filename) { // The file is open (no error). Ok(mut file) =&amp;gt; { let mut content = String::new(); // Read all the file content into a variable (ignoring the result of the operation). file.read_to_string(&amp;amp;mut content).unwrap(); println!(&amp;quot;{}&amp;quot;, content); // The file is automatically closed when is goes out of scope.</description>
    </item>
    
    <item>
      <title>Paralelismo</title>
      <link>https://www.wikiod.com/es/rust/paralelismo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/paralelismo/</guid>
      <description>El paralelismo es compatible con la biblioteca estándar de Rust a través de varias clases, como el módulo std::thread, canales y átomos. Esta sección lo guiará a través del uso de estos tipos.
Comunicación entre hilos con canales # Los canales se pueden utilizar para enviar datos de un subproceso a otro. A continuación se muestra un ejemplo de un sistema productor-consumidor simple, donde el subproceso principal produce los valores 0, 1, &amp;hellip;, 9, y el subproceso generado los imprime:</description>
    </item>
    
    <item>
      <title>Instrumentos de cuerda</title>
      <link>https://www.wikiod.com/es/rust/instrumentos-de-cuerda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/rust/instrumentos-de-cuerda/</guid>
      <description>A diferencia de muchos otros lenguajes, Rust tiene dos tipos de cadenas principales: String (un tipo de cadena asignada al almacenamiento dinámico) y &amp;amp;str (una cadena prestada, que no usa memoria adicional). Saber la diferencia y cuándo usar cada uno es vital para comprender cómo funciona Rust.
Manipulación básica de cadenas # fn main() { // Statically allocated string slice let hello = &amp;quot;Hello world&amp;quot;; // This is equivalent to the previous one let hello_again: &amp;amp;&#39;static str = &amp;quot;Hello world&amp;quot;; // An empty String let mut string = String::new(); // An empty String with a pre-allocated initial buffer let mut capacity = String::with_capacity(10); // Add a string slice to a String string.</description>
    </item>
    
  </channel>
</rss>
