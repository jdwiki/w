<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MOQTutorial on </title>
    <link>https://www.wikiod.com/es/docs/moq/</link>
    <description>Recent content in MOQTutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/moq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con moq</title>
      <link>https://www.wikiod.com/es/moq/comenzando-con-moq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/moq/comenzando-con-moq/</guid>
      <description>Instalación o Configuración # Seleccione el proyecto al que desea agregar la referencia a Moq. Abra Nuget para este proyecto. Seleccione &amp;ldquo;Examinar&amp;rdquo; y luego escriba &amp;ldquo;moq&amp;rdquo; en el cuadro de búsqueda. Seleccione &amp;ldquo;Moq&amp;rdquo; y haga clic en Instalar. Siguiendo estos pasos, se instalará el paquete Moq y se le agregará una referencia en las referencias del proyecto seleccionado. Después de completar estos pasos, Moq se puede usar en el proyecto de prueba unitaria simplemente declarándolo en los archivos de clases de prueba:</description>
    </item>
    
    <item>
      <title>Validación de orden de llamada</title>
      <link>https://www.wikiod.com/es/moq/validacion-de-orden-de-llamada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/moq/validacion-de-orden-de-llamada/</guid>
      <description>Validando el orden de llamada implícitamente # Cuando un método que se va a probar usa información de una llamada para pasar a llamadas posteriores, un enfoque que se puede usar para garantizar que los métodos se llamen en el orden esperado es configurar las expectativas para reflejar este flujo de datos.
Dado el método a probar:
public void MethodToTest() { var str = _utility.GetInitialValue(); str = _utility.PrefixString(str); str = _utility.</description>
    </item>
    
    <item>
      <title>Burlarse de interfaces comunes</title>
      <link>https://www.wikiod.com/es/moq/burlarse-de-interfaces-comunes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/moq/burlarse-de-interfaces-comunes/</guid>
      <description>Burlándose de IEnumerable # Burlarse de una interfaz que hereda de IEnumerable para devolver datos enlatados es bastante sencillo. Suponiendo las siguientes clases:
public class DataClass { public int Id { get; set; } } public interface IEnumerableClass : IEnumerable&amp;lt;DataClass&amp;gt; { } Se puede tomar el siguiente enfoque. Primero, cree una lista que contenga la información que debe devolver el simulacro:
IList&amp;lt;DataClass&amp;gt; list = new List&amp;lt;DataClass&amp;gt;(); for (int i = 0; i &amp;lt; 10; i++) { list.</description>
    </item>
    
    <item>
      <title>Burlarse de propiedades</title>
      <link>https://www.wikiod.com/es/moq/burlarse-de-propiedades/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/moq/burlarse-de-propiedades/</guid>
      <description>Propiedades de creación automática de apéndices # A veces, desea simular una clase o una interfaz y hacer que sus propiedades se comporten como si fueran simples captadores y definidores. Como este es un requisito común, Moq proporciona un método abreviado para configurar todas las propiedades de un simulacro para almacenar y recuperar valores:
// SetupAllProperties tells mock to implement setter/getter funcationality var userMock = new Mock&amp;lt;IUser&amp;gt;().SetupAllProperties(); // Invoke the code to test SetPropertiesOfUser(userMock.</description>
    </item>
    
    <item>
      <title>comportamiento burlón</title>
      <link>https://www.wikiod.com/es/moq/comportamiento-burlon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/moq/comportamiento-burlon/</guid>
      <description>Sintaxis # mock.Setup(expression).Returns(value) //Cada vez que se llame al método en la expresión, se devolverá el valor Parámetros # Parámetro Detalles expresión Expresión lambda que especifica la invocación del método. Simulación del método sin argumentos # interface Mockable { bool DoSomething(); } var mock = new Mock&amp;lt;Mockable&amp;gt;(); mock.Setup(x =&amp;gt; x.DoSomething()).Returns(true); var result = mock.Object.DoSomething(); //true Burlándose de miembros protegidos # Para simular un miembro protegido, primero debe incluir lo siguiente en la parte superior de su dispositivo de prueba:</description>
    </item>
    
  </channel>
</rss>
