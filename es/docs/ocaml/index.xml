<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de OCaml on </title>
    <link>https://www.wikiod.com/es/docs/ocaml/</link>
    <description>Recent content in Tutorial de OCaml on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/ocaml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con OCaml</title>
      <link>https://www.wikiod.com/es/ocaml/primeros-pasos-con-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/primeros-pasos-con-ocaml/</guid>
      <description>Instalación o configuración # Instalación de OPAM # OPAM es un administrador de paquetes para OCaml. Construye y administra versiones del compilador y bibliotecas OCaml fácilmente.
La forma más fácil de instalar OPAM en su sistema operativo es usar un administrador de paquetes para su sistema. por ejemplo, apt-get, yum o homebrew.
Instrucciones de instalación de Mac OSX # Actualice las fórmulas homebrew e instale OPAM.
brew update brew install opam Instrucciones de instalación de Ubuntu # add-apt-repository ppa:avsm/ppa apt-get update apt-get install ocaml opam Compilando desde la fuente # wget http://caml.</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/ocaml/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/la-coincidencia-de-patrones/</guid>
      <description>Función factorial usando coincidencia de patrones # let rec factorial n = match n with | 0 | 1 -&amp;gt; 1 | n -&amp;gt; n * (factorial (n - 1)) Esta función coincide con los valores 0 y 1 y los asigna al caso base de nuestra definición recursiva. Luego, todos los demás números se asignan a la llamada recursiva de esta función.
Evaluación de expresiones booleanas # Definimos el tipo de expresiones booleanas cuyos átomos se identifican mediante cadenas como</description>
    </item>
    
    <item>
      <title>Escriba su primer script OCaml</title>
      <link>https://www.wikiod.com/es/ocaml/escriba-su-primer-script-ocaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/escriba-su-primer-script-ocaml/</guid>
      <description>Hola Mundo # Este ejemplo asume que ha instalado OCaml.
Compilando código OCaml # Crea un nuevo archivo llamado hello.ml, con el siguiente contenido:
print_string &amp;quot;Hello world!\n&amp;quot; ocamlc es el compilador de OCaml. Para compilar y ejecutar este script, ejecute
$ ocamlc -o hello hello.ml y luego ejecutar el binario resultante
$ ./hello Hello world! Ejecutando código OCaml # También puede ejecutar este script sin compilarlo en un binario. Puede hacerlo utilizando ocaml, el sistema de nivel superior de ocaml que permite el uso interactivo de OCaml.</description>
    </item>
    
    <item>
      <title>Ocamlbuild</title>
      <link>https://www.wikiod.com/es/ocaml/ocamlbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/ocamlbuild/</guid>
      <description>Ejemplo básico sin dependencia externa # Si su proyecto no tiene una dependencia externa y tiene foo.ml como punto de entrada principal, puede compilar una versión de código de bytes con
ocamlbuild foo.byte Para obtener un ejecutable nativo, ejecute
ocamlbuild foo.native Proyecto dependiendo de bibliotecas externas # Si su proyecto depende de las bibliotecas externas, primero debe instalarlas con opam. Suponiendo que sus dependencias son foo y bar y el punto de entrada principal de su proyecto es foobar.</description>
    </item>
    
    <item>
      <title>Funciones de orden superior</title>
      <link>https://www.wikiod.com/es/ocaml/funciones-de-orden-superior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/funciones-de-orden-superior/</guid>
      <description>Sintaxis # val (|&amp;gt;) : &#39;a -&amp;gt; (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;b val (@@) : (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a -&amp;gt; &#39;b Algoritmos genéricos # Las funciones de orden superior se pueden utilizar para implementar algoritmos genéricos, renunciando a la responsabilidad de proporcionar los detalles finales al usuario. Por ejemplo, List.sort espera una función de comparación, que permite implementar varias formas de clasificación. Aquí implementamos la clasificación de cadenas que no distingue entre mayúsculas y minúsculas:</description>
    </item>
    
    <item>
      <title>Procesamiento de listas</title>
      <link>https://www.wikiod.com/es/ocaml/procesamiento-de-listas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/procesamiento-de-listas/</guid>
      <description>Lista.Mapa # List.map tiene la firma (&#39;a -&amp;gt; &#39;b) -&amp;gt; &#39;a list -&amp;gt; &#39;b list que en inglés es una función que toma una función (la llamaremos la función de mapeo) de una (es decir, &#39;a) a otro tipo (es decir, &#39;b) y una lista del primer tipo. La función devuelve una lista del segundo tipo donde cada elemento es el resultado de llamar a la función de mapeo en un elemento de la primera lista.</description>
    </item>
    
    <item>
      <title>Funciones</title>
      <link>https://www.wikiod.com/es/ocaml/funciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/funciones/</guid>
      <description>Funciones anónimas # Dado que las funciones son valores ordinarios, existe una sintaxis conveniente para crear funciones sin nombres:
List.map (fun x -&amp;gt; x * x) [1; 2; 3; 4] (* - : int list = [1; 4; 9; 16] *) Esto es útil, ya que de lo contrario tendríamos que nombrar primero la función (ver [let][1]) para poder usarla:
let square x = x * x (* val square : int -&amp;gt; int = &amp;lt;fun&amp;gt; *) List.</description>
    </item>
    
    <item>
      <title>Tuberías, archivos y flujos</title>
      <link>https://www.wikiod.com/es/ocaml/tuberias-archivos-y-flujos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/tuberias-archivos-y-flujos/</guid>
      <description>Leer desde entrada estándar e imprimir a salida estándar # Preparamos un archivo llamado reverser.ml con el siguiente contenido:
let acc = ref [] in try while true do acc := read_line () :: !acc; done with End_of_file -&amp;gt; print_string (String.concat &amp;quot;\n&amp;quot; !acc) Luego compilamos nuestro programa usando el siguiente comando:
$ ocamlc -o reverser.byte reverser.ml Lo probamos canalizando datos a nuestro nuevo ejecutable:
$ cat data.txt one two three $ .</description>
    </item>
    
    <item>
      <title>Errores comunes</title>
      <link>https://www.wikiod.com/es/ocaml/errores-comunes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/errores-comunes/</guid>
      <description>Usar el operador incorrecto # En OCaml, existen diferentes operadores aritméticos para números flotantes y enteros. Además, estos operadores solo se pueden usar en 2 flotantes o 2 enteros. Aquí hay expresiones no válidas en OCaml
1.0 + 2.0 1 + 2.0 1 +. 2 1 +. 2.0 La expresión correcta para cada uno de estos respectivamente son
1. +. 2. float_of_int 1 +. 2. 1 + 2 float_of_int 1 +.</description>
    </item>
    
    <item>
      <title>Campos de registro mutables</title>
      <link>https://www.wikiod.com/es/ocaml/campos-de-registro-mutables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ocaml/campos-de-registro-mutables/</guid>
      <description>Como la mayoría de los valores de OCaml, los registros son inmutables de forma predeterminada. Sin embargo, dado que OCaml también maneja la programación imperativa, proporciona una manera de hacer que los campos individuales sean mutables. Los campos mutables se pueden modificar en el lugar mediante asignación, en lugar de tener que recurrir a las técnicas funcionales habituales, como la actualización funcional.
Si bien presenta efectos secundarios, los campos mutables pueden mejorar el rendimiento cuando se usan correctamente.</description>
    </item>
    
  </channel>
</rss>
