<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/ada/</link>
    <description>Recent content in Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/ada/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Empezando con ada</title>
      <link>https://www.wikiod.com/es/ada/empezando-con-ada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/empezando-con-ada/</guid>
      <description>Versión # El lenguaje de programación estándar de Ada se define en el Manual de referencia de Ada. Los cambios de la versión provisional y las notas de la versión se analizan en los documentos de justificación correspondientes. Las implementaciones normalmente documentan su cumplimiento con el estándar en forma de guía de usuario y/o manual de referencia, por ejemplo, 2.
Adá 2012
Ada 2012 Language Reference Manual Rationale for Ada 2012 Adá 2005</description>
    </item>
    
    <item>
      <title>Imagen de atributo</title>
      <link>https://www.wikiod.com/es/ada/imagen-de-atributo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/imagen-de-atributo/</guid>
      <description>Los atributos de subtipo &#39;Imagen y &#39;Valor tomarán, respectivamente, un valor escalar y una cadena y devolverán, respectivamente, una cadena y un valor escalar. El resultado de &#39;Imagen se puede ingresar a &#39;Valor para obtener el valor original. Lo contrario también es cierto.
El atributo __Scalar_Object__&#39;Image se puede usar directamente en los objetos (desde Ada 2012-TC-1).
Sintaxis # Función Scalar&amp;rsquo;Image (Argumento: Scalar&amp;rsquo;Base) return String; función Discrete&amp;rsquo;Image (Argumento: Discrete&amp;rsquo;Base) return String; función Integer&amp;rsquo;Image (Argumento: Integer&amp;rsquo;Base) return String; función Enumeration&amp;rsquo;Image (Argumento: Enumeration&amp;rsquo;Base) return String; función Real&amp;rsquo;Image (Argumento: Real&amp;rsquo;Base) cadena de retorno; función Numeric&amp;rsquo;Image (Argumento: Numeric&amp;rsquo;Base) cadena de retorno; función Scalar&amp;rsquo;Value (Argumento: Cadena) devuelve Scalar&amp;rsquo;Base; función Discrete&amp;rsquo;Value (Argumento: Cadena) devuelve Discrete&amp;rsquo;Base; función Integer&amp;rsquo;Value (Argumento: Cadena) return Integer&amp;rsquo;Base; función Enumeration&amp;rsquo;Value (Argumento: Cadena) return Enumeration&amp;rsquo;Base; función Real&amp;rsquo;Value (Argumento: Cadena) devuelve Real&amp;rsquo;Base; función Scalar_Object&amp;lsquo;Imagen cadena de retorno; Tenga en cuenta que &#39;Imagen puede incurrir en resultados definidos por la implementación (RM 3.</description>
    </item>
    
    <item>
      <title>Implementando el patrón productor-consumidor</title>
      <link>https://www.wikiod.com/es/ada/implementando-el-patron-productor-consumidor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/implementando-el-patron-productor-consumidor/</guid>
      <description>Una demostración de cómo se implementa el patrón productor-consumidor en Ada.
Sintaxis # function Scalar&amp;rsquo;Imagen (Argumento: Scalar&amp;rsquo;Base) return String; tarea Task_Name; tarea Task_Name es Fin de entradas; tarea cuerpo Task_Name es Declaraciones comienzan Código final; entrada Entry_Name; aceptar Entry_Name; salida; Todos los ejemplos deberían garantizar la finalización adecuada de la tarea.
Patrón productor-consumidor utilizando el mecanismo Ada Rendezvous # Una solución síncrona productor-consumidor garantiza que el consumidor lea cada elemento de datos escrito por el productor exactamente una vez.</description>
    </item>
    
    <item>
      <title>Enumeración</title>
      <link>https://www.wikiod.com/es/ada/enumeracion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/enumeracion/</guid>
      <description>Sintaxis # función Enumeración&amp;rsquo;Imagen (Argumento: Enumeración&amp;rsquo;Base) return String; función Enumeración&amp;rsquo;Img cadena de retorno; &amp;ndash; Mosquito función Enumeration&amp;rsquo;Val (Argumento: Universal_Integer) return Enumeration&amp;rsquo;Base; función Enumeration&amp;rsquo;Pos (Argumento: Enumeration&amp;rsquo;Base) return Universal_Integer; función Enumeration&amp;rsquo;Enum_Rep (Argumento: Enumeration&amp;rsquo;Base) return Universal_Integer; función Literal&amp;lsquo;Enum_Rep devuelve Universal_Integer; &amp;ndash; Mosquito function Literal&amp;lsquo;Address return System.Address; para uso de Enumeración (Literal_1 =&amp;gt; Universal_Integer, Literal_n =&amp;gt; Universal_Integer); (Literal en Enumeración) return Boolean; Iterando literales # Un literal dentro de una enumeración es un tipo discreto, por lo que podemos usar el atributo Imagen para averiguar qué literal es como forma de texto.</description>
    </item>
    
    <item>
      <title>Archivos y flujos de ES</title>
      <link>https://www.wikiod.com/es/ada/archivos-y-flujos-de-es/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/archivos-y-flujos-de-es/</guid>
      <description>La biblioteca estándar de Ada proporciona E/S de archivos tradicionales de texto o datos binarios, así como E/S de archivos transmitidos. Los archivos de datos binarios serán secuencias de valores de un tipo, mientras que los archivos de flujo pueden ser secuencias de valores de tipos posiblemente diferentes.
Para leer y escribir elementos de diferentes tipos desde/hacia archivos continuos, Ada utiliza subprogramas indicados por los atributos de los tipos, a saber, &#39;Read, &#39;Write, &#39;Input y &#39;Output.</description>
    </item>
    
    <item>
      <title>Tarea</title>
      <link>https://www.wikiod.com/es/ada/tarea/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/tarea/</guid>
      <description>Sintaxis # tarea Task_Name; tarea Task_Name es Fin de entradas; el cuerpo de la tarea Task_Name es Declaraciones comienzan Código final; Una tarea sencilla # with Ada.Text_IO; use Ada.Text_IO; procedure Main is task My_Task; task body My_Task is begin Put_Line (&amp;quot;Hello from My_Task&amp;quot;); end; begin Put_Line (&amp;quot;Hello from Main&amp;quot;); end; Resultado # El orden de Put_Line puede variar.
Hello from My_Task Hello from Main Una tarea simple y un ciclo # with Ada.</description>
    </item>
    
    <item>
      <title>paquete Ada.Text_IO</title>
      <link>https://www.wikiod.com/es/ada/paquete-adatext_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/paquete-adatext_io/</guid>
      <description>El paquete Ada.Text_IO se usa para poner texto o para obtener texto de archivos o consola.
Poner_Línea # Imprime una cadena con una nueva línea.
with Ada.Text_IO; procedure Put_Text is use Ada.Text_IO; S : String := &amp;quot;Hello&amp;quot;; begin Put_Line (&amp;quot;Hello&amp;quot;); Put_Line (Standard_Output, &amp;quot;Hello&amp;quot;); Put_Line (Standard_Error, &amp;quot;Hello error&amp;quot;); Put_Line (S &amp;amp; &amp;quot; World&amp;quot;); end; Resultado # Hello Hello Hello error Hello World </description>
    </item>
    
    <item>
      <title>Paquetes</title>
      <link>https://www.wikiod.com/es/ada/paquetes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/paquetes/</guid>
      <description>Sintaxis # con Package_Name_To_Include; el paquete New_Package_Name cambia el nombre de Package_To_Rename; use Package_Name; el paquete Parent_Name.Child_Name es El paquete proporciona:
Encapsulación de código Compilación separada Ocultar procedimientos, funciones, operadores en tipos privados. Semejanzas o análogos en otros idiomas:
espacio de nombres de C++ paquetes Java Más sobre paquetes # En Hello World, se le presentó el paquete Ada.Text_IO y cómo usarlo para realizar operaciones de E/S dentro de su programa.</description>
    </item>
    
    <item>
      <title>Tipos parametrizados</title>
      <link>https://www.wikiod.com/es/ada/tipos-parametrizados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/tipos-parametrizados/</guid>
      <description>Todos los tipos compuestos que no sean matrices pueden tener discriminantes, que son componentes con propiedades especiales. Los discriminantes pueden ser de tipo discreto o de tipo de acceso. En el último caso, el tipo de acceso puede ser un tipo de acceso con nombre o puede ser anónimo. Un discriminante de un tipo de acceso anónimo se denomina discriminante de acceso por analogía con un parámetro de acceso.
Tipos de registros discriminados # En el caso de un tipo de registro discriminado, algunos de los componentes son conocidos como discriminantes y los componentes restantes pueden depender de estos.</description>
    </item>
    
    <item>
      <title>Tipos escalares</title>
      <link>https://www.wikiod.com/es/ada/tipos-escalares/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/ada/tipos-escalares/</guid>
      <description>En la jerarquía de tipos de Ada, los tipos elementales tienen conjuntos de valores lógicamente indivisibles. Entre estos tipos se encuentran los tipos de acceso (tipos punteros) y los tipos escalares. Los tipos escalares se pueden categorizar como enumeración, carácter y numérico. Estos tipos forman el tema de este tema. Además de los conjuntos de valores, los tipos tienen un conjunto de operaciones aplicables a los escalares respectivos, como sucesor o &amp;quot;+&amp;quot;.</description>
    </item>
    
  </channel>
</rss>
