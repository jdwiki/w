<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de C&#43;&#43; on </title>
    <link>https://www.wikiod.com/es/docs/c&#43;&#43;/</link>
    <description>Recent content in Tutorial de C&#43;&#43; on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con C&#43;&#43;</title>
      <link>https://www.wikiod.com/es/c-/comenzando-con-c-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/comenzando-con-c-/</guid>
      <description>Hola Mundo # Este programa imprime Hello World! en el flujo de salida estándar:
#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;quot;Hello World!&amp;quot; &amp;lt;&amp;lt; std::endl; } Véalo [en vivo en Coliru] (http://coliru.stacked-crooked.com/a/ba766ad8ca2fae56).
Análisis # Examinemos cada parte de este código en detalle:
#include &amp;lt;iostream&amp;gt; es una directiva de preprocesador que incluye el contenido del archivo de encabezado estándar de C++ iostream.
iostream is a standard library header file that contains definitions of the standard input and output streams.</description>
    </item>
    
    <item>
      <title>vector estándar</title>
      <link>https://www.wikiod.com/es/c-/vector-estandar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/vector-estandar/</guid>
      <description>Un vector es una matriz dinámica con almacenamiento manejado automáticamente. Se puede acceder a los elementos de un vector con la misma eficacia que a los de una matriz, con la ventaja de que los vectores pueden cambiar dinámicamente de tamaño.
En términos de almacenamiento, los datos vectoriales se colocan (generalmente) en una memoria asignada dinámicamente, lo que requiere una pequeña sobrecarga; por el contrario, C-arrays y std::array utilizan el almacenamiento automático en relación con la ubicación declarada y, por lo tanto, no tienen ninguna sobrecarga.</description>
    </item>
    
    <item>
      <title>Devolver varios valores de una función</title>
      <link>https://www.wikiod.com/es/c-/devolver-varios-valores-de-una-funcion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/devolver-varios-valores-de-una-funcion/</guid>
      <description>Hay muchas situaciones en las que es útil devolver varios valores de una función: por ejemplo, si desea ingresar un artículo y devolver el precio y el número en stock, esta funcionalidad podría ser útil. Hay muchas formas de hacer esto en C++, y la mayoría involucra STL. Sin embargo, si desea evitar el STL por alguna razón, todavía hay varias formas de hacerlo, incluidas structs/classes y arrays.
Usando std::tuple # El tipo std::tuple puede agrupar cualquier número de valores, incluidos potencialmente valores de diferentes tipos, en un solo objeto de retorno:</description>
    </item>
    
    <item>
      <title>La regla de tres, cinco y cero</title>
      <link>https://www.wikiod.com/es/c-/la-regla-de-tres-cinco-y-cero/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/la-regla-de-tres-cinco-y-cero/</guid>
      <description>Regla del Cero # Podemos combinar los principios de la regla de cinco y RAII para obtener una interfaz mucho más sencilla: la regla de cero: cualquier recurso que deba administrarse debe ser de su propio tipo. Ese tipo tendría que seguir la regla de los cinco, pero todos los usuarios de ese recurso no necesitan escribir ninguna de las cinco funciones de miembros especiales y simplemente pueden &amp;ldquo;predeterminar&amp;rdquo; todas ellas.</description>
    </item>
    
    <item>
      <title>lambdas</title>
      <link>https://www.wikiod.com/es/c-/lambdas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/lambdas/</guid>
      <description>Sintaxis # [default-capture, capture-list] (argument-list) mutable throw-specification attributes -&amp;gt; return-type { lambda-body } // Orden de especificadores lambda y atributos. [capture-list] (argument-list) { lambda-body } // Definición común de lambda. [=] (argument-list) { lambda-body } // Captura todas las variables locales necesarias por valor. [&amp;amp;] (argument-list) { lambda-body } // Captura todas las variables locales necesarias por referencia. [capture-list] { lambda-body } // Se pueden omitir la lista de argumentos y los especificadores.</description>
    </item>
    
    <item>
      <title>Punteros inteligentes</title>
      <link>https://www.wikiod.com/es/c-/punteros-inteligentes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/punteros-inteligentes/</guid>
      <description>Sintaxis # std::shared_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_shared&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); std::shared_ptr&amp;lt;ClassType&amp;gt; variableName (nuevo ClassType(arg1, arg2, ...)); std::unique_ptr&amp;lt;ClassType&amp;gt; variableName = std::make_unique&amp;lt;ClassType&amp;gt;(arg1, arg2, ...); // C++14 std::unique_ptr&amp;lt;ClassType&amp;gt; variableName (nuevo ClassType(arg1, arg2, ...)); C++ no es un lenguaje administrado por memoria. La memoria asignada dinámicamente (es decir, los objetos creados con nuevo) se &amp;ldquo;filtrará&amp;rdquo; si no se desasigna explícitamente (con delete). Es responsabilidad del programador asegurarse de que la memoria asignada dinámicamente se libere antes de descartar el último puntero a ese objeto.</description>
    </item>
    
    <item>
      <title>cadena estándar</title>
      <link>https://www.wikiod.com/es/c-/cadena-estandar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/cadena-estandar/</guid>
      <description>Las cadenas son objetos que representan secuencias de caracteres. La clase string estándar proporciona una alternativa simple, segura y versátil al uso de matrices explícitas de chars cuando se trata de texto y otras secuencias de caracteres. La clase string de C++ es parte del espacio de nombres std y se estandarizó en 1998.
Sintaxis # // Declaración de cadena vacía
std::string s;
// Construyendo desde const char* (c-string)
std::string s(&amp;ldquo;Hola&amp;rdquo;);</description>
    </item>
    
    <item>
      <title>Plantillas</title>
      <link>https://www.wikiod.com/es/c-/plantillas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/plantillas/</guid>
      <description>Se pueden crear plantillas de clases, funciones y (desde C++14) variables. Una plantilla es una pieza de código con algunos parámetros libres que se convertirán en una clase, función o variable concreta cuando se especifiquen todos los parámetros. Los parámetros pueden ser tipos, valores o plantillas en sí mismos. Una plantilla bien conocida es std::vector, que se convierte en un tipo de contenedor concreto cuando se especifica el tipo de elemento, por ejemplo, std::vector&amp;lt;int&amp;gt;.</description>
    </item>
    
    <item>
      <title>Metaprogramación</title>
      <link>https://www.wikiod.com/es/c-/metaprogramacion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/metaprogramacion/</guid>
      <description>En C++, la metaprogramación se refiere al uso de macros o plantillas para generar código en tiempo de compilación.
En general, las macros están mal vistas en este rol y se prefieren las plantillas, aunque no son tan genéricas.
La metaprogramación de plantillas a menudo hace uso de cálculos en tiempo de compilación, ya sea a través de plantillas o funciones constexpr, para lograr sus objetivos de generar código; sin embargo, los cálculos en tiempo de compilación no son metaprogramación per se.</description>
    </item>
    
    <item>
      <title>enhebrar</title>
      <link>https://www.wikiod.com/es/c-/enhebrar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/c-/enhebrar/</guid>
      <description>Sintaxis # hilo() hilo(hilo&amp;amp;&amp;amp; otro) subproceso explícito (Función&amp;amp;&amp;amp; func, Args&amp;amp;&amp;amp;&amp;hellip; args) Parámetros # | Parámetro | Detalles | | &amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | | otro | Toma posesión de otro, otro ya no posee el hilo | | función | Función para llamar en un hilo separado | | argumentos | Argumentos para func |
Algunas notas:
Dos objetos std::thread nunca pueden representar el mismo hilo. Un objeto std::thread puede estar en un estado en el que no representa ningún hilo (es decir, después de un movimiento, después de llamar a join, etc.</description>
    </item>
    
  </channel>
</rss>
