<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de principios sólidos on </title>
    <link>https://www.wikiod.com/es/docs/solid-principles/</link>
    <description>Recent content in Tutorial de principios sólidos on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/solid-principles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con principios sólidos</title>
      <link>https://www.wikiod.com/es/solid-principles/primeros-pasos-con-principios-solidos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/solid-principles/primeros-pasos-con-principios-solidos/</guid>
      <description>Principio de sustitución de Liskov # Por qué usar LSP
Escenario: Supongamos que tenemos 3 bases de datos (Clientes Hipotecarios, Clientes de Cuentas Corrientes y Clientes de Cuentas de Ahorro) que brindan datos de clientes y necesitamos detalles de clientes para el apellido del cliente dado. Ahora podemos obtener más de 1 detalle de cliente de esas 3 bases de datos contra el apellido dado.
Implementación
CAPA DEL MODELO DE NEGOCIO:</description>
    </item>
    
    <item>
      <title>Principio Abierto Cerrado (OCP)</title>
      <link>https://www.wikiod.com/es/solid-principles/principio-abierto-cerrado-ocp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/solid-principles/principio-abierto-cerrado-ocp/</guid>
      <description>Las entidades de software (clase, módulos, funciones, etc.) deben estar abiertas para la extensión pero cerradas para la modificación.
Principio abierto cerrado C# # Aquí, tratamos de explicar OCP usando código base. Primero mostraremos un escenario que viola OCP y luego eliminaremos esa violación.
Cálculo del área (Código de violación OCP):
public class Rectangle{ public double Width {get; set;} public double Height {get; set;} } public class Circle{ public double Radious {get; set;} } public double getArea (object[] shapes){ double totalArea = 0; foreach(var shape in shapes){ if(shape is Rectangle){ Rectangle rectangle = (Rectangle)shape; totalArea += rectangle.</description>
    </item>
    
    <item>
      <title>Principio de inversión de dependencia (DIP)</title>
      <link>https://www.wikiod.com/es/solid-principles/principio-de-inversion-de-dependencia-dip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/solid-principles/principio-de-inversion-de-dependencia-dip/</guid>
      <description>Básicamente, el principio dice que la &amp;ldquo;clase&amp;rdquo; debe depender de abstracciones (por ejemplo, interfaz, clases abstractas), no de detalles específicos (implementaciones). Eso significa que debe permitir que la persona que llama cree las dependencias en lugar de dejar que la clase misma cree las dependencias.
Principio de inversión de dependencia C# # Para comprender el Principio de inversión de dependencia (DIP), debemos aclarar el concepto sobre Inversión de control (IOC) e Inyección de dependencia (DI).</description>
    </item>
    
    <item>
      <title>Principio de responsabilidad única (PRS)</title>
      <link>https://www.wikiod.com/es/solid-principles/principio-de-responsabilidad-unica-prs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/solid-principles/principio-de-responsabilidad-unica-prs/</guid>
      <description>Nunca debe haber más de una razón para cambiar algo en las entidades de software (clase, función, archivo, etc.). Una clase, función, archivo, etc. debe tener solo una razón para cambiar.
Solo porque puedas, no significa que debas.
Principio de responsabilidad única C# # Analicemos primero el problema. Echa un vistazo al código a continuación:
public class BankAccount { public BankAccount() {} public string AccountNumber { get; set; } public decimal AccountBalance { get; set; } public decimal CalculateInterest() { // Code to calculate Interest } } Aquí, la clase CuentaBancaria contiene las propiedades de la cuenta y también calcular el interés de la cuenta.</description>
    </item>
    
    <item>
      <title>Principio de segregación de interfaz (ISP)</title>
      <link>https://www.wikiod.com/es/solid-principles/principio-de-segregacion-de-interfaz-isp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/solid-principles/principio-de-segregacion-de-interfaz-isp/</guid>
      <description>El principio establece que ningún cliente debe verse obligado a depender de métodos que no utiliza. Nunca se debe obligar a un cliente a implementar una interfaz que no usa o no se debe obligar a un cliente a depender de métodos que no usa.
Principio de segregación de interfaz C# # Aquí damos un ejemplo de infracción de ISP y luego refactorizamos esa infracción. Sin hablar de cosas innecesarias, saltemos al código.</description>
    </item>
    
  </channel>
</rss>
