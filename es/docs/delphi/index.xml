<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Embarcadero Delphi Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/delphi/</link>
    <description>Recent content in Embarcadero Delphi Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/delphi/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Embarcadero Delphi</title>
      <link>https://www.wikiod.com/es/delphi/primeros-pasos-con-embarcadero-delphi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/primeros-pasos-con-embarcadero-delphi/</guid>
      <description>Hola Mundo # Este programa, guardado en un archivo llamado HelloWorld.dpr, se compila en una aplicación de consola que imprime &amp;ldquo;Hello World&amp;rdquo; en la consola:
program HelloWorld; {$APPTYPE CONSOLE} begin WriteLn(&#39;Hello World&#39;); end. Muestra &amp;lsquo;Hello World&amp;rsquo; usando la VCL # Este programa utiliza VCL, la biblioteca de componentes de interfaz de usuario predeterminada de Delphi, para imprimir &amp;ldquo;Hello World&amp;rdquo; en un cuadro de mensaje. La VCL envuelve la mayoría de los componentes de WinAPI comúnmente utilizados.</description>
    </item>
    
    <item>
      <title>Uso de probar, excepto y finalmente</title>
      <link>https://www.wikiod.com/es/delphi/uso-de-probar-excepto-y-finalmente/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/uso-de-probar-excepto-y-finalmente/</guid>
      <description>Sintaxis # Try-except: pruebe [sentencias] excepto [[[en E:ExceptionType do statement]] [else statement] | [statements] end;
Try-finally: try [statements] finally [statements] end;
Devolución a prueba de excepciones de un nuevo objeto # Cuando una función devuelve un objeto (a diferencia de usar uno que pasa por la persona que llama), tenga cuidado de que una excepción no haga que el objeto se filtre.
function MakeStrings: TStrings; begin // Create a new object before entering the try-block.</description>
    </item>
    
    <item>
      <title>Ejecutar un hilo manteniendo la GUI receptiva</title>
      <link>https://www.wikiod.com/es/delphi/ejecutar-un-hilo-manteniendo-la-gui-receptiva/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/ejecutar-un-hilo-manteniendo-la-gui-receptiva/</guid>
      <description>GUI receptiva que usa subprocesos para el trabajo en segundo plano y PostMessage para informar desde los subprocesos # Mantener una GUI receptiva mientras se ejecuta un proceso largo requiere algunas &amp;ldquo;devoluciones de llamada&amp;rdquo; muy elaboradas para permitir que la GUI procese su cola de mensajes, o el uso de subprocesos (de fondo) (trabajadores).
Lanzar cualquier cantidad de subprocesos para hacer algún trabajo generalmente no es un problema. La diversión comienza cuando desea que la GUI muestre resultados intermedios y finales o informe sobre el progreso.</description>
    </item>
    
    <item>
      <title>Instrumentos de cuerda</title>
      <link>https://www.wikiod.com/es/delphi/instrumentos-de-cuerda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/instrumentos-de-cuerda/</guid>
      <description>Tipos de cadenas # Delphi tiene los siguientes tipos de cadenas (en orden de popularidad):
Tipo Longitud máxima Tamaño mínimo Descripción cadena 2 GB 16 bytes Una cadena administrada. Un alias para AnsiString hasta Delphi 2007 y un alias para UnicodeString a partir de Delphi 2009. Cadena Unicode 2GB 16 bytes Una cadena administrada en formato UTF-16. AnsiString 2GB 16 bytes Una cadena administrada en formato ANSI anterior a Unicode. A partir de Delphi 2009, lleva un indicador de página de códigos explícito.</description>
    </item>
    
    <item>
      <title>Medición de intervalos de tiempo</title>
      <link>https://www.wikiod.com/es/delphi/medicion-de-intervalos-de-tiempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/medicion-de-intervalos-de-tiempo/</guid>
      <description>Uso de la API de Windows GetTickCount # La función GetTickCount de la API de Windows devuelve el número de milisegundos desde que se inició el sistema (computadora). El ejemplo más simple sigue:
var Start, Stop, ElapsedMilliseconds: cardinal; begin Start := GetTickCount; // do something that requires measurement Stop := GetTickCount; ElapsedMillseconds := Stop - Start; end; Tenga en cuenta que GetTickCount devuelve DWORD de 32 bits, por lo que se ajusta cada 49,7 días.</description>
    </item>
    
    <item>
      <title>Genéricos</title>
      <link>https://www.wikiod.com/es/delphi/genericos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/genericos/</guid>
      <description>Ordenar una matriz dinámica a través de TArray.Sort genérico # uses System.Generics.Collections, { TArray } System.Generics.Defaults; { TComparer&amp;lt;T&amp;gt; } var StringArray: TArray&amp;lt;string&amp;gt;; { Also works with &amp;quot;array of string&amp;quot; } ... { Sorts the array case insensitive } TArray.Sort&amp;lt;string&amp;gt;(StringArray, TComparer&amp;lt;string&amp;gt;.Construct( function (const A, B: string): Integer begin Result := string.CompareText(A, B); end )); Uso sencillo de TList # var List: TList&amp;lt;Integer&amp;gt;; ... List := TList&amp;lt;Integer&amp;gt;.Create; { Create List } try List.</description>
    </item>
    
    <item>
      <title>Para bucles</title>
      <link>https://www.wikiod.com/es/delphi/para-bucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/para-bucles/</guid>
      <description>Sintaxis # para OrdinalVariable := LowerOrdinalValue to UpperOrdinalValue do begin {loop-body} end;
para OrdinalVariable := UpperOrdinalValue downto LowerOrdinalValue do begin {loop-body} end;
para EnumerableVariable en la colección, comience {loop-body} end;
La sintaxis del bucle for de Delphi no proporciona nada para cambiar la cantidad de paso de 1 a cualquier otro valor.
Al realizar un bucle con valores ordinales variables, p. variables locales de tipo Integer, los valores superior e inferior se determinarán una sola vez.</description>
    </item>
    
    <item>
      <title>Interfaces</title>
      <link>https://www.wikiod.com/es/delphi/interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/interfaces/</guid>
      <description>Las interfaces se utilizan para describir la información necesaria y la salida esperada de métodos y clases, sin proporcionar información sobre la implementación explícita.
Las clases pueden implementar interfaces, y las interfaces pueden heredarse unas de otras. Si una clase implementa una interfaz, significa que todas las funciones y procedimientos expuestos por la interfaz existen en la clase.
Un aspecto especial de las interfaces en Delphi es que las instancias de las interfaces tienen una gestión de por vida basada en el recuento de referencias.</description>
    </item>
    
    <item>
      <title>Recuperación de datos TDataSet actualizados en un subproceso en segundo plano</title>
      <link>https://www.wikiod.com/es/delphi/recuperacion-de-datos-tdataset-actualizados-en-un-subproceso-en-segundo-plano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/recuperacion-de-datos-tdataset-actualizados-en-un-subproceso-en-segundo-plano/</guid>
      <description>Este ejemplo de FireDAC, y los demás que planeo enviar, evitarán el uso de llamadas nativas para abrir el conjunto de datos de forma asíncrona.
Ejemplo de FireDAC # El ejemplo de código a continuación muestra una forma de recuperar registros de un servidor MSSql en un hilo de fondo usando FireDAC. Probado para Delphi 10 Seattle
Como esta escrito:
El subproceso recupera datos usando su propia TFDConnection y TFDQuery y transfiere los datos al FDQuery del formulario en una llamada a Sychronize().</description>
    </item>
    
    <item>
      <title>Ejecutando otros programas</title>
      <link>https://www.wikiod.com/es/delphi/ejecutando-otros-programas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/delphi/ejecutando-otros-programas/</guid>
      <description>Proceso de creación # La siguiente función encapsula el código para usar la API de Windows CreateProcess para iniciar otros programas.
Es configurable y puede esperar hasta que finalice el proceso de llamada o regresar inmediatamente.
Parámetros:
FileName - ruta completa al ejecutable
Params - parámetros de la línea de comandos o usar una cadena vacía
Folder - carpeta de trabajo para el programa llamado - si la ruta vacía se extraerá de FileName</description>
    </item>
    
  </channel>
</rss>
