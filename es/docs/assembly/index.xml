<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de lenguaje ensamblador on </title>
    <link>https://www.wikiod.com/es/docs/assembly/</link>
    <description>Recent content in Tutorial de lenguaje ensamblador on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/assembly/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con el lenguaje ensamblador</title>
      <link>https://www.wikiod.com/es/assembly/primeros-pasos-con-el-lenguaje-ensamblador/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/primeros-pasos-con-el-lenguaje-ensamblador/</guid>
      <description>Introducción # El lenguaje ensamblador es una forma legible por humanos de lenguaje de máquina o código de máquina que es la secuencia real de bits y bytes en los que opera la lógica del procesador. Por lo general, es más fácil para los humanos leer y programar en mnemónicos que en binario, octal o hexadecimal, por lo que los humanos generalmente escriben código en lenguaje ensamblador y luego usan uno o más programas para convertirlo al formato de lenguaje de máquina que entiende el procesador.</description>
    </item>
    
    <item>
      <title>Registros</title>
      <link>https://www.wikiod.com/es/assembly/registros/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/registros/</guid>
      <description>¿Qué son los Registros?
El procesador puede operar con valores numéricos (números), pero primero deben almacenarse en algún lugar. Los datos se almacenan principalmente en la memoria, o dentro del código de operación de la instrucción (que generalmente también se almacena en la memoria), o en una memoria especial en el chip ubicada directamente en el procesador, que se llama registro.
Para trabajar con el valor en el registro, no necesita dirigirse a él por dirección, pero se usan &amp;ldquo;nombres&amp;rdquo; nemotécnicos especiales, como por ejemplo ax en x86, o A en Z80, o r0 en ARM.</description>
    </item>
    
    <item>
      <title>La pila</title>
      <link>https://www.wikiod.com/es/assembly/la-pila/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/la-pila/</guid>
      <description>La pila de computadoras es como una pila de libros. PUSH agrega uno a la parte superior y POP quita el superior. Como en la vida real, la pila no puede ser infinita, por lo que tiene un tamaño máximo. La pila se puede usar para ordenar algoritmos, para manejar una mayor cantidad de datos o para proteger valores de registros mientras se realiza otra operación.
pila Zilog Z80 # El registro sp se usa como puntero de pila, apuntando al último valor almacenado en la pila (&amp;ldquo;parte superior&amp;rdquo; de la pila).</description>
    </item>
    
    <item>
      <title>Ejemplos de Linux elf64 que no usan glibc</title>
      <link>https://www.wikiod.com/es/assembly/ejemplos-de-linux-elf64-que-no-usan-glibc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/ejemplos-de-linux-elf64-que-no-usan-glibc/</guid>
      <description>Interfaz de usuario # Me atrevería a decir que el 80 % del procesamiento que se lleva a cabo en los sistemas informáticos modernos no requiere la interacción del usuario, como el código del kernel para Linux, OSX y Windows. Para aquellos que lo hacen, hay dos fundamentos que son la interactividad a través del teclado (dispositivos señaladores) y la consola. Este ejemplo y otros de mi serie están orientados a la consola basada en texto (emulación VT100) y al teclado.</description>
    </item>
    
    <item>
      <title>Control de flujo</title>
      <link>https://www.wikiod.com/es/assembly/control-de-flujo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/control-de-flujo/</guid>
      <description>Cada pieza de software no trivial necesita estructuras de control de flujo para desviar el flujo del programa según las condiciones.
El ensamblaje, que es el lenguaje de programación de nivel más bajo, solo proporciona primitivos para las estructuras de control. Por lo general, las operaciones de la máquina afectan a las banderas de la CPU y las ramificaciones/saltos condicionales implementan el control de flujo. En ensamblaje, todas las estructuras de control de nivel superior deben construirse a partir de tales primitivas.</description>
    </item>
    
    <item>
      <title>Interrupciones</title>
      <link>https://www.wikiod.com/es/assembly/interrupciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/assembly/interrupciones/</guid>
      <description>Por qué necesitamos interrupciones
Imaginemos: Nuestro ordenador está conectado a un teclado. Queremos entrar en algo. Cuando pulsamos la tecla no pasa nada porque el ordenador está lidiando con cosas diferentes y no se da cuenta de que queremos algo de él. ¡Necesitamos interrupciones!
Las interrupciones son activadas por software (INT 80h) o hardware (pulsación de tecla), se comportan como una Llamada (saltan a una ubicación específica, ejecutan código y vuelven a saltar).</description>
    </item>
    
  </channel>
</rss>
