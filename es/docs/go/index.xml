<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ir al tutorial on </title>
    <link>https://www.wikiod.com/es/docs/go/</link>
    <description>Recent content in Ir al tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Go</title>
      <link>https://www.wikiod.com/es/go/primeros-pasos-con-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/primeros-pasos-con-go/</guid>
      <description>¡Hola Mundo! # Coloque el siguiente código en un nombre de archivo hello.go:
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;Hello, 世界&amp;quot;) } Patio de juegos
Cuando Go está instalado correctamente, este programa puede compilarse y ejecutarse así:
go run hello.go Producción: # Hello, 世界 Una vez que esté satisfecho con el código, puede compilarlo en un ejecutable ejecutando:
go build hello.go Esto creará un archivo ejecutable apropiado para su sistema operativo en el directorio actual, que luego puede ejecutar con el siguiente comando:</description>
    </item>
    
    <item>
      <title>Compilación cruzada</title>
      <link>https://www.wikiod.com/es/go/compilacion-cruzada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/compilacion-cruzada/</guid>
      <description>El compilador Go puede producir binarios para muchas plataformas, es decir, procesadores y sistemas. A diferencia de la mayoría de los otros compiladores, no hay un requisito específico para la compilación cruzada, es tan fácil de usar como la compilación regular.
Sintaxis # GOOS = linux GOARCH = amd64 ir a compilar Combinaciones de destino de sistema operativo y arquitectura compatibles (fuente)
$ GOOS $GOARCH androide brazo darwin 386 darwin amd64 darwin brazo darwin brazo64 libélula amd64 freebsd 386 freebsd amd64 freebsd brazo linux 386 linux amd64 linux brazo linux brazo64 linux ppc64 linux ppc64le linux mips64 linux mips64le netbsd 386 netbsd amd64 netbsd brazo openbsd 386 openbsd amd64 openbsd brazo plan9 386 plan9 amd64 solaris amd64 ventanas 386 ventanas amd64 Compilación cruzada simple con go build # Desde el directorio de su proyecto, ejecute el comando go build y especifique el sistema operativo y la arquitectura de destino con las variables de entorno GOOS y GOARCH:</description>
    </item>
    
    <item>
      <title>mapas</title>
      <link>https://www.wikiod.com/es/go/mapas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/mapas/</guid>
      <description>Los mapas son tipos de datos que se utilizan para almacenar pares clave-valor no ordenados, por lo que buscar el valor asociado a una clave dada es muy eficiente. Las llaves son únicas. La estructura de datos subyacente crece según sea necesario para dar cabida a nuevos elementos, por lo que el programador no necesita preocuparse por la gestión de la memoria. Son similares a lo que otros lenguajes llaman tablas hash, diccionarios o arreglos asociativos.</description>
    </item>
    
    <item>
      <title>Cliente HTTP</title>
      <link>https://www.wikiod.com/es/go/cliente-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/cliente-http/</guid>
      <description>Sintaxis # resp, err := http.Get(url) // Realiza una solicitud HTTP GET con el cliente HTTP predeterminado. Se devuelve un error no nulo si la solicitud falla. resp, err := http.Post(url, bodyType, body) // Realiza una solicitud HTTP POST con el cliente HTTP predeterminado. Se devuelve un error no nulo si la solicitud falla. resp, err := http.PostForm(url, valores) // Realiza una solicitud POST de formulario HTTP con el cliente HTTP predeterminado.</description>
    </item>
    
    <item>
      <title>concurrencia</title>
      <link>https://www.wikiod.com/es/go/concurrencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/concurrencia/</guid>
      <description>En Go, la concurrencia se logra mediante el uso de goroutines, y la comunicación entre goroutines generalmente se realiza con canales. Sin embargo, hay otros medios de sincronización disponibles, como mutexes y grupos de espera, y deben usarse siempre que sean más convenientes que los canales.
Sintaxis # go doWork() // ejecuta la función doWork como una gorutina ch := make(chan int) // declara un nuevo canal de tipo int ch &amp;lt;- 1 // envío en un canal valor = &amp;lt;-ch // recibir de un canal Goroutines en Go son similares a los hilos en otros idiomas en términos de uso.</description>
    </item>
    
    <item>
      <title>Servidor HTTP</title>
      <link>https://www.wikiod.com/es/go/servidor-http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/servidor-http/</guid>
      <description>http.ServeMux proporciona un multiplexor que llama a los controladores para solicitudes HTTP.
Las alternativas al multiplexor de biblioteca estándar incluyen:
Gorilla Mux
Hola Mundo # La forma típica de comenzar a escribir servidores web en golang es usar el módulo net/http de la biblioteca estándar.
También hay un tutorial para ello aquí.
El siguiente código también lo usa. Aquí está la implementación de servidor HTTP más simple posible. Responde &amp;quot;Hello World&amp;quot; a cualquier solicitud HTTP.</description>
    </item>
    
    <item>
      <title>estructuras</title>
      <link>https://www.wikiod.com/es/go/estructuras/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/estructuras/</guid>
      <description>Las estructuras son conjuntos de varias variables agrupadas. La estructura en sí es solo un paquete que contiene variables y las hace fácilmente accesibles.
A diferencia de C, las estructuras de Go pueden tener métodos adjuntos. También les permite implementar interfaces. Eso hace que las estructuras de Go sean similares a los objetos, pero (probablemente intencionalmente) les faltan algunas características importantes conocidas en los lenguajes orientados a objetos, como la herencia.</description>
    </item>
    
    <item>
      <title>Iota</title>
      <link>https://www.wikiod.com/es/go/iota/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/iota/</guid>
      <description>Iota proporciona una forma de declarar constantes numéricas a partir de un valor inicial que crece monótonamente. Iota se puede usar para declarar máscaras de bits que a menudo se usan en la programación de sistemas y redes y otras listas de constantes con valores relacionados.
El identificador iota se usa para asignar valores a listas de constantes. Cuando se usa iota en una lista, comienza con un valor de cero y se incrementa en uno por cada valor en la lista de constantes y se restablece en cada palabra clave const.</description>
    </item>
    
    <item>
      <title>venta</title>
      <link>https://www.wikiod.com/es/go/venta/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/venta/</guid>
      <description>La venta es un método para garantizar que todos los paquetes de terceros que usa en su proyecto Go sean consistentes para todos los que desarrollan para su aplicación.
Cuando su paquete Go importa otro paquete, el compilador normalmente verifica $GOPATH/src/ para la ruta del proyecto importado. Sin embargo, si su paquete contiene una carpeta llamada proveedor, el compilador verificará esa carpeta primero. Esto significa que puede importar paquetes de otras partes dentro de su propio repositorio de código, sin tener que modificar su código.</description>
    </item>
    
    <item>
      <title>Manejo de errores</title>
      <link>https://www.wikiod.com/es/go/manejo-de-errores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/go/manejo-de-errores/</guid>
      <description>En Go, las situaciones inesperadas se manejan usando errores, no excepciones. Este enfoque es más similar al de C, usando errno, que al de Java u otros lenguajes orientados a objetos, con sus bloques try/catch. Sin embargo, un error no es un número entero sino una interfaz.
Una función que puede fallar normalmente devuelve un error como su último valor de retorno. Si este error no es nil, algo salió mal y la persona que llama a la función debe tomar las medidas correspondientes.</description>
    </item>
    
  </channel>
</rss>
