<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de programación dinámica on </title>
    <link>https://www.wikiod.com/es/docs/dynamic-programming/</link>
    <description>Recent content in Tutorial de programación dinámica on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/dynamic-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con la programación dinámica</title>
      <link>https://www.wikiod.com/es/dynamic-programming/primeros-pasos-con-la-programacion-dinamica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/primeros-pasos-con-la-programacion-dinamica/</guid>
      <description>Introducción a la programación dinámica # Programación dinámica resuelve problemas combinando las soluciones de los subproblemas. Puede ser análogo al método divide y vencerás, donde el problema se divide en subproblemas separados, los subproblemas se resuelven recursivamente y luego se combinan para encontrar la solución del problema original. Por el contrario, la programación dinámica se aplica cuando los subproblemas se superponen, es decir, cuando los subproblemas comparten subproblemas. En este contexto, un algoritmo divide y vencerás hace más trabajo del necesario, resolviendo repetidamente los subsubproblemas comunes.</description>
    </item>
    
    <item>
      <title>Problema de cambio de moneda</title>
      <link>https://www.wikiod.com/es/dynamic-programming/problema-de-cambio-de-moneda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/problema-de-cambio-de-moneda/</guid>
      <description>Número de formas de obtener el total # Dadas monedas de diferentes denominaciones y un total, ¿de cuántas maneras podemos combinar estas monedas para obtener el total? Digamos que tenemos monedas = {1, 2, 3} y un total = 5, podemos obtener el total de 5 maneras:
1 1 1 1 1 1 1 1 2 1 1 3 1 2 2 2 3 El problema está estrechamente relacionado con el problema de la mochila.</description>
    </item>
    
    <item>
      <title>Resolviendo Problemas de Gráficas Usando Programación Dinámica</title>
      <link>https://www.wikiod.com/es/dynamic-programming/resolviendo-problemas-de-graficas-usando-programacion-dinamica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/resolviendo-problemas-de-graficas-usando-programacion-dinamica/</guid>
      <description>Algoritmo de Floyd-Warshall # Cobertura de vértice mínima # Minimum Vertex Cover es un problema gráfico clásico. Digamos que en una ciudad tenemos algunas carreteras que conectan algunos puntos. Representamos las carreteras mediante aristas y los puntos mediante nodos. Tomemos dos gráficos de ejemplo:
Queremos poner centinelas en algunos puntos. Un vigilante puede vigilar todos los caminos conectados al punto. El problema es, ¿cuál es el número mínimo de vigilantes necesarios para cubrir todos los caminos?</description>
    </item>
    
    <item>
      <title>Selección de actividad ponderada</title>
      <link>https://www.wikiod.com/es/dynamic-programming/seleccion-de-actividad-ponderada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/seleccion-de-actividad-ponderada/</guid>
      <description>Algoritmo de programación de trabajos ponderados # El algoritmo de programación de trabajo ponderado también se puede denominar algoritmo de selección de actividad ponderada.
El problema es que, dados ciertos trabajos con su hora de inicio y finalización, y una ganancia que obtienes cuando terminas el trabajo, ¿cuál es la ganancia máxima que puedes obtener dado que no se pueden ejecutar dos trabajos en paralelo?
Este se parece a la selección de actividades usando el algoritmo codicioso, pero hay un giro adicional.</description>
    </item>
    
    <item>
      <title>Problema de mochila</title>
      <link>https://www.wikiod.com/es/dynamic-programming/problema-de-mochila/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/problema-de-mochila/</guid>
      <description>El problema de la mochila o mochila es un problema de optimización combinatoria. Dado un conjunto de artículos, cada uno con un peso y un valor, determine el número de cada artículo que se incluirá en una colección para que el peso total sea menor o igual a un límite dado y el valor total sea lo más grande posible. Deriva su nombre del problema que enfrenta alguien que está limitado por una mochila de tamaño fijo y debe llenarla con los artículos más valiosos.</description>
    </item>
    
    <item>
      <title>Algoritmos relacionados con subsecuencias</title>
      <link>https://www.wikiod.com/es/dynamic-programming/algoritmos-relacionados-con-subsecuencias/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/algoritmos-relacionados-con-subsecuencias/</guid>
      <description>Subsecuencia creciente más larga # La tarea es encontrar la longitud de la subsecuencia más larga en una matriz dada de enteros de modo que todos los elementos de la subsecuencia se clasifiquen en orden ascendente. Por ejemplo, la longitud de la subsecuencia creciente más larga (LIS) para {15, 27, 14, 38, 26, 55, 46, 65, 85} es 6 y la subsecuencia creciente más larga es * *{15, 27, 38, 55, 65, 85}**.</description>
    </item>
    
    <item>
      <title>Deformación dinámica del tiempo</title>
      <link>https://www.wikiod.com/es/dynamic-programming/deformacion-dinamica-del-tiempo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/deformacion-dinamica-del-tiempo/</guid>
      <description>Introducción a la deformación temporal dinámica # Dynamic Time Warping(DTW) es un algoritmo para medir la similitud entre dos secuencias temporales que pueden variar en velocidad. Por ejemplo, las similitudes al caminar podrían detectarse usando DTW, incluso si una persona caminaba más rápido que la otra, o si hubo aceleraciones y desaceleraciones durante el curso de una observación. Se puede usar para hacer coincidir un comando de voz de muestra con otro comando, incluso si la persona habla más rápido o más lento que la voz de muestra pregrabada.</description>
    </item>
    
    <item>
      <title>Multiplicación de cadenas de matrices</title>
      <link>https://www.wikiod.com/es/dynamic-programming/multiplicacion-de-cadenas-de-matrices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/multiplicacion-de-cadenas-de-matrices/</guid>
      <description>Solución recursiva # Multiplicación de cadenas de matrices es un problema de optimización que se puede resolver mediante programación dinámica. Dada una secuencia de matrices, el objetivo es encontrar la forma más eficiente de multiplicar estas matrices. El problema no es realmente realizar las multiplicaciones, sino simplemente decidir la secuencia de las multiplicaciones de matrices involucradas.
Digamos que tenemos dos matrices A1 y A2 de dimensión m * n y p * q .</description>
    </item>
    
    <item>
      <title>Corte de varillas</title>
      <link>https://www.wikiod.com/es/dynamic-programming/corte-de-varillas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/dynamic-programming/corte-de-varillas/</guid>
      <description>Cortar la varilla para obtener el máximo beneficio # Dada una varilla de longitud n pulgadas y una matriz de precios de longitud m que contiene los precios de todas las piezas de tamaño menor que n. Tenemos que encontrar el valor máximo que se puede obtener cortando la varilla y vendiendo las piezas. Por ejemplo, si la longitud de la varilla es 8 y los valores de las diferentes piezas se dan a continuación, entonces el valor máximo que se puede obtener es 22.</description>
    </item>
    
  </channel>
</rss>
