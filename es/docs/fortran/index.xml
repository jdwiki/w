<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Fortran on </title>
    <link>https://www.wikiod.com/es/docs/fortran/</link>
    <description>Recent content in Tutorial de Fortran on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/fortran/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Fortran</title>
      <link>https://www.wikiod.com/es/fortran/primeros-pasos-con-fortran/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/primeros-pasos-con-fortran/</guid>
      <description>Hola Mundo # Cualquier programa Fortran tiene que incluir end como última declaración. Por lo tanto, el programa Fortran más simple se ve así:
end Estos son algunos ejemplos de programas &amp;ldquo;hola, mundo&amp;rdquo;:
print *, &amp;quot;Hello, world&amp;quot; end Con la sentencia write:
write(*,*) &amp;quot;Hello, world&amp;quot; end Para mayor claridad, ahora es común usar la instrucción &amp;lsquo;programa&amp;rsquo; para iniciar un programa y darle un nombre. La instrucción end puede hacer referencia a este nombre para que sea obvio a qué se refiere, y permitir que el compilador verifique que el código sea correcto.</description>
    </item>
    
    <item>
      <title>arreglos</title>
      <link>https://www.wikiod.com/es/fortran/arreglos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/arreglos/</guid>
      <description>Constructores de matrices # Se puede crear un valor de matriz de rango 1 usando un constructor de matriz, con la sintaxis
(/ ... /) [ ... ] La forma [...] se introdujo en Fortran 2003 y generalmente se considera más clara de leer, especialmente en expresiones complejas. Este formulario se utiliza exclusivamente en este ejemplo.
Los valores que aparecen en un constructor de matriz pueden ser valores escalares, valores de matriz o bucles implícitos.</description>
    </item>
    
    <item>
      <title>Tipos de datos</title>
      <link>https://www.wikiod.com/es/fortran/tipos-de-datos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/tipos-de-datos/</guid>
      <description>Precisión de los números de punto flotante # Los números de punto flotante de tipo real no pueden tener ningún valor real. Pueden representar números reales hasta cierta cantidad de dígitos decimales.
FORTRAN 77 garantiza dos tipos de coma flotante y los estándares más recientes garantizan al menos dos tipos reales. Las variables reales pueden declararse como
real x double precision y x aquí es un tipo real por defecto y y es un tipo real con mayor precisión decimal que x.</description>
    </item>
    
    <item>
      <title>Programación orientada a objetos</title>
      <link>https://www.wikiod.com/es/fortran/programacion-orientada-a-objetos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/programacion-orientada-a-objetos/</guid>
      <description>Definición de tipo derivado # Fortran 2003 introdujo soporte para programación orientada a objetos. Esta característica permite aprovechar las técnicas modernas de programación. Los tipos derivados se definen con la siguiente forma:
TYPE [[, attr-list] :: ] name [(name-list)] [def-stmts] [PRIVATE statement or SEQUENCE statement]. . . [component-definition]. . . [procedure-part] END TYPE [name] dónde,
attr-list - una lista de especificadores de atributos nombre - el nombre del tipo de datos derivado name-list - una lista de nombres de parámetros de tipo separados por comas def-stmts - una o más declaraciones INTEGER de los parámetros de tipo nombrados en la lista de nombres definición-de-componente: una o más sentencias de declaración de tipo o sentencias de puntero de procedimiento que definen el componente del tipo derivado parte del procedimiento: una declaración CONTAINS, opcionalmente seguida de una declaración PRIVATE y una o más declaraciones vinculantes del procedimiento Ejemplo:</description>
    </item>
    
    <item>
      <title>Alternativas modernas a las características históricas.</title>
      <link>https://www.wikiod.com/es/fortran/alternativas-modernas-a-las-caracteristicas-historicas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/alternativas-modernas-a-las-caracteristicas-historicas/</guid>
      <description>Aritmética declaración if # La declaración aritmética if permite usar tres ramas dependiendo del resultado de una expresión aritmética
if (arith_expr) label1, label2, label3 Esta instrucción if transfiere el flujo de control a una de las etiquetas en un código. Si el resultado de arith_expr es negativo, se utiliza label1, si el resultado es cero, se utiliza label2, y si el resultado es positivo, se aplica la última label3. La aritmética si requiere las tres etiquetas pero permite la reutilización de etiquetas, por lo tanto, esta declaración se puede simplificar a dos ramas si.</description>
    </item>
    
    <item>
      <title>Unidades de programa y disposición de archivos</title>
      <link>https://www.wikiod.com/es/fortran/unidades-de-programa-y-disposicion-de-archivos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/unidades-de-programa-y-disposicion-de-archivos/</guid>
      <description>Subprogramas internos # Una unidad de programa que no es un subprograma interno puede contener otras unidades de programa, denominadas subprogramas internos.
program prog implicit none contains function f() end function f subroutine g() end subroutine g end program Dicho subprograma interno tiene una serie de características:
existe una asociación de host entre las entidades del subprograma y el programa externo Las reglas de escritura implícitas se heredan (implicit none está en vigor en f arriba) los subprogramas internos tienen una interfaz explícita disponible en el host Los subprogramas de módulo y los subprogramas externos pueden tener subprogramas internos, como</description>
    </item>
    
    <item>
      <title>Procedimientos - Funciones y Subrutinas</title>
      <link>https://www.wikiod.com/es/fortran/procedimientos---funciones-y-subrutinas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/procedimientos---funciones-y-subrutinas/</guid>
      <description>Funciones y subrutinas, junto con módulos, son las herramientas para dividir un programa en unidades. Esto hace que el programa sea más legible y manejable. Cada una de estas unidades puede pensarse como parte del código que, idealmente, podría compilarse y probarse de forma aislada. Los programas principales pueden llamar (o invocar) dichos subprogramas (funciones o subrutinas) para realizar una tarea.
Las funciones y subrutinas son diferentes en el siguiente sentido:</description>
    </item>
    
    <item>
      <title>Uso de Módulos</title>
      <link>https://www.wikiod.com/es/fortran/uso-de-modulos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/uso-de-modulos/</guid>
      <description>Sintaxis del módulo # El módulo es una colección de declaraciones de tipos, declaraciones de datos y procedimientos. La sintaxis básica es:
module module_name use other_module_being_used ! The use of implicit none here will set it for the scope of the module. ! Therefore, it is not required (although considered good practice) to repeat ! it in the contained subprograms. implicit none ! Parameters declaration real, parameter, public :: pi = 3.</description>
    </item>
    
    <item>
      <title>Interfaces explícitas e implícitas</title>
      <link>https://www.wikiod.com/es/fortran/interfaces-explicitas-e-implicitas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/interfaces-explicitas-e-implicitas/</guid>
      <description>Subprogramas externos e interfaces implícitas # Se dice que un subprograma es externo cuando no está contenido en el programa principal, ni en un módulo ni en otro subprograma. En particular, puede definirse mediante un lenguaje de programación distinto de Fortran.
Cuando se invoca un subprograma externo, el compilador no puede acceder a su código, por lo que toda la información permitida al compilador está implícitamente contenida en la instrucción de llamada del programa de llamada y en las propiedades de tipo y de los argumentos reales, no en los argumentos ficticios ( cuya declaración es desconocida para el compilador).</description>
    </item>
    
    <item>
      <title>Control de ejecución</title>
      <link>https://www.wikiod.com/es/fortran/control-de-ejecucion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/fortran/control-de-ejecucion/</guid>
      <description>Si construye # La construcción if (llamada sentencia IF de bloque en FORTRAN 77) es común en muchos lenguajes de programación. Ejecuta condicionalmente un bloque de código cuando una expresión lógica se evalúa como verdadera.
[name:] IF (expr) THEN block [ELSE IF (expr) THEN [name] block] [ELSE [name] block] END IF [name] dónde,
nombre - el nombre de la construcción if (opcional) expr - una expresión lógica escalar entre paréntesis bloque: una secuencia de cero o más declaraciones o construcciones El nombre de una construcción al comienzo de una declaración si, entonces debe tener el mismo valor que el nombre de la construcción en la declaración final si, y debe ser único para la unidad de alcance actual.</description>
    </item>
    
  </channel>
</rss>
