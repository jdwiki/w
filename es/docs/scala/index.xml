<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial del lenguaje Scala on </title>
    <link>https://www.wikiod.com/es/docs/scala/</link>
    <description>Recent content in Tutorial del lenguaje Scala on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Scala Language</title>
      <link>https://www.wikiod.com/es/scala/primeros-pasos-con-scala-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/primeros-pasos-con-scala-language/</guid>
      <description>Hello World al extender la aplicación # object HelloWorld extends App { println(&amp;quot;Hello, world!&amp;quot;) } Demostración en vivo
Al extender App trait, puede evitar definir un método main explícito . Todo el cuerpo del objeto HelloWorld se trata como &amp;ldquo;el método principal&amp;rdquo;.
Inicialización retrasada # Según la documentación oficial, App hace uso de una función llamada Inicialización retrasada. Esto significa que los campos del objeto se inicializan después de llamar al método principal.</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/scala/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/la-coincidencia-de-patrones/</guid>
      <description>Sintaxis # función parcial de coincidencia del selector coincidencia de selector {lista de alternativas de casos) // Esta es la forma más común de lo anterior Parámetros # Parámetro Detalles seleccionador La expresión cuyo valor se compara con el patrón. alternativas una lista de alternativas delimitadas por &amp;lsquo;casos&amp;rsquo;. Coincidencia de patrón simple # Este ejemplo muestra cómo hacer coincidir una entrada con varios valores:
def f(x: Int): String = x match { case 1 =&amp;gt; &amp;quot;One&amp;quot; case 2 =&amp;gt; &amp;quot;Two&amp;quot; case _ =&amp;gt; &amp;quot;Unknown!</description>
    </item>
    
    <item>
      <title>implícitos</title>
      <link>https://www.wikiod.com/es/scala/implicitos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/implicitos/</guid>
      <description>Sintaxis # valor implícito x: T = ??? Las clases implícitas permiten agregar métodos personalizados a los tipos existentes, sin tener que modificar su código, enriqueciendo así los tipos sin necesidad de controlar el código.
El uso de tipos implícitos para enriquecer una clase existente a menudo se denomina patrón &amp;ldquo;enriquecer mi biblioteca&amp;rdquo;.
Restricciones en clases implícitas
Las clases implícitas solo pueden existir dentro de otra clase, objeto o rasgo. Las clases implícitas solo pueden tener un parámetro de constructor primario no implícito.</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/es/scala/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/json/</guid>
      <description>##JSON con Circe Circe proporciona códecs derivados en tiempo de compilación para en/decode json en clases de casos. Un ejemplo simple se ve así:
import io.circe._ import io.circe.generic.auto._ import io.circe.parser._ import io.circe.syntax._ case class User(id: Long, name: String) val user = User(1, &amp;quot;John Doe&amp;quot;) // {&amp;quot;id&amp;quot;:1,&amp;quot;name&amp;quot;:&amp;quot;John Doe&amp;quot;} val json = user.asJson.noSpaces // Right(User(1L, &amp;quot;John Doe&amp;quot;)) val res: Either[Error, User] = decode[User](json) JSON con spray-json # spray-json proporciona una manera fácil de trabajar con JSON.</description>
    </item>
    
    <item>
      <title>Extractores</title>
      <link>https://www.wikiod.com/es/scala/extractores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/extractores/</guid>
      <description>Sintaxis # val extractor(extractedValue1, _ /* se ignora el segundo valor extraído */) = valueToBeExtracted valueToBeExtracted match { case extractor(extractedValue1, _) =&amp;gt; ???} val (tupla1, tupla2, tupla3) = tuplaCon3Elementos object Foo { def no aplicar(foo: Foo): Option[String] = Some(foo.x); } Extractores de clases de casos # Una clase de caso es una clase con una gran cantidad de código repetitivo estándar incluido automáticamente. Un beneficio de esto es que Scala facilita el uso de extractores con clases de casos.</description>
    </item>
    
    <item>
      <title>Colecciones</title>
      <link>https://www.wikiod.com/es/scala/colecciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/colecciones/</guid>
      <description>Lista y hoja de trucos de vectores # Ahora es una mejor práctica usar Vector en lugar de Lista porque las implementaciones tienen un mejor rendimiento [Las características de rendimiento se pueden encontrar aquí][perforabletransversal]. Vector se puede utilizar siempre que se utilice Lista.
Creación de lista
List[Int]() // Declares an empty list of type Int List.empty[Int] // Uses `empty` method to declare empty list of type Int Nil // A list of type Nothing that explicitly has nothing in it List(1, 2, 3) // Declare a list with some elements 1 :: 2 :: 3 :: Nil // Chaining element prepending to an empty list, in a LISP-style Tomar elemento</description>
    </item>
    
    <item>
      <title>mónadas</title>
      <link>https://www.wikiod.com/es/scala/monadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/monadas/</guid>
      <description>Definición de mónada # Informalmente, una mónada es un contenedor de elementos, anotado como F[_], empaquetado con 2 funciones: flatMap (para transformar este contenedor) y unit (para crear este contenedor).
Los ejemplos de bibliotecas comunes incluyen List[T], Set[T] y Option[T].
Definicion formal
Monad M es un tipo paramétrico M[T] con dos operaciones flatMap y unit, tales como:
trait M[T] { def flatMap[U](f: T =&amp;gt; M[U]): M[U] } def unit[T](x: T): M[T] Estas funciones deben satisfacer tres leyes:</description>
    </item>
    
    <item>
      <title>Clases de casos</title>
      <link>https://www.wikiod.com/es/scala/clases-de-casos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/clases-de-casos/</guid>
      <description>Sintaxis # case class Foo() // Las clases de case sin parámetros deben tener una lista vacía case class Foo(a1: A1, &amp;hellip;, aN: AN) // Crear una case class con campos a1 &amp;hellip; aN case object Bar // Crear una clase de caso singleton Artefactos de código generados # El modificador case hace que el compilador de Scala genere automáticamente un código repetitivo común para la clase. Implementar este código manualmente es tedioso y fuente de errores.</description>
    </item>
    
    <item>
      <title>enumeraciones</title>
      <link>https://www.wikiod.com/es/scala/enumeraciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/enumeraciones/</guid>
      <description>Se prefiere el enfoque con &amp;ldquo;rasgo sellado&amp;rdquo; y &amp;ldquo;objetos de caso&amp;rdquo; porque la enumeración de Scala tiene algunos problemas:
Las enumeraciones tienen el mismo tipo después del borrado.
El compilador no se queja de que &amp;ldquo;La coincidencia no es exhaustiva&amp;rdquo;, si se pierde el caso, fallará en el tiempo de ejecución scala.MatchError:
def isWeekendWithBug(day: WeekDays.Value): Boolean = day match { case WeekDays.Sun | WeekDays.Sat =&amp;gt; true }
isWeekendWithBug(WeekDays.Fri) scala.MatchError: Fri (of class scala.</description>
    </item>
    
    <item>
      <title>Zurra</title>
      <link>https://www.wikiod.com/es/scala/zurra/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/scala/zurra/</guid>
      <description>Sintaxis # aFunction(10)_ //Usando &amp;lsquo;_&amp;rsquo; Le dice al compilador que todos los parámetros en el resto de los grupos de parámetros serán procesados. nArityFunction.curred //Convierte una función n-arity en una versión curry equivalente anotherFunction(x)(_: String)(z) // Calcular un parámetro arbitrario. Necesita que su tipo se indique explícitamente. Cuándo usar Curry # Currying es la técnica de traducir la evaluación de una función que toma múltiples argumentos para evaluar una secuencia de funciones, cada una con un solo argumento.</description>
    </item>
    
  </channel>
</rss>
