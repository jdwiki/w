<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial del lenguaje Prolog on </title>
    <link>https://www.wikiod.com/es/docs/prolog/</link>
    <description>Recent content in Tutorial del lenguaje Prolog on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/prolog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Prolog Language</title>
      <link>https://www.wikiod.com/es/prolog/primeros-pasos-con-prolog-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/primeros-pasos-con-prolog-language/</guid>
      <description>Programación de bases de datos # Prolog clasifica todo en:
Átomos: cualquier secuencia de caracteres que no comience con un alfabeto en mayúsculas. Por ejemplo: a, b, bien Números - No hay una sintaxis especial para números, no se requiere declaración. Por ejemplo, 1, 22, 35.8 Variables - Una cadena que comienza con un carácter en mayúscula o guión bajo (_). Por ejemplo, X, Y, Abc, AA Términos complejos - Están formados por un funtor y una secuencia de argumentos.</description>
    </item>
    
    <item>
      <title>Estructuras de Control</title>
      <link>https://www.wikiod.com/es/prolog/estructuras-de-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/estructuras-de-control/</guid>
      <description>Disyunción (OR lógico), implícito vs. explícito # Prolog prueba cláusulas alternativas para un predicado en el orden de aparición:
likes(alice, music). likes(bob, hiking). // Either alice likes music, or bob likes hiking will succeed. El operador de disyunción (OR) ; se puede utilizar para expresar esto en una regla:
likes(P,Q) :- ( P = alice , Q = music ) ; ( P = bob , Q = hiking ). Los paréntesis son importantes aquí para mayor claridad.</description>
    </item>
    
    <item>
      <title>Estructuras de datos</title>
      <link>https://www.wikiod.com/es/prolog/estructuras-de-datos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/estructuras-de-datos/</guid>
      <description>Listas de asociaciones # En todos los sistemas Prolog serios, listas de asociación están disponibles para permitir un acceso más rápido que lineal a una colección de elementos. Estas listas de asociaciones generalmente se basan en árboles equilibrados como árboles AVL . Existe una biblioteca de dominio público llamada library(assoc) que se envía con muchos sistemas Prolog y proporciona operaciones O(log(N)) para insertar, obtener y cambiar elementos en una colección.</description>
    </item>
    
    <item>
      <title>monotonicidad</title>
      <link>https://www.wikiod.com/es/prolog/monotonicidad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/monotonicidad/</guid>
      <description>Alternativas monótonas para construcciones no monótonas # Estos son ejemplos de cómo usar predicados monotónicos en lugar de construcciones no monotónicas impuras en sus programas:
dif/2 está destinado a usarse en lugar de construcciones no monótonas como (\=)/2 Las restricciones aritméticas (CLP(FD), CLP(Q) y otras) están destinadas a usarse en lugar de predicados aritméticos modales !/0 casi siempre conduce a programas no monótonos y debe evitar por completo. Se pueden generar errores de creación de instancias en situaciones en las que no puede tomar una decisión acertada en este momento.</description>
    </item>
    
    <item>
      <title>árboles de derivación</title>
      <link>https://www.wikiod.com/es/prolog/arboles-de-derivacion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/arboles-de-derivacion/</guid>
      <description>Árbol de prueba # El árbol de prueba (también árbol de búsqueda o árbol de derivación) es un árbol que muestra la ejecución de un programa Prolog. Este árbol ayuda a visualizar el proceso de retroceso cronológico presente en Prolog. La raíz del árbol representa la consulta inicial y las ramas se crean cuando se producen puntos de elección. Cada nodo en el árbol representa así una meta. Las ramas solo se convierten en hojas cuando se demostró verdadero/falso para el (los) objetivo(s) requerido(s) y la búsqueda en Prolog se realiza de izquierda a derecha en profundidad.</description>
    </item>
    
    <item>
      <title>Razonamiento sobre datos</title>
      <link>https://www.wikiod.com/es/prolog/razonamiento-sobre-datos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/razonamiento-sobre-datos/</guid>
      <description>Se dio vida a una nueva sección llamada Estructuras de datos donde se proporcionan explicaciones de ciertas estructuras + algunos ejemplos simples de creación. Para mantener su contenido conciso y ordenado, no debe contener ninguna documentación sobre la manipulación de datos.
Por lo tanto, se cambió el nombre de esta sección a &amp;ldquo;Razonamiento sobre datos&amp;rdquo; con el propósito de generalizar el razonamiento sobre datos en Prolog. Esto podría incluir temas que van desde &amp;lsquo;inferencia de arriba hacia abajo&amp;rsquo; hasta &amp;lsquo;recorrido de listas&amp;rsquo;, así como muchos otros.</description>
    </item>
    
    <item>
      <title>Programación Lógica de Restricciones</title>
      <link>https://www.wikiod.com/es/prolog/programacion-logica-de-restricciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/programacion-logica-de-restricciones/</guid>
      <description>CLP(FD) # Restricciones CLP(FD) (Dominios finitos) implementan aritmética sobre enteros. Están disponibles en todas las implementaciones serias de Prolog.
Hay dos casos de uso principales de restricciones CLP(FD):
Aritmética entera declarativa Resolver problemas combinatorios como la planificación, programación y asignación de tareas. Ejemplos:
?- X #= 1+2. X = 3. ?- 3 #= Y+2. Y = 1. Tenga en cuenta que si se usara is/2 en la segunda consulta, se produciría un error de creación de instancias:</description>
    </item>
    
    <item>
      <title>Programación de orden superior</title>
      <link>https://www.wikiod.com/es/prolog/programacion-de-orden-superior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/programacion-de-orden-superior/</guid>
      <description>llamada/N predicados # La familia de predicados call/N puede llamar a objetivos arbitrarios de Prolog en tiempo de ejecución:
?- G=true, call(G). true. ?- G=(true,false), call(G). false. lista de mapas/[2,3] # maplist/2 y maplist/3 son predicados de orden superior, que permiten elevar la definición de un predicado sobre un solo elemento a listas de tales elementos. Estos predicados se pueden definir usando call/2 y call/3 como bloques de construcción y se envían con muchos sistemas Prolog.</description>
    </item>
    
    <item>
      <title>Pureza lógica</title>
      <link>https://www.wikiod.com/es/prolog/pureza-logica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/pureza-logica/</guid>
      <description>diferencia/2 # El predicado dif/2 es un predicado puro: se puede usar en todas las direcciones y con todos los patrones de creación de instancias, siempre lo que significa que sus dos argumentos son diferentes.
Unificación # Unificación es una relación pura. No produce efectos secundarios y se puede utilizar en todas las direcciones, con uno o ambos argumentos instanciados total o parcialmente.
En Prolog, la unificación puede ocurrir
explícitamente, usando predicados incorporados como (=)/2 o unify_with_occurs_check/2 implícitamente, cuando se utiliza la unificación para seleccionar una cláusula adecuada.</description>
    </item>
    
    <item>
      <title>Uso de Prolog moderno</title>
      <link>https://www.wikiod.com/es/prolog/uso-de-prolog-moderno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/prolog/uso-de-prolog-moderno/</guid>
      <description>CLP(FD) para aritmética entera # Tradicionalmente, Prolog realizaba operaciones aritméticas usando los operadores is y =:=. Sin embargo, varios Prologs actuales ofrecen CLP(FD) (Programación Lógica de Restricciones sobre Dominios Finitos) como una alternativa más limpia para la aritmética de enteros. CLP(FD) se basa en almacenar las restricciones que se aplican a un valor entero y combinarlas en la memoria.
CLP(FD) es una extensión en la mayoría de los Prologs que la admiten, por lo que debe cargarse explícitamente.</description>
    </item>
    
  </channel>
</rss>
