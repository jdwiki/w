<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/haxe/</link>
    <description>Recent content in Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/haxe/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con haxe</title>
      <link>https://www.wikiod.com/es/haxe/primeros-pasos-con-haxe/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/primeros-pasos-con-haxe/</guid>
      <description>Hola Mundo # Requisitos # Se debe instalar una versión del kit de herramientas Haxe Haxe debe estar presente en la ruta de su sistema La línea de comandos debe ser accesible Código # Navegue a un directorio de proyecto deseado y cree un archivo fuente Test.hx con el siguiente contenido:
class Test { static function main() { trace(&amp;quot;Hello world&amp;quot;); } } Los archivos fuente de Haxe se denominan módulos. Un módulo debería definir un tipo (abstract, class, enum, interface o typedef) con el mismo identificador que el nombre del módulo, en este caso, la clase Test.</description>
    </item>
    
    <item>
      <title>Enumeraciones</title>
      <link>https://www.wikiod.com/es/haxe/enumeraciones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/enumeraciones/</guid>
      <description>Sintaxis # enumeración identificador { constructores } Capturando valores de enumeración # Los valores pasados ​​como argumentos del constructor de enumeración se pueden capturar en variables mediante el uso de coincidencia de patrones.
Supongamos la siguiente enumeración:
enum Color { RGB(r : Int, g : Int, b : Int); HSV(h : Int, s : Float, v : Float); } El valor del canal rojo se puede capturar de la siguiente manera:</description>
    </item>
    
    <item>
      <title>Bucles</title>
      <link>https://www.wikiod.com/es/haxe/bucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/bucles/</guid>
      <description>Sintaxis # for (identificador de variable en colección iterativa) { expresión } while (condición) { expresión } do { expresión } while (condición); descanso; Seguir; Para # For-loops iterar sobre una colección iterativa. Una colección iterativa es cualquier clase que se unifica estructuralmente con los tipos Iterator&amp;lt;T&amp;gt; o Iterable&amp;lt;T&amp;gt; de la biblioteca estándar de Haxe.
Un ciclo for que registra números en el rango de 0 a 10 (exclusivo) se puede escribir de la siguiente manera:</description>
    </item>
    
    <item>
      <title>La coincidencia de patrones</title>
      <link>https://www.wikiod.com/es/haxe/la-coincidencia-de-patrones/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/la-coincidencia-de-patrones/</guid>
      <description>La coincidencia de patrones es el proceso de ramificación según los patrones proporcionados. Todas las coincidencias de patrones se realizan dentro de una expresión switch, y las expresiones case individuales representan los patrones.
Las reglas fundamentales de la coincidencia de patrones son:
los patrones siempre se combinarán de arriba a abajo; el patrón superior que coincide con el valor de entrada tiene su expresión ejecutada; un patrón _ coincide con cualquier cosa, por lo que case _: es igual a default:.</description>
    </item>
    
    <item>
      <title>resúmenes</title>
      <link>https://www.wikiod.com/es/haxe/resumenes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/resumenes/</guid>
      <description>Sintaxis # resumen identificador(tipo subyacente) { &amp;hellip; } identificador abstracto (tipo subyacente) de tipoA de tipoB &amp;hellip; a tipoA a tipoB { &amp;hellip; } Un tipo abstracto es un tipo en tiempo de compilación que se resuelve en el tipo subyacente en tiempo de ejecución. Esto significa que el tipo abstracto no existe en el código fuente generado por el compilador Haxe. En su lugar se colocan el tipo subyacente o los tipos definidos para la conversión implícita.</description>
    </item>
    
    <item>
      <title>Derivación</title>
      <link>https://www.wikiod.com/es/haxe/derivacion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haxe/derivacion/</guid>
      <description>Sintaxis # si (condición) { &amp;hellip; } si (condición) { &amp;hellip; } si no { &amp;hellip; } si (condición) { &amp;hellip; } si no (condición) { &amp;hellip; } si no { &amp;hellip; } // Las llaves son opcionales para declaraciones de una sola línea if (condition) &amp;hellip; else if (condition) &amp;hellip; else &amp;hellip; cambiar (expresión) { caso patrón: &amp;hellip; predeterminado: &amp;hellip; } condición ? expresión si es verdadero : expresión si es falso; Todas las expresiones de bifurcación permiten devolver expresiones evaluadas.</description>
    </item>
    
  </channel>
</rss>
