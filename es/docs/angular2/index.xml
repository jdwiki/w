<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de Angular 2 on </title>
    <link>https://www.wikiod.com/es/docs/angular2/</link>
    <description>Recent content in Tutorial de Angular 2 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/angular2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Angular 2</title>
      <link>https://www.wikiod.com/es/angular2/primeros-pasos-con-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/primeros-pasos-con-angular-2/</guid>
      <description>Instalar angular2 con angular-cli # Este ejemplo es una configuración rápida de Angular 2 y cómo generar un proyecto de ejemplo rápido.
Requisitos previos: # Node.js v4 o superior. npm v3 o superior o hilo. Abra una terminal y ejecute los comandos uno por uno:
npm install -g @angular/cli o
yarn global add @angular/cli dependiendo de su elección de administrador de paquetes.
El comando anterior instala @angular/cli globalmente, agregando el ejecutable ng a PATH.</description>
    </item>
    
    <item>
      <title>Actualización de formularios de Angular 2</title>
      <link>https://www.wikiod.com/es/angular2/actualizacion-de-formularios-de-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/actualizacion-de-formularios-de-angular-2/</guid>
      <description>Angular 2 permite acceder a la instancia de ngForm creando una variable de plantilla local. Angular 2 expone instancias de directivas como ngForm al especificar la propiedad exportAs de los metadatos de la directiva. Ahora, la ventaja aquí es que, sin mucha codificación, puede acceder a la instancia de ngForm y usarla para acceder a los valores enviados o para verificar si todos los campos son válidos usando propiedades (válido, enviado, valor, etc.</description>
    </item>
    
    <item>
      <title>Tubería</title>
      <link>https://www.wikiod.com/es/angular2/tuberia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/tuberia/</guid>
      <description>El carácter de tubería | se usa para aplicar tuberías en Angular 2. Las tuberías son muy similares a los filtros en AngularJS en que ambos ayudan a transformar los datos en un formato específico.
Parámetros # Función/Parámetro Explicación @Pipe({nombre, puro}) metadatos para tubería, deben preceder inmediatamente a la clase de tubería nombre: cadena lo que usarás dentro de la plantilla puro: booleano por defecto es verdadero, márquelo como falso para que su tubería sea reevaluada con más frecuencia transformar( valor, argumentos[]?</description>
    </item>
    
    <item>
      <title>Agregue componentes dinámicamente usando ViewContainerRef.createComponent</title>
      <link>https://www.wikiod.com/es/angular2/agregue-componentes-dinamicamente-usando-viewcontainerrefcreatecomponent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/agregue-componentes-dinamicamente-usando-viewcontainerrefcreatecomponent/</guid>
      <description>Un componente contenedor que agrega componentes dinámicos declarativamente # Un componente personalizado que toma el tipo de un componente como entrada y crea una instancia de ese tipo de componente dentro de sí mismo. Cuando se actualiza la entrada, el componente dinámico agregado anteriormente se elimina y se agrega uno nuevo en su lugar.
@Component({ selector: &#39;dcl-wrapper&#39;, template: `&amp;lt;div #target&amp;gt;&amp;lt;/div&amp;gt;` }) export class DclWrapper { @ViewChild(&#39;target&#39;, { read: ViewContainerRef }) target; @Input() type; cmpRef: ComponentRef; private isViewInitialized: boolean = false; constructor(private resolver: ComponentResolver) {} updateComponent() { if (!</description>
    </item>
    
    <item>
      <title>Burlándose de @ngrxTienda</title>
      <link>https://www.wikiod.com/es/angular2/burlandose-de-ngrxtienda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/burlandose-de-ngrxtienda/</guid>
      <description>@ngrx/Store se usa cada vez más en proyectos de Angular 2. Como tal, se requiere que la Tienda se inyecte en el constructor de cualquier Componente o Servicio que desee utilizarla. Sin embargo, la prueba unitaria de Store no es tan fácil como probar un servicio simple. Al igual que con muchos problemas, hay una gran variedad de formas de implementar soluciones. Sin embargo, la receta básica es escribir una clase simulada para la interfaz de Observer y escribir una clase simulada para Store.</description>
    </item>
    
    <item>
      <title>Sujetos y observables angulares RXJS con solicitudes de API</title>
      <link>https://www.wikiod.com/es/angular2/sujetos-y-observables-angulares-rxjs-con-solicitudes-de-api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/sujetos-y-observables-angulares-rxjs-con-solicitudes-de-api/</guid>
      <description>Hacer solicitudes de API con el servicio Angular 2 Http y RxJS es muy similar a trabajar con promesas en Angular 1.x.
Utilice la clase Http para realizar solicitudes. La clase Http expone los métodos para emitir solicitudes HTTP GET, POST, PUT, DELETE, PATCH, HEAD a través de los métodos correspondientes. También expone un método genérico de solicitud para emitir cualquier tipo de solicitud HTTP.
Todos los métodos de la clase Http devuelven un Observable&amp;lt;Response&amp;gt;, al que puede aplicar operaciones RxJS.</description>
    </item>
    
    <item>
      <title>Enrutamiento (3.0.0&#43;)</title>
      <link>https://www.wikiod.com/es/angular2/enrutamiento-300-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/enrutamiento-300-/</guid>
      <description>Hay algunos trucos más que podemos hacer con el enrutador (como restringir el acceso), pero se pueden tratar en un tutorial separado.
Si necesita una nueva ruta, simplemente modifique app.routes.ts y siga los siguientes pasos:
Importar el Componente Agregue a la matriz rutas. Asegúrese de incluir una nueva ruta y componente. Controlar el acceso hacia o desde una ruta # El enrutador Angular predeterminado permite la navegación hacia y desde cualquier ruta incondicionalmente.</description>
    </item>
    
    <item>
      <title>Bootstrap Módulo vacío en angular 2</title>
      <link>https://www.wikiod.com/es/angular2/bootstrap-modulo-vacio-en-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/bootstrap-modulo-vacio-en-angular-2/</guid>
      <description>Un módulo vacío # import { NgModule } from &#39;@angular/core&#39;; @NgModule({ declarations: [], // components your module owns. imports: [], // other modules your module needs. providers: [], // providers available to your module. bootstrap: [] // bootstrap this root component. }) export class MyModule {} Este es un módulo vacío que no contiene declaraciones, importaciones, proveedores o componentes para arrancar. Usa esto como referencia.
Módulo raíz de la aplicación # import { NgModule } from &#39;@angular/core&#39;; import { BrowserModule } from &#39;@angular/platform-browser&#39;; import { AppComponent } from &#39;.</description>
    </item>
    
    <item>
      <title>Prueba de una aplicación Angular 2</title>
      <link>https://www.wikiod.com/es/angular2/prueba-de-una-aplicacion-angular-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/prueba-de-una-aplicacion-angular-2/</guid>
      <description>Instalación del marco de pruebas de Jasmine # La forma más común de probar aplicaciones de Angular 2 es con el marco de prueba de Jasmine. Jasmine te permite probar tu código en el navegador.
Instalar # Para comenzar, todo lo que necesita es el paquete jasmine-core (no jasmine).
npm install jasmine-core --save-dev --save-exact Verificar # Para verificar que Jasmine esté configurado correctamente, cree el archivo ./src/unit-tests.html con el siguiente contenido y ábralo en el navegador.</description>
    </item>
    
    <item>
      <title>Detección de eventos de cambio de tamaño</title>
      <link>https://www.wikiod.com/es/angular2/deteccion-de-eventos-de-cambio-de-tamano/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/angular2/deteccion-de-eventos-de-cambio-de-tamano/</guid>
      <description>Un componente escuchando el evento de cambio de tamaño de la ventana. # Supongamos que tenemos un componente que se ocultará en un cierto ancho de ventana.
import { Component } from &#39;@angular/core&#39;; @Component({ ... template: ` &amp;lt;div&amp;gt; &amp;lt;p [hidden]=&amp;quot;!visible&amp;quot; (window:resize)=&amp;quot;onResize($event)&amp;quot; &amp;gt;Now you see me...&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;now you dont!&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ` ... }) export class MyComponent { visible: boolean = false; breakpoint: number = 768; constructor() { } onResize(event) { const w = event.</description>
    </item>
    
  </channel>
</rss>
