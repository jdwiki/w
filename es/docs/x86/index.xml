<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de microarquitectura y lenguaje ensamblador Intel x86 on </title>
    <link>https://www.wikiod.com/es/docs/x86/</link>
    <description>Recent content in Tutorial de microarquitectura y lenguaje ensamblador Intel x86 on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/x86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con el lenguaje ensamblador Intel x86 y la microarquitectura</title>
      <link>https://www.wikiod.com/es/x86/primeros-pasos-con-el-lenguaje-ensamblador-intel-x86-y-la-microarquitectura/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/primeros-pasos-con-el-lenguaje-ensamblador-intel-x86-y-la-microarquitectura/</guid>
      <description>x86 Linux Hola Mundo Ejemplo # Este es un programa básico de Hello World en ensamblaje NASM para Linux x86 de 32 bits, que usa llamadas al sistema directamente (sin ninguna llamada a la función libc). Es mucho para asimilar, pero con el tiempo se volverá comprensible. Las líneas que comienzan con un punto y coma (;) son comentarios.
Si aún no conoce la programación de sistemas Unix de bajo nivel, es posible que desee simplemente escribir funciones en asm y llamarlas desde programas C o C ++.</description>
    </item>
    
    <item>
      <title>Convenciones de llamadas</title>
      <link>https://www.wikiod.com/es/x86/convenciones-de-llamadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/convenciones-de-llamadas/</guid>
      <description>Recursos # Resúmenes/comparaciones: Guía de convenciones de llamadas agradables de Agner Fog. Además, ABI x86 (wikipedia): convenciones de llamadas para funciones, incluidas x86-64 Windows y System V (Linux).
SystemV x86-64 ABI (estándar oficial). Utilizado por todos los sistemas operativos excepto Windows. (Esta página wiki de github, actualizada por H.J. Lu, tiene enlaces a 32 bits, 64 bits y x32. También enlaces al foro oficial para mantenedores/colaboradores de ABI). También tenga en cuenta que [clang/gcc sign /zero amplía los argumentos estrechos a 32 bits][5], aunque la ABI tal como está escrita no lo requiere.</description>
    </item>
    
    <item>
      <title>Gestión multiprocesador</title>
      <link>https://www.wikiod.com/es/x86/gestion-multiprocesador/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/gestion-multiprocesador/</guid>
      <description>Parámetros # registro LAPIC Dirección (Relativa a BASE APIC) Registro de identificación APIC local +20h Registro de vector de interrupción espuria +0f0h registro de comando de interrupción (ICR); bits 0-31 +300h registro de comando de interrupción (ICR); puntas 32-63 +310h Para acceder a los registros LAPIC, un segmento debe poder alcanzar el rango de direcciones que comienza en APIC Base (en IA32_APIC_BASE). Esta dirección es reubicable y, teóricamente, se puede configurar para que apunte a algún lugar de la memoria inferior, lo que hace que el rango sea direccionable en modo real.</description>
    </item>
    
    <item>
      <title>Registro Fundamentos</title>
      <link>https://www.wikiod.com/es/x86/registro-fundamentos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/registro-fundamentos/</guid>
      <description>Registros de 16 bits # Cuando Intel definió el 8086 original, era un procesador de 16 bits con un bus de direcciones de 20 bits (ver más abajo). Definieron 8 registros de 16 bits de propósito general, pero les dieron roles específicos para ciertas instrucciones:
AX El registro Acumulador. Muchos códigos de operación asumieron este registro o fueron más rápidos si se especificaba. DX El registro de Datos. Esto a veces se combinaba como los 16 bits altos de un valor de 32 bits con &amp;lsquo;AX&amp;rsquo;, por ejemplo, como resultado de una multiplicación.</description>
    </item>
    
    <item>
      <title>Ensambladores</title>
      <link>https://www.wikiod.com/es/x86/ensambladores/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/ensambladores/</guid>
      <description>Ensamblador de red - NASM # NASM es, con mucho, el ensamblador más adaptado para la arquitectura x86: está disponible para prácticamente todos los sistemas operativos basados ​​en x86 (incluso se incluye con MacOS) y está disponible como ensamblador multiplataforma en otras plataformas.
Este ensamblador utiliza la sintaxis de Intel, pero es diferente de los demás porque se centra en gran medida en su propio lenguaje &amp;ldquo;macro&amp;rdquo;; esto permite al programador crear expresiones más complejas utilizando definiciones más simples, lo que permite crear nuevas &amp;ldquo;instrucciones&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Mecanismos de llamada al sistema</title>
      <link>https://www.wikiod.com/es/x86/mecanismos-de-llamada-al-sistema/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/mecanismos-de-llamada-al-sistema/</guid>
      <description>Llamadas de BIOS # Cómo interactuar con el BIOS # El sistema básico de entrada/salida, o BIOS, es lo que controla la computadora antes de que se ejecute cualquier sistema operativo. Para acceder a los servicios proporcionados por el BIOS, el código ensamblador utiliza interrupciones. Una interrupción toma la forma de
int &amp;lt;interrupt&amp;gt; ; interrupt must be a literal number, not in a register or memory El número de interrupción debe estar entre 0 y 255 (0x00 - 0xFF), inclusive.</description>
    </item>
    
    <item>
      <title>Mejoramiento</title>
      <link>https://www.wikiod.com/es/x86/mejoramiento/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/mejoramiento/</guid>
      <description>La familia x86 ha existido durante mucho tiempo y, como tal, se han descubierto y desarrollado muchos trucos y técnicas que son de conocimiento público, o tal vez no tan públicos.
La mayoría de estos trucos aprovechan el hecho de que muchas instrucciones efectivamente hacen lo mismo, pero las diferentes versiones son más rápidas, ahorran memoria o no afectan las banderas.
Aquí hay una serie de trucos que se han descubierto.</description>
    </item>
    
    <item>
      <title>Modos Real vs Protegido</title>
      <link>https://www.wikiod.com/es/x86/modos-real-vs-protegido/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/modos-real-vs-protegido/</guid>
      <description>Modo real # Cuando Intel diseñó el x86 original, el 8086 (y el derivado del 8088), incluyeron Segmentación para permitir que el procesador de 16 bits acceda a más de 16 bits de dirección. Hicieron esto haciendo que las direcciones de 16 bits fueran relativas a un Registro de segmento de 16 bits dado, de los cuales definieron cuatro: Segmento de código (CS), Segmento de datos (DS), Segmento adicional (ES) y segmento de pila (SS).</description>
    </item>
    
    <item>
      <title>Flujo de control</title>
      <link>https://www.wikiod.com/es/x86/flujo-de-control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/flujo-de-control/</guid>
      <description>Condiciones de prueba # Para usar un salto condicional, se debe probar una condición. Probar una condición aquí se refiere solo al acto de verificar las banderas, el salto real se describe en [Saltos condicionales] (https://www.wikiod.com/es/x86/flujo-de-control#Saltos condicionales -saltos).
x86 prueba las condiciones basándose en el registro EFLAGS, que contiene un conjunto de indicadores que cada instrucción puede establecer potencialmente.
Las instrucciones aritméticas, como sub o add, y las instrucciones lógicas, como xor o and, obviamente &amp;ldquo;establecen las banderas&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Paginación - Direccionamiento virtual y memoria</title>
      <link>https://www.wikiod.com/es/x86/paginacion---direccionamiento-virtual-y-memoria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/x86/paginacion---direccionamiento-virtual-y-memoria/</guid>
      <description>Introducción # Historia # Las primeras computadoras # Las primeras computadoras tenían un bloque de memoria en el que el programador ponía código y datos, y la CPU ejecutaba dentro de este entorno. Dado que las computadoras entonces eran muy costosas, era desafortunado que hiciera un trabajo, se detuviera y esperara a que se cargara el siguiente trabajo, y luego lo procesaría.
Multiusuario, multiprocesamiento # Entonces, las computadoras rápidamente se volvieron más sofisticadas y admitieron múltiples usuarios y/o programas simultáneamente, pero fue entonces cuando comenzaron a surgir problemas con la idea simple de &amp;ldquo;un bloque de memoria&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>
