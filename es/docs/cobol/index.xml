<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CobolTutorial on </title>
    <link>https://www.wikiod.com/es/docs/cobol/</link>
    <description>Recent content in CobolTutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/cobol/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Comenzando con cobol</title>
      <link>https://www.wikiod.com/es/cobol/comenzando-con-cobol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/comenzando-con-cobol/</guid>
      <description>Hola Mundo # HELLO * HISTORIC EXAMPLE OF HELLO WORLD IN COBOL IDENTIFICATION DIVISION. PROGRAM-ID. HELLO. PROCEDURE DIVISION. DISPLAY &amp;quot;HELLO, WORLD&amp;quot;. STOP RUN. Los días del diseño de tarjetas perforadas y las entradas solo en mayúsculas quedaron muy atrás. Sin embargo, la mayoría de las implementaciones de COBOL aún manejan el mismo diseño de código. Incluso las implementaciones actuales siguen lo mismo (a menudo incluso en mayúsculas) compiladas y en producción.</description>
    </item>
    
    <item>
      <title>Declaración de LLAMADA</title>
      <link>https://www.wikiod.com/es/cobol/declaracion-de-llamada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/declaracion-de-llamada/</guid>
      <description>La sentencia COBOL CALL proporciona acceso a rutinas de biblioteca compiladas.
Declaración de LLAMADA # COBOL puede usar enlaces estáticos para la siguiente declaración. GnuCOBOL usa enlaces dinámicos por defecto para todos los símbolos externos conocidos en tiempo de compilación, incluso cuando el símbolo es un literal:
CALL &amp;quot;subprogram&amp;quot; USING a b c *&amp;gt; run a (possibly static linked) sub program *&amp;gt; passing three fields CALL some-prog USING a b c *&amp;gt; some-prog is a PIC X item and can be changed *&amp;gt; at run-time to do a dynamic lookup Esta declaración fuerza la resolución de edición de enlace de tiempo de compilación.</description>
    </item>
    
    <item>
      <title>Instalación de GnuCOBOL con GNULinux</title>
      <link>https://www.wikiod.com/es/cobol/instalacion-de-gnucobol-con-gnulinux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/instalacion-de-gnucobol-con-gnulinux/</guid>
      <description>Instalación GNU/Linux # Para la mayoría de las distribuciones de GNU/Linux, una versión de GnuCOBOL está disponible en los repositorios. GnuCOBOL era originalmente OpenCOBOL, renombrado cuando el proyecto se convirtió en un proyecto GNU oficial. Muchos repositorios todavía usan open-cobol como nombre del paquete (a partir de agosto de 2016).
Para Fedora y otros administradores de paquetes basados ​​en RPM
sudo yum install open-cobol Para paquetes basados ​​en Debian, Ubuntu y APT</description>
    </item>
    
    <item>
      <title>instrucción ALTERAR</title>
      <link>https://www.wikiod.com/es/cobol/instruccion-alterar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/instruccion-alterar/</guid>
      <description>La muy querida declaración ALTER. Cambia el destino de un párrafo IR A.
Ya no forma parte del estándar COBOL, todavía es compatible con muchos compiladores por razones de compatibilidad con versiones anteriores. (El diagrama de sintaxis está atenuado para mostrar que ya no es COBOL estándar).
Un ejemplo artificial usando ALTER # identification division. program-id. altering. date-written. 2015-10-28/06:36-0400. remarks. Demonstrate ALTER. procedure division. main section. *&amp;gt; And now for some altering.</description>
    </item>
    
    <item>
      <title>ACEPTAR declaración</title>
      <link>https://www.wikiod.com/es/cobol/aceptar-declaracion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/aceptar-declaracion/</guid>
      <description>La instrucción COBOL ACCEPT se utiliza para recuperar datos del sistema.
Declaración ACEPTAR # ACCEPT variable. ACCEPT variable FROM CONSOLE. ACCEPT variable FROM ENVIRONMENT &amp;quot;path&amp;quot;. ACCEPT variable FROM COMMAND-LINE. ACCEPT variable FROM ARGUMENT-NUMBER ACCEPT variable FROM ARGUMENT-VALUE ACCEPT variable AT 0101. ACCEPT screen-variable. ACCEPT today FROM DATE. ACCEPT today FROM DATE YYYYMMDD. ACCEPT thetime FROM TIME. ACCEPT theday FROM DAY. ACCEPT theday FROM DAY YYYYDDD. ACCEPT weekday FROM DAY-OF-WEEK. ACCEPT thekey FROM ESCAPE KEY.</description>
    </item>
    
    <item>
      <title>Declaración de INICIO</title>
      <link>https://www.wikiod.com/es/cobol/declaracion-de-inicio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/declaracion-de-inicio/</guid>
      <description>La instrucción START proporciona una forma de colocar una lectura en un archivo para su posterior recuperación secuencial (por clave).
El relacional clave puede incluir (pero no se limita a):
LA CLAVE ES MAYOR QUE
LA CLAVE ES &amp;gt;
LA CLAVE ES MENOR QUE
LA CLAVE ES &amp;lt;
LA CLAVE ES IGUAL A
LA CLAVE ES =
LA CLAVE NO ES MAYOR QUE
LA CLAVE NO ES &amp;gt;
LA CLAVE NO ES MENOR QUE</description>
    </item>
    
    <item>
      <title>Declaración de SALIDA</title>
      <link>https://www.wikiod.com/es/cobol/declaracion-de-salida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/declaracion-de-salida/</guid>
      <description>La declaración COBOL EXIT es un verbo de control de flujo de terminación.
EXIT viene en algunos sabores:
EXIT desnudo es un punto final común para una serie de procedimientos. EXIT PARAGRAPH, EXIT SECTION proporciona un medio para salir de un procedimiento estructurado sin ejecutar ninguna de las sentencias posteriores. EXIT FUNCTION, EXIT METHOD, EXIT PROGRAM marca el final lógico de un módulo de código. EXIT PERFORM sale de un bucle de ejecución en línea.</description>
    </item>
    
    <item>
      <title>ESCRIBIR declaración</title>
      <link>https://www.wikiod.com/es/cobol/escribir-declaracion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/escribir-declaracion/</guid>
      <description>La sentencia WRITE libera registros lógicos a un recurso de almacenamiento output o input-output, y para el posicionamiento lógico de líneas dentro de una página lógica.
ESCRIBIR secuencial
ESCRIBIR al azar
ESCRIBIR ejemplos # WRITE record-buff WRITE indexed-record WITH LOCK ON INVALID KEY DISPLAY &amp;quot;Key exists, REWRITING...&amp;quot; END-DISPLAY PERFORM rewrite-key END-WRITE IF indexed-file-status NOT EQUAL ZERO THEN DISPLAY &amp;quot;Write problem: &amp;quot; indexed-file-status UPON SYSERR END-DISPLAY PERFORM evasive-manoeuvres END-IF WRITE record-name-1 AFTER ADVANCING PAGE WRITE record-name-1 FROM header-record-1 AFTER ADVANCING 2 LINES AT END-OF-PAGE PERFORM write-page-header PERFORM write-last-detail-reminder END-WRITE </description>
    </item>
    
    <item>
      <title>declaración CONTINUAR</title>
      <link>https://www.wikiod.com/es/cobol/declaracion-continuar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/declaracion-continuar/</guid>
      <description>La sentencia CONTINUE hace que el flujo de control continúe en la sentencia siguiente. No es del todo un no-op, ya que puede influir en el flujo de control cuando se encuentra dentro de secuencias de declaraciones compuestas, en particular IF/THEN/ELSE.
¿Un práctico? el ejemplo es durante el desarrollo temprano y la construcción con y sin ayudas de depuración.
CALL &amp;quot;CBL_OC_DUMP&amp;quot; USING structure ON EXCEPTION CONTINUE END-CALL Ese código, aunque costoso, permitirá volcados de memoria formateada cuando el módulo CBL_OC_DUMP esté vinculado al ejecutable, pero fallará inofensivamente cuando no lo esté.</description>
    </item>
    
    <item>
      <title>Funciones intrínsecas</title>
      <link>https://www.wikiod.com/es/cobol/funciones-intrinsecas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/cobol/funciones-intrinsecas/</guid>
      <description>Las funciones intrínsecas se incluyen en el estándar COBOL como un conjunto de funciones que devuelven valores de un algoritmo específico, con cero o más argumentos. Estas funciones intrínsecas se proporcionan como una facilidad del compilador y del sistema de tiempo de ejecución. Los elementos devueltos son campos COBOL temporales y pueden ser datos de caracteres, campos de bits o valores numéricos.
Los ejemplos incluyen funciones trigonométricas, rutinas de fecha y hora, conversiones de tipos de datos, desviación estándar y otros algoritmos de soporte.</description>
    </item>
    
  </channel>
</rss>
