<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de lenguaje de Julia on </title>
    <link>https://www.wikiod.com/es/docs/julia-lang/</link>
    <description>Recent content in Tutorial de lenguaje de Julia on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/julia-lang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Julia Language</title>
      <link>https://www.wikiod.com/es/julia-lang/primeros-pasos-con-julia-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/primeros-pasos-con-julia-language/</guid>
      <description>¡Hola Mundo! # println(&amp;quot;Hello, World!&amp;quot;) Para ejecutar Julia, primero obtenga el intérprete de la [página de descarga] del sitio web (http://julialang.org/downloads/). La versión estable actual es v0.5.0, y esta versión se recomienda para la mayoría de los usuarios. Ciertos desarrolladores de paquetes o usuarios avanzados pueden optar por utilizar la compilación nocturna, que es mucho menos estable.
Cuando tenga el intérprete, escriba su programa en un archivo llamado hello.jl. Luego se puede ejecutar desde una terminal del sistema como:</description>
    </item>
    
    <item>
      <title>para bucles</title>
      <link>https://www.wikiod.com/es/julia-lang/para-bucles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/para-bucles/</guid>
      <description>Sintaxis # para i en iter; &amp;hellip;; final mientras que cond; &amp;hellip;; final descanso Seguir @parallel (op) para i en iter; &amp;hellip;; final @parallel para i en iter; &amp;hellip;; final etiqueta @goto etiqueta @label Siempre que haga que el código sea más corto y más fácil de leer, considere usar funciones de orden superior, como mapa o filtro, en lugar de bucles.
Encuentra el factor primo más pequeño # En algunas situaciones, es posible que desee regresar de una función antes de terminar un ciclo completo.</description>
    </item>
    
    <item>
      <title>Cierres</title>
      <link>https://www.wikiod.com/es/julia-lang/cierres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/cierres/</guid>
      <description>Sintaxis # x -&amp;gt; [cuerpo] (x, y) -&amp;gt; [cuerpo] (xs&amp;hellip;) -&amp;gt; [cuerpo] En versiones anteriores de Julia, los cierres y las funciones anónimas tenían una penalización en el rendimiento del tiempo de ejecución. Esta penalización ha sido eliminada en 0.5.
Introducción a los cierres # Funciones son ​​una parte importante de la programación de Julia. Se pueden definir directamente dentro de los módulos, en cuyo caso las funciones se denominan nivel superior.</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://www.wikiod.com/es/julia-lang/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/json/</guid>
      <description>Sintaxis # usando JSON JSON.parse(str) JSON.json(obj) JSON.print(io, obj, sangría) Dado que ni los objetos Dict de Julia ni los objetos JSON están ordenados inherentemente, es mejor no confiar en el orden de los pares clave-valor en un objeto JSON.
Instalación de JSON.jl # JSON es un formato popular de intercambio de datos. La biblioteca JSON más popular para Julia es JSON.jl. Para instalar este paquete, use el administrador de paquetes:</description>
    </item>
    
    <item>
      <title>Aporte</title>
      <link>https://www.wikiod.com/es/julia-lang/aporte/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/aporte/</guid>
      <description>Sintaxis # línea de lectura() líneas de lectura() cadena de lectura (STDIN) morder (str) abrir (f, archivo) línea de ojos (io) cadena de lectura (archivo) leer (archivo) readcsv(archivo) readdlm(archivo) Parámetros # Parámetro Detalles chomp(cadena) Eliminar hasta un salto de línea final de una cadena. str La cadena de la que se va a quitar una nueva línea final. Tenga en cuenta que cadenas son ​​inmutables por convención. Esta función devuelve una nueva cadena.</description>
    </item>
    
    <item>
      <title>Condicionales</title>
      <link>https://www.wikiod.com/es/julia-lang/condicionales/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/condicionales/</guid>
      <description>Sintaxis # si está condicionado; cuerpo; final si está condicionado; cuerpo; más; cuerpo; final si está condicionado; cuerpo; elseif condicional; cuerpo; más; final si está condicionado; cuerpo; elseif condicional; cuerpo; final ¿Condición? si es cierto: si es falso cond &amp;amp;&amp;amp; si es cierto condición || si es falso ifelse(cond, iftrue, iffalse) Todos los operadores y funciones condicionales implican el uso de condiciones booleanas (verdadero o falso). En Julia, el tipo de booleanos es Bool.</description>
    </item>
    
    <item>
      <title>Metaprogramación</title>
      <link>https://www.wikiod.com/es/julia-lang/metaprogramacion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/metaprogramacion/</guid>
      <description>Sintaxis # nombre de macro (ex) &amp;hellip; final cita &amp;hellip; final :(&amp;hellip;) $ x Meta.quot(x) QuoteNode(x) esc(x) Las funciones de metaprogramación de Julia están fuertemente inspiradas en las de los lenguajes similares a Lisp, y les parecerán familiares a aquellos con algo de experiencia en Lisp. La metaprogramación es muy poderosa. Cuando se usa correctamente, puede conducir a un código más conciso y legible.
La sintaxis quote ... end es cuasiquote.</description>
    </item>
    
    <item>
      <title>Procesamiento en paralelo</title>
      <link>https://www.wikiod.com/es/julia-lang/procesamiento-en-paralelo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/procesamiento-en-paralelo/</guid>
      <description>@async y @sync # De acuerdo con la documentación bajo ?@async, &amp;ldquo;@async envuelve una expresión en una Tarea&amp;rdquo;. Lo que esto significa es que, para lo que sea que esté dentro de su alcance, Julia iniciará la ejecución de esta tarea, pero luego continuará con lo que venga a continuación en el script sin esperar a que se complete la tarea. Así, por ejemplo, sin la macro obtendrá:
julia&amp;gt; @time sleep(2) 2.</description>
    </item>
    
    <item>
      <title>tuplas</title>
      <link>https://www.wikiod.com/es/julia-lang/tuplas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/tuplas/</guid>
      <description>Sintaxis # a, un, b a, b = xs () (a,) (a, b) (un, b&amp;hellip;) Tupla{T, U, V} NTuplo{N, T} Tupla{T, U, Vararg{V}} Las tuplas tienen un rendimiento de tiempo de ejecución mucho mejor que matrices por dos razones: sus tipos son más precisos y su inmutabilidad les permite asignarse en la pila en lugar del montón. Sin embargo, esta tipificación más precisa conlleva una mayor sobrecarga de tiempo de compilación y una mayor dificultad para lograr la estabilidad del tipo.</description>
    </item>
    
    <item>
      <title>Examen de la unidad</title>
      <link>https://www.wikiod.com/es/julia-lang/examen-de-la-unidad/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/julia-lang/examen-de-la-unidad/</guid>
      <description>Sintaxis # @prueba [expr] @test_throws [Excepción] [expr] @testset &amp;ldquo;[nombre]&amp;rdquo; comienza; [pruebas]; final Pkg.test([paquete]) La documentación de la biblioteca estándar para Base.Test cubre material adicional además del que se muestra en estos ejemplos.
Prueba de un paquete # Para ejecutar las pruebas unitarias para un paquete, use la función Pkg.test. Para un paquete llamado MyPackage, el comando sería
julia&amp;gt; Pkg.test(&amp;quot;MyPackage&amp;quot;) Un resultado esperado sería similar a
INFO: Computing test dependencies for MyPackage.</description>
    </item>
    
  </channel>
</rss>
