<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorial de lenguaje Haskell on </title>
    <link>https://www.wikiod.com/es/docs/haskell/</link>
    <description>Recent content in Tutorial de lenguaje Haskell on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/haskell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con Haskell Language</title>
      <link>https://www.wikiod.com/es/haskell/primeros-pasos-con-haskell-language/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/primeros-pasos-con-haskell-language/</guid>
      <description>¡Hola Mundo! # Un básico &amp;quot;¡Hola, mundo!&amp;quot; program en Haskell se puede expresar de manera concisa en solo una o dos líneas:
main :: IO () main = putStrLn &amp;quot;Hello, World!&amp;quot; La primera línea es una anotación de tipo opcional, que indica que main es un valor de tipo IO (), que representa una acción de E/S que &amp;ldquo;calcula&amp;rdquo; un valor de tipo () (léase &amp;ldquo;unidad&amp;rdquo;; el tupla vacía que no transmite información) además de realizar algunos efectos secundarios en el mundo exterior (aquí, imprimiendo una cadena en la terminal).</description>
    </item>
    
    <item>
      <title>Lente</title>
      <link>https://www.wikiod.com/es/haskell/lente/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/lente/</guid>
      <description>Lens es una biblioteca para Haskell que proporciona lentes, isomorfismos, pliegues, recorridos, getters y setters, que expone una interfaz uniforme para consultar y manipular estructuras arbitrarias, similar a los conceptos de acceso y mutación de Java.
¿Qué es una lente? # Las lentes (y otras ópticas) nos permiten separar la descripción de cómo queremos acceder a algunos datos de qué queremos hacer con ellos. Es importante distinguir entre la noción abstracta de lente y la implementación concreta.</description>
    </item>
    
    <item>
      <title>Extensiones de idioma comunes de GHC</title>
      <link>https://www.wikiod.com/es/haskell/extensiones-de-idioma-comunes-de-ghc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/extensiones-de-idioma-comunes-de-ghc/</guid>
      <description>Estas extensiones de idioma suelen estar disponibles cuando se utiliza el Compilador de Haskell de Glasgow (GHC), ya que no forman parte del Informe de idioma de Haskell 2010. Para usar estas extensiones, uno debe informar al compilador usando una bandera o colocar un programa LANGUAGE antes de la palabra clave module en un archivo. La documentación oficial se puede encontrar en la sección 7 de la guía del usuario de GCH.</description>
    </item>
    
    <item>
      <title>Mónadas libres</title>
      <link>https://www.wikiod.com/es/haskell/monadas-libres/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/monadas-libres/</guid>
      <description>Las mónadas libres dividen los cálculos monádicos en estructuras de datos e intérpretes # Por ejemplo, un cálculo que involucre comandos para leer y escribir desde el indicador:
Primero describimos los &amp;ldquo;comandos&amp;rdquo; de nuestro cálculo como un tipo de datos Functor
{-# LANGUAGE DeriveFunctor #-} data TeletypeF next = PrintLine String next | ReadLine (String -&amp;gt; next) deriving Functor Luego usamos Free para crear la &amp;ldquo;Monada libre sobre TeletypeF&amp;rdquo; y construir algunas operaciones básicas.</description>
    </item>
    
    <item>
      <title>io</title>
      <link>https://www.wikiod.com/es/haskell/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/io/</guid>
      <description>Obteniendo la &amp;lsquo;a&amp;rsquo; &amp;ldquo;fuera de&amp;rdquo; &amp;lsquo;IO a&amp;rsquo; # Una pregunta común es &amp;ldquo;Tengo un valor de IO a, pero quiero hacer algo con ese valor a: ¿cómo puedo acceder a él?&amp;rdquo; ¿Cómo se puede operar con datos que vienen del mundo exterior (por ejemplo, incrementando un número tecleado por el usuario)?
El punto es que si usa una función pura en datos obtenidos de forma impura, entonces el resultado sigue siendo impuro.</description>
    </item>
    
    <item>
      <title>mónadas</title>
      <link>https://www.wikiod.com/es/haskell/monadas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/monadas/</guid>
      <description>Una mónada es un tipo de datos de acciones componibles. Monad es la clase de constructores de tipos cuyos valores representan tales acciones. Quizás IO es el más reconocible: un valor de IO a es una &amp;ldquo;receta para recuperar un valor a del mundo real&amp;rdquo;.
Decimos que un constructor de tipos m (como [] o Maybe) forma una mónada si hay una instancia Mónada m que satisface ciertas leyes sobre la composición de acciones.</description>
    </item>
    
    <item>
      <title>plegable</title>
      <link>https://www.wikiod.com/es/haskell/plegable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/plegable/</guid>
      <description>Plegable es la clase de tipos t :: * -&amp;gt; * que admiten una operación de plegado. Un pliegue agrega los elementos de una estructura en un orden bien definido, utilizando una función de combinación.
Si t es Plegable significa que para cualquier valor t a sabemos cómo acceder a todos los elementos de a desde &amp;ldquo;dentro&amp;rdquo; de t a en un orden lineal fijo. Este es el significado de foldMap :: Monoid m =&amp;gt; (a -&amp;gt; m) -&amp;gt; (t a -&amp;gt; m): &amp;ldquo;visitamos&amp;rdquo; cada elemento con una función de resumen y juntamos todos los resúmenes.</description>
    </item>
    
    <item>
      <title>Traversable</title>
      <link>https://www.wikiod.com/es/haskell/traversable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/traversable/</guid>
      <description>La clase Traversable generaliza la función anteriormente conocida como mapM :: Monad m =&amp;gt; (a -&amp;gt; m b) -&amp;gt; [a] -&amp;gt; m [b] para trabajar con efectos Applicative sobre estructuras que no sean listas.
Atravesar una estructura al revés # Se puede ejecutar un recorrido en la dirección opuesta con la ayuda del funtor aplicativo Backwards , que invierte un aplicativo existente para que los efectos compuestos se produzcan en orden inverso.</description>
    </item>
    
    <item>
      <title>Literales sobrecargados</title>
      <link>https://www.wikiod.com/es/haskell/literales-sobrecargados/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/literales-sobrecargados/</guid>
      <description>Literales enteros # es un número sin un punto decimal
por ejemplo 0, 1, 42, &amp;hellip;
se aplica implícitamente a fromInteger que forma parte de la clase de tipo [Num] (https://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#t:Num) por lo que de hecho tiene tipo Num a =&amp;gt; a - es decir, puede tener cualquier tipo que es una instancia de Num
Literales fraccionarios # es un número con un punto decimal
por ejemplo 0.0, -0.1111, &amp;hellip;</description>
    </item>
    
    <item>
      <title>Comprobación rápida</title>
      <link>https://www.wikiod.com/es/haskell/comprobacion-rapida/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/haskell/comprobacion-rapida/</guid>
      <description>Generación aleatoria de datos para tipos personalizados # La clase Arbitrary es para tipos que QuickCheck puede generar aleatoriamente.
La implementación mínima de Arbitrary es el método arbitrary, que se ejecuta en la mónada Gen para producir un valor aleatorio.
Aquí hay una instancia de Arbitrary para el siguiente tipo de datos de listas no vacías.
import Test.QuickCheck.Arbitrary (Arbitrary(..)) import Test.QuickCheck.Gen (oneof) import Control.Applicative ((&amp;lt;$&amp;gt;), (&amp;lt;*&amp;gt;)) data NonEmpty a = End a | Cons a (NonEmpty a) instance Arbitrary a =&amp;gt; Arbitrary (NonEmpty a) where arbitrary = oneof [ -- randomly select one of the cases from the list End &amp;lt;$&amp;gt; arbitrary, -- call a&#39;s instance of Arbitrary Cons &amp;lt;$&amp;gt; arbitrary &amp;lt;*&amp;gt; -- call a&#39;s instance of Arbitrary arbitrary -- recursively call NonEmpty&#39;s instance of Arbitrary ] Usar implicación (==&amp;gt;) para verificar propiedades con condiciones previas # prop_evenNumberPlusOneIsOdd :: Integer -&amp;gt; Property prop_evenNumberPlusOneIsOdd x = even x ==&amp;gt; odd (x + 1) Si desea verificar que una propiedad se cumple dado que se cumple una condición previa, puede usar el operador ==&amp;gt;.</description>
    </item>
    
  </channel>
</rss>
