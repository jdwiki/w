<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojurescript Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/clojurescript/</link>
    <description>Recent content in Clojurescript Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Primeros pasos con clojurescript</title>
      <link>https://www.wikiod.com/es/clojurescript/primeros-pasos-con-clojurescript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/primeros-pasos-con-clojurescript/</guid>
      <description>Instalación o configuración # #leiningen
Nota: Si va a utilizar Leiningen, primero debe descargar e instalar JDK 6 o posterior.
La forma más fácil de comenzar con Clojure es descargar e instalar Leiningen, la herramienta estándar de facto para administrar proyectos de Clojure.
##linux:
curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein &amp;gt; ~/bin/lein export PATH=$PATH:~/bin chmod 755 ~/bin/lein lein SO X: # Siga los pasos de Linux anteriores o
Instalar con [Homebrew]:
brew install leiningen Ventanas: # Consulte https://github.</description>
    </item>
    
    <item>
      <title>Primeros pasos con el reactivo</title>
      <link>https://www.wikiod.com/es/clojurescript/primeros-pasos-con-el-reactivo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/primeros-pasos-con-el-reactivo/</guid>
      <description>Reagent es una biblioteca que implementa elementos de React.js en ClojureScript, como la creación de &amp;ldquo;etiquetas&amp;rdquo; personalizadas, que se implementa en Reagent a través de funciones.
Interfaz de usuario usando Reactivo e Hipo # Reagent es una interfaz entre ClojureScript y react. Le permite definir componentes de React eficientes usando nada más que funciones y datos simples de ClojureScript, que describen su interfaz de usuario usando una sintaxis similar a Hiccup.</description>
    </item>
    
    <item>
      <title>Noria</title>
      <link>https://www.wikiod.com/es/clojurescript/noria/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/noria/</guid>
      <description>Figwheel reconstruye automáticamente su código clojurescript cuando los archivos fuente cambian y vuelve a cargar el código en el navegador. La recarga funciona sin actualizar la página y puede conservar parte del estado de la aplicación entre recargas usando defonce.
Es una alternativa al desarrollo basado en REPL (aunque también incluye REPL). En lugar de volver a evaluar las funciones modificadas en REPL, vuelve a cargar todo el código y puede usar println para ver el resultado de la evaluación de la expresión en la consola js del navegador.</description>
    </item>
    
    <item>
      <title>lein-cljsbuild</title>
      <link>https://www.wikiod.com/es/clojurescript/lein-cljsbuild/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/lein-cljsbuild/</guid>
      <description>Se pueden encontrar más detalles sobre los parámetros para lein-clsjbuild en su ejemplo de proyecto.
Desarrollo y producción de ClojureScript # Agregue un nodo :cljsbuild como el siguiente a su archivo project.clj.
:cljsbuild { :builds { ;;Different target goals should have different names. ;;We have the dev build here :dev { ;;The ClojureScript code should reside in these directories :source-paths [&amp;quot;src-cljs&amp;quot;] :compiler { ;;This is the target output file ;;This will include none of the goog code.</description>
    </item>
    
    <item>
      <title>Eventos de JavaScript</title>
      <link>https://www.wikiod.com/es/clojurescript/eventos-de-javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/eventos-de-javascript/</guid>
      <description>Sintaxis # (goog.events dom-element event-type event-handler-function) ;;Crea un detector de eventos de cierre de Google (.addEventListener dom-element load-event) ;;Crea un detector de eventos de JavaScript normal. Puede ser específico del navegador. Todos los nombres de eventos de Closure se pueden encontrar en su documentación en la enumeración EventType.
Agregar evento al botón usando la biblioteca de cierre # (ns so-doc.events (:require [goog.dom :as dom] [goog.events :as events])) (defn handle-click [event] ;an event object is passed to all events (js/alert &amp;quot;button pressed&amp;quot;)) (events/listen (dom/getElement &amp;quot;button&amp;quot;); This is the dom element the event comes from (.</description>
    </item>
    
    <item>
      <title>Gestión de estado con reencuadre (httpsgithub.comDay8re-frame)</title>
      <link>https://www.wikiod.com/es/clojurescript/gestion-de-estado-con-reencuadre-httpsgithubcomday8re-frame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/clojurescript/gestion-de-estado-con-reencuadre-httpsgithubcomday8re-frame/</guid>
      <description>Comienza a ser difícil cuando pensamos en clojurescript como un lenguaje funcionalmente puro, que tiene estado para sus componentes de interfaz de usuario. Es simplemente imposible.
Sin embargo, es posible separar los componentes individuales así como sus estados. Podemos hacerlo almacenando datos/estado en reactivo/átomo. Pero cuando hay muchos estados y muchas dependencias, las cosas se vuelven confusas rápidamente y comenzamos a desear una solución lista para usar para la administración de nuestro estado.</description>
    </item>
    
  </channel>
</rss>
