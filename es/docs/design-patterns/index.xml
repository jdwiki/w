<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patrones de diseño Tutorial on </title>
    <link>https://www.wikiod.com/es/docs/design-patterns/</link>
    <description>Recent content in Patrones de diseño Tutorial on </description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://www.wikiod.com/es/docs/design-patterns/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introducción a los patrones de diseño</title>
      <link>https://www.wikiod.com/es/design-patterns/introduccion-a-los-patrones-de-diseno/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/introduccion-a-los-patrones-de-diseno/</guid>
      <description>Introducción # Según Wikipedia:
[Un] patrón de diseño de software es una solución general reutilizable para un problema común dentro de un contexto dado en el diseño de software. No es un diseño terminado que pueda transformarse directamente en código fuente o máquina. Es una descripción o plantilla sobre cómo resolver un problema que se puede usar en muchas situaciones diferentes. Los patrones de diseño son mejores prácticas formalizadas que el programador puede usar para resolver problemas comunes al diseñar una aplicación o sistema.</description>
    </item>
    
    <item>
      <title>Fábrica</title>
      <link>https://www.wikiod.com/es/design-patterns/fabrica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/fabrica/</guid>
      <description>Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.
&amp;ndash; GOF 1994
Fábrica simple (Java) # Una fábrica reduce el acoplamiento entre el código que necesita crear objetos a partir del código de creación de objetos. La creación de objetos no se realiza explícitamente llamando a un constructor de clase, sino llamando a alguna función que crea el objeto en nombre de la persona que llama.</description>
    </item>
    
    <item>
      <title>único</title>
      <link>https://www.wikiod.com/es/design-patterns/unico/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/unico/</guid>
      <description>El patrón de diseño Singleton a veces se considera &amp;ldquo;Antipatrón&amp;rdquo;. Esto se debe al hecho de que tiene algunos problemas. Tienes que decidir por ti mismo si crees que es apropiado usarlo. Este tema se ha discutido varias veces en StackOverflow.
Ver: http://stackoverflow.com/questions/137975/what-is-tan-bad-about-singletons
Singleton (Java) # Singletons en Java son muy similares a C#, ya que ambos lenguajes están orientados a objetos. A continuación se muestra un ejemplo de una clase singleton, donde solo una versión del objeto puede estar viva durante la vida útil del programa (suponiendo que el programa funcione en un subproceso)</description>
    </item>
    
    <item>
      <title>Patrón de estrategia</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-de-estrategia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-de-estrategia/</guid>
      <description>Ejemplo de patrón de estrategia en java con clase de contexto # Estrategia:
Strategy es un patrón de comportamiento, que permite cambiar el algoritmo dinámicamente a partir de una familia de algoritmos relacionados.
UML de patrón de estrategia de Wikipedia
:
import java.util.*; /* Interface for Strategy */ interface OfferStrategy { public String getName(); public double getDiscountPercentage(); } /* Concrete implementation of base Strategy */ class NoDiscountStrategy implements OfferStrategy{ public String getName(){ return this.</description>
    </item>
    
    <item>
      <title>Patrón de constructor</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-de-constructor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-de-constructor/</guid>
      <description>Separa la construcción de un objeto complejo de su representación para que un mismo proceso de construcción pueda crear diferentes representaciones.
Separar la lógica de la representación. Reutilizar la lógica para trabajar con diferentes conjuntos de datos. Java / Lombok # import lombok.Builder; @Builder public class Email { private String to; private String from; private String subject; private String body; } Ejemplo de uso:
Email.builder().to(&amp;quot;email1@email.com&amp;quot;) .from(&amp;quot;email2@email.com&amp;quot;) .subject(&amp;quot;Email subject&amp;quot;) .body(&amp;quot;Email content&amp;quot;) .</description>
    </item>
    
    <item>
      <title>patrón decorador</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-decorador/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-decorador/</guid>
      <description>El patrón Decorator permite al usuario agregar nuevas funciones a un objeto existente sin alterar su estructura. Este tipo de patrón de diseño se incluye en el patrón estructural, ya que este patrón actúa como un envoltorio para la clase existente.
Este patrón crea una clase de decorador que envuelve la clase original y proporciona una funcionalidad adicional que mantiene intacta la firma de los métodos de clase.
Parámetros # Parámetro Descripción Bebida puede ser Té o Café Decorador de máquinas expendedoras # Definición de decorador según Wikipedia:</description>
    </item>
    
    <item>
      <title>Inyección de dependencia</title>
      <link>https://www.wikiod.com/es/design-patterns/inyeccion-de-dependencia/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/inyeccion-de-dependencia/</guid>
      <description>La idea general detrás de la inyección de dependencia es que diseñe su aplicación en torno a componentes poco acoplados mientras se adhiere al principio de inversión de dependencia. Al no depender de implementaciones concretas, permite diseñar sistemas altamente flexibles.
La idea básica detrás de la inyección de dependencia es crear un código acoplado más flexible. Cuando una clase, en lugar de actualizar sus propias dependencias, toma sus dependencias, la clase se vuelve más fácil de probar como una unidad (prueba de unidad).</description>
    </item>
    
    <item>
      <title>Patrón de visitante</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-de-visitante/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-de-visitante/</guid>
      <description>Ejemplo de patrón de visitante en java # El patrón Visitor le permite agregar nuevas operaciones o métodos a un conjunto de clases sin modificar la estructura de esas clases.
Este patrón es especialmente útil cuando desea centralizar una operación particular en un objeto sin extender el objeto o sin modificar el objeto.
Diagrama UML de wikipedia:
Fragmento de código:
import java.util.HashMap; interface Visitable{ void accept(Visitor visitor); } interface Visitor{ void logGameStatistics(Chess chess); void logGameStatistics(Checkers checkers); void logGameStatistics(Ludo ludo); } class GameVisitor implements Visitor{ public void logGameStatistics(Chess chess){ System.</description>
    </item>
    
    <item>
      <title>Patrón de comando</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-de-comando/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-de-comando/</guid>
      <description>Ejemplo de patrón de comando en Java # [wikipedia] definición:
El patrón de comando es un patrón de diseño de comportamiento en el que se usa un objeto para encapsular toda la información necesaria para realizar una acción o desencadenar un evento en un momento posterior
Diagrama UML de dofactory:
Componentes básicos y flujo de trabajo:
Command declara una interfaz para comandos abstractos como execute() Receptor sabe cómo ejecutar un comando en particular Invoker contiene ConcreteCommand, que debe ejecutarse Cliente crea ConcreteCommand y asigna Receptor ConcreteCommand define el vínculo entre Command y Receiver De esta forma, el patrón Command desacopla Sender (Cliente) de Receiver a través de Invoker.</description>
    </item>
    
    <item>
      <title>Patrón de repositorio</title>
      <link>https://www.wikiod.com/es/design-patterns/patron-de-repositorio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.wikiod.com/es/design-patterns/patron-de-repositorio/</guid>
      <description>Acerca de la implementación de IEnumerable&amp;lt;TEntity&amp;gt; Get(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; filter): La idea de esto es usar Expresiones como i =&amp;gt; x.id == 17 para escribir solicitudes genéricas. Es una forma de consultar datos sin utilizar el lenguaje de consulta específico de su tecnología. La implementación es bastante extensa, por lo tanto, es posible que desee considerar otras alternativas, como métodos específicos en sus repositorios implementados: un &amp;lsquo;CompanyRepository&amp;rsquo; imaginario podría proporcionar el método &amp;lsquo;GetByName (string name)&amp;rsquo;.</description>
    </item>
    
  </channel>
</rss>
